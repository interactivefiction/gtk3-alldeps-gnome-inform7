/* Tangled output generated by inweb-C: do not edit */
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <math.h>
#include <errno.h>
#include <errno.h>
#define TRUE 1
#define FALSE 0
#define NOT_APPLICABLE 2
#define MAX_FILENAME_LENGTH 1025
#define MAX_STRING_LENGTH 8*1024
#define UTF8_ENC 1 /* Write as UTF-8 without BOM */
#define ISO_ENC 2 /* Write as ISO Latin-1 (i.e., no conversion needed) */
#define LOG_INDENT STREAM_INDENT(DL)
#define LOG_OUTDENT STREAM_OUTDENT(DL)
#define DEBUGGING_LOG_INCLUSIONS_DA 0
#define SHELL_USAGE_DA 1
#define MEMORY_USAGE_DA 2
#define TEXT_FILES_DA 3
#define NO_INLIB_DAS 4
#define MAX_DAS 100
#define MEMORY_MANAGEMENT \
    	int allocation_id; /* Numbered from 0 upwards in creation order */\
    	void *next_structure; /* Next object in double-linked list */\
    	void *prev_structure; /* Previous object in double-linked list */
#define filename_MT 0
#define pathname_MT 1
#define string_storage_area_MT 2
#define simple_memory_claim_MT 3
#define scan_directory_MT 4
#define ebook_MT 5
#define ebook_datum_MT 6
#define ebook_volume_MT 7
#define ebook_chapter_MT 8
#define ebook_page_MT 9
#define ebook_image_MT 10
#define HTML_file_state_MT 11
#define text_stream_array_MT 12
#define command_line_switch_MT 13
#define NO_INLIB_MEMORY_TYPES 14 /* must be 1 more than the highest |_MT| constant above */
#define NO_MEMORY_TYPES (NO_INLIB_MEMORY_TYPES + NO_EXTRA_MEMORY_TYPES)
#define SAFETY_MARGIN 64
#define BLANK_END_SIZE 128
#define MAX_BLOCKS_ALLOWED 15000
#define MEMORY_GRANULARITY 100*1024*4 /* which must be divisible by 1024 */
#define INTEGRITY_NUMBER 0x12345678 /* a value unlikely to be in memory just by chance */
#define CREATE(type_name) (allocate_##type_name())
#define CREATE_BEFORE(existing, type_name) (allocate_##type_name##_before(existing))
#define DESTROY(this, type_name) (deallocate_##type_name(this))
#define FIRST_OBJECT(type_name) ((type_name *) alloc_status[type_name##_MT].first_in_memory)
#define LAST_OBJECT(type_name) ((type_name *) alloc_status[type_name##_MT].last_in_memory)
#define NEXT_OBJECT(this, type_name) ((type_name *) (this->next_structure))
#define PREV_OBJECT(this, type_name) ((type_name *) (this->prev_structure))
#define NUMBER_CREATED(type_name) (alloc_status[type_name##_MT].objects_count)
#define LOOP_OVER(var, type_name)\
    	for (var=FIRST_OBJECT(type_name); var != NULL; var = NEXT_OBJECT(var, type_name))
#define LOOP_BACKWARDS_OVER(var, type_name)\
    	for (var=LAST_OBJECT(type_name); var != NULL; var = PREV_OBJECT(var, type_name))
#define NEW_OBJECT(type_name) ((type_name *) Memory__allocate(type_name##_MT, sizeof(type_name)))
#define ALLOCATE_INDIVIDUALLY(type_name) \
    type_name *allocate_##type_name(void) {\
    	alloc_status[type_name##_MT].name_of_type = #type_name;\
    	type_name *prev_obj = LAST_OBJECT(type_name);\
    	type_name *new_obj = NEW_OBJECT(type_name);\
    	new_obj->allocation_id = alloc_status[type_name##_MT].objects_allocated-1;\
    	new_obj->next_structure = NULL;\
    	if (prev_obj != NULL)\
    		prev_obj->next_structure = (void *) new_obj;\
    	new_obj->prev_structure = prev_obj;\
    	alloc_status[type_name##_MT].objects_count++;\
    	return new_obj;\
    }\
    void deallocate_##type_name(type_name *kill_me) {\
    	type_name *prev_obj = PREV_OBJECT(kill_me, type_name);\
    	type_name *next_obj = NEXT_OBJECT(kill_me, type_name);\
    	if (prev_obj == NULL) {\
    		alloc_status[type_name##_MT].first_in_memory = next_obj;\
    	} else {\
    		prev_obj->next_structure = next_obj;\
    	}\
    	if (next_obj == NULL) {\
    		alloc_status[type_name##_MT].last_in_memory = prev_obj;\
    	} else {\
    		next_obj->prev_structure = prev_obj;\
    	}\
    	alloc_status[type_name##_MT].objects_count--;\
    }\
    type_name *allocate_##type_name##_before(type_name *existing) {\
    	type_name *new_obj = allocate_##type_name();\
    	deallocate_##type_name(new_obj);\
    	new_obj->prev_structure = existing->prev_structure;\
    	if (existing->prev_structure != NULL)\
    		((type_name *) existing->prev_structure)->next_structure = new_obj;\
    	else alloc_status[type_name##_MT].first_in_memory = (void *) new_obj;\
    	new_obj->next_structure = existing;\
    	existing->prev_structure = new_obj;\
    	alloc_status[type_name##_MT].objects_count++;\
    	return new_obj;\
    }
#define ALLOCATE_IN_ARRAYS(type_name, NO_TO_ALLOCATE_TOGETHER)\
    typedef struct type_name##_array {\
    	int used;\
    	struct type_name array[NO_TO_ALLOCATE_TOGETHER];\
    	MEMORY_MANAGEMENT\
    } type_name##_array;\
    ALLOCATE_INDIVIDUALLY(type_name##_array)\
    type_name##_array *next_##type_name##_array = NULL;\
    struct type_name *allocate_##type_name(void) {\
    	if ((next_##type_name##_array == NULL) ||\
    		(next_##type_name##_array->used >= NO_TO_ALLOCATE_TOGETHER)) {\
    		alloc_status[type_name##_array_MT].no_allocated_together = NO_TO_ALLOCATE_TOGETHER;\
    		next_##type_name##_array = allocate_##type_name##_array();\
    		next_##type_name##_array->used = 0;\
    	}\
    	return &(next_##type_name##_array->array[\
    		next_##type_name##_array->used++]);\
    }
#define STREAM_MREASON 0
#define FILENAME_STORAGE_MREASON 1
#define STRING_STORAGE_MREASON 2
#define NO_INLIB_MREASONS 3
#define NUMBER_OF_MREASONS (NO_INLIB_MREASONS + NO_EXTRA_MREASONS)
#define SSA_CAPACITY 64*1024
#define NEWLINE_IN_STRING ((char) 0x7f) /* Within quoted text, all newlines are converted to this */
#define OUTPUT_STREAM text_stream *OUT /* used only as a function prototype argument */
#define STDOUT Streams__get_stdout()
#define STDERR Streams__get_stderr()
#define PUT(c) Streams__putc(c, OUT)
#define PUT_TO(stream, c) Streams__putc(c, stream)
#define INDENT Streams__indent(OUT);
#define STREAM_INDENT(x) Streams__indent(x);
#define OUTDENT Streams__outdent(OUT);
#define STREAM_OUTDENT(x) Streams__outdent(x);
#define SET_INDENT(N) Streams__set_indentation(OUT, N);
#define TEMPORARY_TEXT(T) \
    	wchar_t T##_dest[2048];\
    	text_stream T##_stream_structure = Streams__new_buffer(2048, T##_dest);\
    	text_stream *T = &T##_stream_structure;
#define DISCARD_TEXT(T) \
    	STREAM_CLOSE(T);
#define TEMPORARY_STREAM TEMPORARY_TEXT(TEMP)
#define CLOSE_TEMPORARY_STREAM DISCARD_TEXT(TEMP)
#define STREAM_OPEN_TO_FILE(new, fn, enc) Streams__open_to_file(new, fn, enc)
#define STREAM_OPEN_TO_FILE_APPEND(new, fn, enc) Streams__open_to_file_append(new, fn, enc)
#define STREAM_OPEN_IN_MEMORY(new) Streams__open_to_memory(new, 20480)
#define SMALL_STREAM_OPEN_IN_MEMORY(new) Streams__open_to_memory(new, 1024)
#define STREAM_CLOSE(stream) Streams__close(stream)
#define STREAM_NEW CREATE(text_stream)
#define STREAM_FLUSH(stream) Streams__flush(stream)
#define STREAM_EXTENT(x) Streams__get_position(x)
#define STREAM_MUST_BE_IN_MEMORY(x) \
    	if ((x != NULL) && (x->write_to_memory == NULL))\
    		internal_error("text_stream not in memory");
#define STREAM_BACKSPACE(x) Streams__set_position(x, Streams__get_position(x) - 1)
#define STREAM_ERASE_BACK_TO(start_position) Streams__set_position(OUT, start_position)
#define STREAM_MOST_RECENT_CHAR(x) Streams__latest(x)
#define STREAM_COPY(to, from) Streams__copy(to, from)
#define MALLOCED_STRF 0x00000001 /* was the |write_to_memory| pointer claimed by |malloc|? */
#define USES_XML_ESCAPES_STRF 0x00000002 /* see above */
#define USES_LOG_ESCAPES_STRF 0x00000004 /* |WRITE| to this stream supports |$| escapes */
#define INDENT_PENDING_STRF 0x00000008 /* we have just ended a line, so further text should indent */
#define FILE_ENCODING_ISO_STRF 0x00000010 /* relevant only for file streams */
#define FILE_ENCODING_UTF8_STRF 0x00000020 /* relevant only for file streams */
#define INDENTATION_BASE_STRF 0x00010000 /* number of tab stops in from the left margin */
#define INDENTATION_MASK_STRF 0x0FFF0000 /* (held in these bits) */
#define SPACE_AT_END_OF_STREAM 6
#define STRING(S) \
    	text_stream S##_struct; text_stream *S = Str__from_wide_string(&S##_struct, NULL);
#define STRING_INIT(S, T)\
    	text_stream S##_struct; text_stream *S = Str__from_wide_string(&S##_struct, T);
#define STRING_FROM_LOCALE(S, T)\
    	text_stream S##_struct; text_stream *S = Str__from_locale_string(&S##_struct, T);
#define STRING_FINISHED_WITH(S) \
    	Streams__close(S); S = NULL;
#define LOOP_THROUGH_TEXT(P, ST)\
    	for (string_position P = Str__start(ST); P.index < Str__len(P.S); P = Str__forward(P))
#define LOOP_BACKWARDS_THROUGH_TEXT(P, ST)\
    	for (string_position P = Str__back(Str__end(ST)); P.index >= 0; P = Str__back(P))
#define internal_error(message) Errors__fatal_with_C_string("internal error (%s)", message)
#define LOG_CLSW 0
#define PLATFORM_CLSW 1
#define CRASH_CLSW 2
#define NO_INLIB_CLSWS 3
#define FORMAT_PERHAPS_HTML 1
#define FORMAT_PERHAPS_JPEG 2
#define FORMAT_PERHAPS_PNG 3
#define FORMAT_PERHAPS_OGG 4
#define FORMAT_PERHAPS_AIFF 5
#define FORMAT_PERHAPS_MIDI 6
#define FORMAT_PERHAPS_MOD 7
#define FORMAT_PERHAPS_GLULX 8
#define FORMAT_PERHAPS_ZCODE 9
#define FORMAT_PERHAPS_SVG 10
#define FORMAT_PERHAPS_GIF 11
#define FORMAT_UNRECOGNISED 0
#define MAX_BRACKETED_SUBEXPRESSIONS 4 /* up to four bracketed subexpressions can be extracted */
#define ANY_CLASS 1
#define DIGIT_CLASS 2
#define WHITESPACE_CLASS 3
#define NONWHITESPACE_CLASS 4
#define IDENTIFIER_CLASS 5
#define PREFORM_CLASS 6
#define PREFORMC_CLASS 7
#define LITERAL_CLASS 8
#define TAB_CLASS 9
#define ANY_CLASS 1
#define DIGIT_CLASS 2
#define WHITESPACE_CLASS 3
#define NONWHITESPACE_CLASS 4
#define IDENTIFIER_CLASS 5
#define PREFORM_CLASS 6
#define PREFORMC_CLASS 7
#define LITERAL_CLASS 8
#define TAB_CLASS 9
#define MAX_TAG_STACK_SIZE 16 /* check tags nested only this far */
#define ADD_TO_LL(B, P, type) {\
    	P->next_##type = NULL;\
    	if (B->type##_list == NULL) B->type##_list = P;\
    	else {\
    		type *Q = B->type##_list;\
    		while ((Q) && (Q->next_##type)) Q = Q->next_##type;\
    		Q->next_##type = P;\
    	}\
    }
#define INTOOL_NAME "inweb"
#define INWEB_BUILD "inweb 7/151208 ('Escape to Danger')"
#define bibliographic_datum_MT NO_INLIB_MEMORY_TYPES
#define chapter_MT NO_INLIB_MEMORY_TYPES+1
#define section_MT NO_INLIB_MEMORY_TYPES+2
#define tangle_target_MT NO_INLIB_MEMORY_TYPES+3
#define source_line_array_MT NO_INLIB_MEMORY_TYPES+4
#define web_MT NO_INLIB_MEMORY_TYPES+5
#define paragraph_MT NO_INLIB_MEMORY_TYPES+6
#define cweb_macro_MT NO_INLIB_MEMORY_TYPES+7
#define programming_language_MT NO_INLIB_MEMORY_TYPES+8
#define c_structure_MT NO_INLIB_MEMORY_TYPES+9
#define structure_dependence_MT NO_INLIB_MEMORY_TYPES+10
#define function_MT NO_INLIB_MEMORY_TYPES+11
#define preform_nonterminal_MT NO_INLIB_MEMORY_TYPES+12
#define nonterminal_variable_MT NO_INLIB_MEMORY_TYPES+13
#define weave_target_MT NO_INLIB_MEMORY_TYPES+14
#define macro_usage_MT NO_INLIB_MEMORY_TYPES+15
#define weave_format_MT NO_INLIB_MEMORY_TYPES+16
#define hash_table_entry_MT NO_INLIB_MEMORY_TYPES+17
#define hash_table_entry_usage_MT NO_INLIB_MEMORY_TYPES+18
#define structure_element_MT NO_INLIB_MEMORY_TYPES+19
#define structure_permission_MT NO_INLIB_MEMORY_TYPES+20
#define theme_tag_MT NO_INLIB_MEMORY_TYPES+21
#define paragraph_tag_MT NO_INLIB_MEMORY_TYPES+22
#define tex_results_MT NO_INLIB_MEMORY_TYPES+23
#define imported_header_MT NO_INLIB_MEMORY_TYPES+24
#define NO_EXTRA_MEMORY_TYPES 25
#define NO_EXTRA_MREASONS 0
#define NO_MODE 0 /* a special mode for doing nothing except printing command-line syntax */
#define ANALYSE_MODE 1
#define TANGLE_MODE 2
#define WEAVE_MODE 3
#define CREATE_MODE 4 /* a special mode for creating a new web, not acting on an existing one */
#define SWARM_OFF 0
#define SWARM_INDEX 1 /* make index(es) as if swarming, but don't actually swarm */
#define SWARM_CHAPTERS 2 /* swarm the chapters */
#define SWARM_SECTIONS 4 /* swarm the individual sections */
#define SWARM_COMPLETE 8 /* also include the complete text */
#define LOOP_OVER_BIBLIOGRAPHIC_DATA(bd, W)\
    	for (bd = W->first_bd; bd; bd = bd->next_bd)
#define NO_LCAT 0                 /* none set as yet */
#define CHAPTER_HEADING_LCAT 1    /* chapter heading line inserted automatically, not read from web */
#define SECTION_HEADING_LCAT 2    /* section heading line, at top of file */
#define PURPOSE_LCAT 3            /* first line of |@Purpose:| declaration; TO is rest of line */
#define INTERFACE_LCAT 4          /* line holding the |@Interface:| heading */
#define INTERFACE_BODY_LCAT 5     /* line within the interface, under this heading */
#define DEFINITIONS_LCAT 6        /* line holding the |@Definitions:| heading */
#define BAR_LCAT 7                /* a bar line |@---------------|... */
#define PB_PARAGRAPH_START_LCAT 8 /* |@p| or |@pp| paragraph start: TO is title, TO2 is rest of line */
#define PARAGRAPH_START_LCAT 9    /* simple |@| paragraph start: TO is blank, TO2 is rest of line */
#define COMMENT_BODY_LCAT 10      /* text following a paragraph header, which is all comment */
#define SOURCE_DISPLAY_LCAT 11    /* commentary line beginning |>>| for display: TO is display text */
#define MACRO_DEFINITION_LCAT 12  /* line on which a CWEB macro is defined with an |=| sign */
#define BEGIN_VERBATIM_LCAT 13    /* an |@c|, |@e| or |@x| line below which is code, early code or extract */
#define CODE_BODY_LCAT 14         /* the rest of the paragraph under an |@c| or |@e| or macro definition */
#define TEXT_EXTRACT_LCAT 15      /* the rest of the paragraph under an |@x| */
#define TOGGLE_WEAVING_LCAT 16    /* a line telling the weaver to toggle code weaving on or off */
#define BEGIN_DEFINITION_LCAT 17  /* an |@d| definition: TO is term, TO2 is this line's part of defn */
#define CONT_DEFINITION_LCAT 18   /* subsequent lines of an |@d| definition */
#define COMMAND_LCAT 19           /* a |[[Command]]| line, with the operand set to the |*_CMD| value */
#define C_LIBRARY_INCLUDE_LCAT 20 /* C-like languages only: a |#include| for an ANSI C header file */
#define TYPEDEF_LCAT 21           /* C-like languages only: a |typedef| which isn't a structure definition */
#define PREFORM_LCAT 22           /* C-for-Inform only: opening line of a Preform nonterminal */
#define PREFORM_GRAMMAR_LCAT 23   /* C-for-Inform only: line of Preform grammar */
#define PURPOSE_BODY_LCAT 24      /* continuation lines of |@Purpose:| declaration */
#define NO_CMD 0
#define PAGEBREAK_CMD 1
#define GRAMMAR_INDEX_CMD 2
#define FIGURE_CMD 3
#define TAG_CMD 4
#define LOOP_WITHIN_TANGLE(T) \
    	for (chapter *C = W->first_chapter; C; C = C->next_chapter)\
    		for (section *S = C->first_section; S; S = S->next_section)\
    			if (S->sect_target == T)\
    				for (source_line *L = S->first_line; L; L = L->next_line)
#define ORDINARY_WEIGHT 0 /* an ordinary |@| paragraph */
#define SUBHEADING_WEIGHT 1 /* an |@p| or |@pp| paragraph */
#define ELEMENT_ACCESS_USAGE 0x00000001 /* C-like languages: access via |->| or |.| operators to structure element */
#define FCALL_USAGE 0x00000002 /* C-like languages: function call made using brackets, |name(args)| */
#define PREFORM_IN_CODE_USAGE 0x00000004 /* C-for-Inform only: use of a Preform nonterminal as a C "constant" */
#define PREFORM_IN_GRAMMAR_USAGE 0x00000008 /* C-for-Inform only: ditto, but within Preform production rather than C code */
#define MISC_USAGE 0x00000010 /* any other appearance as an identifier */
#define ANY_USAGE 0x7fffffff /* any of the above */
#define HASH_TAB_SIZE 1000 /* the possible hash codes are 0 up to this minus 1 */
#define NUMBER_HASH 0 /* literal decimal integers, and no other words, have this hash code */
#define TRACE_CI_EXECUTION FALSE /* set true for debugging */
#define MAX_TEMPLATE_LINES 256 /* maximum number of lines in template */
#define CI_STACK_CAPACITY 8 /* maximum recursion of chapter/section iteration */
#define CHAPTER_LEVEL 1
#define SECTION_LEVEL 2
#define REGULAR_MATERIAL 1
#define MACRO_MATERIAL 2       /* when a macro is being defined... */
#define DEFINITION_MATERIAL 3  /* ...versus when an |@d| definition is being made */
#define CODE_MATERIAL 4
#define WEAVE_FIRST_HALF 1
#define WEAVE_SECOND_HALF 2
#define IN_SECOND_HALF 4
#define SHOW_INTERFACES FALSE
#define LOOP_OVER_PARAGRAPHS(T) \
    	for (chapter *C = W->first_chapter; C; C = C->next_chapter)\
    		for (section *S = C->first_section; S; S = S->next_section)\
    			if (S->sect_target == T)\
    				for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
#define MAX_ARG_LINES 8 /* maximum number of lines over which a function's header can extend */
#define INFINITE_WORD_COUNT 1000000000
#define NOT_A_NONTERMINAL -4
#define A_FLEXIBLE_NONTERMINAL -3
#define A_VORACIOUS_NONTERMINAL -2
#define A_GRAMMAR_NONTERMINAL -1
#define MACRO_CODE 1
#define FUNCTION_CODE 2
#define RESERVED_CODE 3
#define ELEMENT_CODE 4
#define IDENTIFIER_CODE 5
#define CHAR_LITERAL_CODE 6
#define CONSTANT_CODE 7
#define STRING_CODE 8
#define PLAIN_CODE 9
#define HTML_OUT 0 /* write position in HTML file is currently outside of p, pre, li */
#define HTML_IN_P 1 /* write position in HTML file is currently outside p */
#define HTML_IN_PRE 2 /* write position in HTML file is currently outside pre */
#define HTML_IN_LI 3 /* write position in HTML file is currently outside li */
typedef char string[MAX_STRING_LENGTH+1];
#line 43 "inlib/Chapter 2/Debugging Log.w"
typedef struct debugging_aspect {
	struct text_stream *hyphenated_name; /* e.g., "memory-usage" */
	struct text_stream *negated_name; /* e.g., "no-memory-usage" */
	struct text_stream *unhyphenated_name; /* e.g., "memory-usage" */
	int on_or_off; /* whether or not active when writing to debugging log */
	int alternate; /* whether or not active when writing in trace mode */
} debugging_aspect;
#line 34 "inlib/Chapter 2/Memory.w"
typedef struct simple_memory_claim {
	void *memory_claimed; /* position in memory of the array allocated */
	int extent_of_claim; /* total number of bytes making it up */
	MEMORY_MANAGEMENT
} simple_memory_claim;
#line 73 "inlib/Chapter 2/Memory.w"
typedef struct allocation_status_structure {

	/* actually needed for allocation purposes: */
	int objects_allocated; /* total number of objects (or arrays) ever allocated */
	void *first_in_memory; /* head of doubly linked list */
	void *last_in_memory; /* tail of doubly linked list */

	/* used only to provide statistics for the debugging log: */
	char *name_of_type; /* e.g., |"lexicon_entry_MT"| */
	int bytes_allocated; /* total allocation for this type of object, not counting overhead */
	int objects_count; /* total number currently in existence (i.e., undeleted) */
	int no_allocated_together; /* number of objects in each array of this type of object */
} allocation_status_structure;
#line 156 "inlib/Chapter 2/Memory.w"
typedef struct memblock_header {
	int block_number;
	struct memblock_header *next;
	char *the_memory;
} memblock_header;
#line 240 "inlib/Chapter 2/Memory.w"
typedef struct memory_frame {
	int integrity_check; /* this should always contain the |INTEGRITY_NUMBER| */
	struct memory_frame *next_frame; /* next frame in the list of memory frames */
	int mem_type; /* type of object stored in this frame */
	int allocation_id; /* allocation ID number of object stored in this frame */
} memory_frame;
#line 658 "inlib/Chapter 2/Memory.w"
typedef struct string_storage_area {
	char *storage_at;
	int first_free_byte;
	MEMORY_MANAGEMENT
} string_storage_area;
#line 211 "inlib/Chapter 2/Streams.w"
typedef struct text_stream {
	int stream_flags; /* bitmap of the |*_STRF| values above */
	FILE *write_to_file; /* for an open stream, exactly one of these is |NULL| */
	struct HTML_file_state *as_HTML; /* relevant only to the |HTML::| section */
	wchar_t *write_to_memory;
	struct filename *file_written; /* ditto */
	int chars_written; /* number of characters sent, counting |\n| as 1 */
	int chars_capacity; /* maximum number the stream can accept without claiming more resources */
	struct text_stream *stream_continues; /* if one memory stream is extended by another */
} text_stream;
#line 147 "inlib/Chapter 2/String Manipulation.w"
typedef struct string_position {
	struct text_stream *S;
	int index;
} string_position;
#line 15 "inlib/Chapter 2/Command Line Arguments.w"
typedef struct command_line_switch {
	int switch_id;
	struct text_stream *switch_name; /* e.g., |log| */
	int valency; /* 1 for bare, 2 for one argument follows */
	MEMORY_MANAGEMENT
} command_line_switch;
#line 13 "inlib/Chapter 3/Filenames.w"
typedef struct filename {
	struct pathname *pathname_of_location;
	struct text_stream *leafname;
	MEMORY_MANAGEMENT
} filename;
#line 38 "inlib/Chapter 3/Pathnames.w"
typedef struct pathname {
	struct text_stream *intermediate;
	struct pathname *pathname_of_parent;
	int known_to_exist; /* corresponds to a directory in the filing system */
	MEMORY_MANAGEMENT
} pathname;
#line 9 "inlib/Chapter 3/Directories.w"
typedef struct scan_directory {
	void *directory_handle;
	char directory_name_written_out[MAX_FILENAME_LENGTH];
	MEMORY_MANAGEMENT
} scan_directory;
#line 9 "inlib/Chapter 4/Text Files.w"
typedef struct text_file_position {
	struct filename *text_file_filename;
	int line_count;
	int line_position;
	int skip_terminator;
	int actively_scanning; /* whether we are still interested in the rest of the file */
} text_file_position;
#line 285 "inlib/Chapter 4/Text Files.w"
typedef struct unicode_file_buffer {
	char unicode_feed_buffer[32]; /* holds a single escape such as "[unicode 3106]" */
	int ufb_counter; /* position in the unicode feed buffer */
} unicode_file_buffer;
#line 90 "inlib/Chapter 4/Pattern Matching.w"
typedef struct X_match_position {
	int tpos; /* position within text being matched */
	int ppos; /* position within pattern */
	int bc; /* count of bracketed subexpressions so far begun */
	int bl; /* bracket indentation level */
	int bracket_nesting[MAX_BRACKETED_SUBEXPRESSIONS]; /* which subexpression numbers (0, 1, 2, 3) correspond to which nesting */
	int brackets_start[MAX_BRACKETED_SUBEXPRESSIONS], brackets_end[MAX_BRACKETED_SUBEXPRESSIONS]; /* positions in text being matched, inclusive */
} X_match_position;
#line 102 "inlib/Chapter 4/Pattern Matching.w"
typedef struct match_result {
	wchar_t match_text_storage[64];
	struct text_stream match_text_struct;
} match_result;
#line 106 "inlib/Chapter 4/Pattern Matching.w"
typedef struct match_results {
	int no_matched_texts;
	struct match_result exp_storage[MAX_BRACKETED_SUBEXPRESSIONS];
	struct text_stream *exp[MAX_BRACKETED_SUBEXPRESSIONS];
} match_results;
#line 92 "inlib/Chapter 4/ISO Pattern Matching.w"
typedef struct match_position {
	int tpos; /* position within text being matched */
	int ppos; /* position within pattern */
	int bc; /* count of bracketed subexpressions so far begun */
	int bl; /* bracket indentation level */
	int bracket_nesting[4]; /* which subexpression numbers (0, 1, 2, 3) correspond to which nesting */
	int brackets_start[4], brackets_end[4]; /* positions in text being matched, inclusive */
} match_position;
#line 12 "inlib/Chapter 5/HTML.w"
typedef struct HTML_file_state {
	int XHTML_flag;
	char *tag_stack[MAX_TAG_STACK_SIZE];
	int tag_sp;
	MEMORY_MANAGEMENT
} HTML_file_state;
#line 23 "inlib/Chapter 5/Epub Ebooks.w"
typedef struct ebook {
	struct ebook_datum *metadata_list; /* DCMI-standard bibliographic data */

	struct filename *eventual_epub; /* filename of the final |*.epub| to be made */
	struct pathname *holder; /* directory to put the ingredients into */
	struct pathname *OEBPS_path; /* subdirectory which mysteriously has to be called |OEBPS| */
	struct filename *CSS_file; /* where to find the CSS file to be included */

	struct ebook_volume *ebook_volume_list;
	struct ebook_volume *current_volume; /* the one to which chapters are now being added */

	struct ebook_chapter *ebook_chapter_list;
	struct ebook_chapter *current_chapter; /* the one to which pages are now being added */

	struct ebook_page *ebook_page_list;
	struct ebook_image *ebook_image_list;
	MEMORY_MANAGEMENT
} ebook;
#line 47 "inlib/Chapter 5/Epub Ebooks.w"
typedef struct ebook_datum {
	struct text_stream *key;
	struct text_stream *value;
	struct ebook_datum *next_metadatum;
	MEMORY_MANAGEMENT
} ebook_datum;
#line 57 "inlib/Chapter 5/Epub Ebooks.w"
typedef struct ebook_volume {
	struct text_stream *volume_title;
	struct ebook_page *volume_starts; /* on which page the volume starts */
	struct ebook_volume *next_ebook_volume;
	MEMORY_MANAGEMENT
} ebook_volume;
#line 64 "inlib/Chapter 5/Epub Ebooks.w"
typedef struct ebook_chapter {
	struct text_stream *chapter_title;
	struct ebook_volume *in_volume; /* to which volume this chapter belongs */
	struct ebook_page *chapter_starts; /* on which page the chapter starts */
	struct ebook_chapter *next_ebook_chapter;
	MEMORY_MANAGEMENT
} ebook_chapter;
#line 76 "inlib/Chapter 5/Epub Ebooks.w"
typedef struct ebook_page {
	struct text_stream *page_title;
	struct text_stream *page_type;
	struct text_stream *page_ID;

	struct filename *relative_URL; /* eventual URL of this page within the ebook */

	struct ebook_volume *in_volume; /* to which volume this page belongs */
	struct ebook_chapter *in_chapter; /* to which chapter this page belongs */

	struct ebook_page *next_ebook_page;
	int nav_entry_written; /* keep track of what we've written to the navigation tree */

	MEMORY_MANAGEMENT
} ebook_page;
#line 92 "inlib/Chapter 5/Epub Ebooks.w"
typedef struct ebook_image {
	struct text_stream *image_ID;
	struct filename *relative_URL; /* eventual URL of this image within the ebook */
	struct ebook_image *next_ebook_image;
	MEMORY_MANAGEMENT
} ebook_image;
#line 11 "inweb/Chapter 1/Configuration.w"
typedef struct inweb_instructions {
	int inweb_mode; /* our main mode of operation: one of the |*_MODE| constants */
	struct pathname *chosen_web; /* project folder relative to cwd */
	string chosen_subweb; /* which subset of this web we apply to (often, all of it) */

	int swarm_mode; /* relevant to weaving only: one of the |*_SWARM| constants */
	string theme_setting; /* |-theme X|: theme for a topic-restricted weave */
	string weave_format; /* |-format X|: for example, |-format TeX| */

	int catalogue_switch; /* |-catalogue|: print catalogue of sections */
	int functions_switch; /* |-functions|: print catalogue of functions within sections */
	int open_pdf_switch; /* |-open-pdf|: open any woven PDF in the OS once it is made */
	int scan_switch; /* |-scan|: simply show the syntactic scan of the source */
	struct filename *tangle_setting; /* |-tangle X|: the pathname X, if supplied */
	int verbose_switch; /* |-verbose|: print names of files read to stdout */

	struct pathname *location_setting; /* |-at X|: where this program is */
	struct pathname *import_setting; /* |-import X|: where to find imported webs */
} inweb_instructions;
#line 11 "inweb/Chapter 2/Bibliographic Data.w"
typedef struct bibliographic_datum {
	string key;
	string value;
	int declaration_permitted; /* is the contents page of the web allowed to set this? */
	int declaration_mandatory; /* is it positively required to? */
	int on_or_off; /* boolean: which we handle as the string "On" or "Off" */
	struct bibliographic_datum *alias;
	struct bibliographic_datum *next_bd; /* within the linked list for a web */
	MEMORY_MANAGEMENT
} bibliographic_datum;
#line 16 "inweb/Chapter 2/Line Categories.w"
typedef struct source_line {
	char *text; /* the text as read in */
	char *text_operand; /* meaning depends on category */
	char *text_operand2; /* meaning depends on category */

	int category; /* what sort of line this is: an |*_LCAT| value */
	int command_code; /* used only for |COMMAND_LCAT| lines: a |*_CMD| value */
	int is_commentary; /* flag */
	struct function *function_defined; /* if any C-like function is defined on this line */
	struct preform_nonterminal *preform_nonterminal_defined; /* similarly */
	int suppress_tangling; /* if e.g., lines are tangled out of order */
	int interface_line_identified; /* only relevant during parsing of Interface lines */

	struct text_file_position source; /* which file this was read in from, if any */

	struct section *owning_section; /* for interleaved title lines, it's the one about to start */
	struct source_line *next_line; /* within the owning section's linked list */
	struct paragraph *owning_paragraph; /* for lines falling under paragraphs; |NULL| if not */
} source_line;
#line 24 "inweb/Chapter 2/Reading Sections.w"
typedef struct web {
	struct pathname *path_to_web; /* relative to the current working directory */

	/* convenient statistics */
	int no_lines; /* total lines in literate source, excluding contents */
	int no_paragraphs; /* this will be at least 1 */
	int no_sections; /* again, excluding contents: it will eventually be at least 1 */
	int no_chapters; /* this will be at least 1 */
	int chaptered; /* has the author explicitly divided it into named chapters? */
	int analysed; /* has this been scanned for function usage and such? */

	struct bibliographic_datum *first_bd; /* key-value pairs for title, author and such */
	struct programming_language *main_language; /* in which most of the sections are written */

	struct chapter *first_chapter; /* two ends of a linked list */
	struct chapter *last_chapter;

	struct imported_header *first_header; /* two ends of a linked list */
	struct imported_header *last_header;

	struct c_structure *first_c_structure; /* two ends of a linked list, used only for C */
	struct c_structure *last_c_structure;

	struct tangle_target *first_target; /* linked list of tangle targets */

	struct ebook *as_ebook; /* when being woven to an ebook */
	struct pathname *redirect_weaves_to; /* ditto */
	MEMORY_MANAGEMENT
} web;
#line 91 "inweb/Chapter 2/Reading Sections.w"
typedef struct chapter {
	string ch_sigil; /* e.g., |P| for Preliminaries, |7| for Chapter 7, |C| for Appendix C */
	string ch_title; /* e.g., "Chapter 3: Fresh Water Fish" */
	string rubric; /* optional; without double-quotation marks */

	string woven_pdf_leafname; /* a leafname for a standalone weave of this chapter */
	struct tangle_target *ch_target; /* |NULL| unless this chapter produces a tangle of its own */
	struct weave_target *ch_weave; /* |NULL| unless this chapter produces a weave of its own */
	struct programming_language *ch_language; /* in which most of the sections are written */

	int titling_line_inserted; /* has an interleaved chapter heading been added yet? */

	int ch_extent; /* total number of lines in the sections of this chapter */
	struct section *first_section; /* two ends of a linked list */
	struct section *last_section;

	struct web *owning_web;
	int imported; /* from a different web? */
	struct chapter *next_chapter; /* within the owning web's linked list */
	MEMORY_MANAGEMENT
} chapter;
#line 116 "inweb/Chapter 2/Reading Sections.w"
typedef struct section {
	string sigil; /* e.g., "9/tfto" */
	string sect_title; /* e.g., "Program Control" */
	string sect_namespace; /* e.g., "Text::Languages::" */
	string sect_purpose; /* e.g., "To manage the zoo, and feed all penguins" */
	int barred; /* contains a dividing bar? */

	struct filename *source_file_for_section;

	struct tangle_target *sect_target; /* |NULL| unless this section produces a tangle of its own */
	struct weave_target *sect_weave; /* |NULL| unless this section produces a weave of its own */
	struct programming_language *sect_language; /* in which this section is written */

	int sect_extent; /* total number of lines in this section */
	struct source_line *first_line; /* two ends of a linked list */
	struct source_line *last_line;

	int sect_paragraphs; /* total number of paragraphs in this section */
	struct paragraph *first_paragraph; /* two ends of a linked list */
	struct paragraph *last_paragraph;
	struct theme_tag *tag_with; /* automatically tag paras in this section thus */

	struct cweb_macro *first_macro; /* two ends of a linked list */
	struct cweb_macro *last_macro;

	struct chapter *owning_chapter;
	struct section *next_section; /* within the owning chapter's linked list */

	int scratch_flag; /* temporary workspace */
	int erroneous_interface; /* problem with Interface declarations */
	MEMORY_MANAGEMENT
} section;
#line 163 "inweb/Chapter 2/Reading Sections.w"
typedef struct reader_state {
	struct web *current_web;
	int in_biblio;
	int in_purpose; /* Reading the bit just after the new chapter? */
	struct chapter *chapter_being_scanned;
	string chapter_folder_name; /* Where sections in the current chapter live */
	string titling_line_to_insert; /* To be inserted automagically */
	struct pathname *path_to; /* Where web material is being read from */
	struct pathname *import_from; /* Where imported webs are */
	int scan_verbosely;
	int in_original; /* Reading the original web, or an included one? */
} reader_state;
#line 187 "inweb/Chapter 3/The Analyser.w"
typedef struct hash_table {
	struct hash_table_entry *analysis_hash[HASH_TAB_SIZE]; /* linked list of identifiers sharing this hash code */
	int analysis_hash_initialised; /* when we start up, array's contents are undefined */
} hash_table;
#line 646 "inweb/Chapter 2/Reading Sections.w"
typedef struct tangle_target {
	struct programming_language *tangle_language; /* common to the entire contents */
	struct hash_table symbols; /* a table of identifiable names in this program */
	struct tangle_target *next_target; /* within the web's linked list */
	MEMORY_MANAGEMENT
} tangle_target;
#line 682 "inweb/Chapter 2/Reading Sections.w"
typedef struct imported_header {
	struct filename *header_file;
	struct imported_header *next_header;
	MEMORY_MANAGEMENT
} imported_header;
#line 207 "inweb/Chapter 2/The Parser.w"
typedef struct cweb_macro {
	string macro_name;
	struct paragraph *defining_paragraph; /* as printed in small type after the name in any usage */
	struct source_line *defn_start; /* it ends at the end of its defining paragraph */
	struct cweb_macro *next_macro; /* within the owning section's linked list */
	struct macro_usage *macro_usages; /* only computed for weaves, since unnecessary for tangles */
	MEMORY_MANAGEMENT
} cweb_macro;
#line 401 "inweb/Chapter 2/The Parser.w"
typedef struct paragraph {
	int above_bar; /* placed above the dividing bar in its section */
	int placed_early; /* should appear early in the tangled code */
	char *ornament; /* a "P" for a pilcrow or "S" for section-marker */
	string paragraph_number; /* used in combination with the ornament */
	int next_child_number; /* used when working out paragraph numbers */
	struct paragraph *parent_paragraph; /* ditto */
	int starts_on_new_page; /* relevant for weaving to |TeX| only, of course */
	int weight; /* typographic prominence: one of the |*_WEIGHT| values */
	struct cweb_macro *defines_macro; /* there can only be one */
	struct function *first_defined_in_paragraph; /* there can be several */
	struct c_structure *first_c_structure_in_para; /* similarly */
	struct c_structure *last_c_structure_in_para; /* similarly */
	struct paragraph_tag *tags; /* a linked list */

	struct source_line *first_line_in_paragraph; /* a linked list */

	struct section *under_section;
	struct paragraph *next_paragraph_in_section; /* within the owning section's linked list */
	MEMORY_MANAGEMENT
} paragraph;
#line 500 "inweb/Chapter 2/The Parser.w"
typedef struct theme_tag {
	string tag_name;
	string title_when_woven;
	string leafname_when_woven;
	string cover_sheet_when_woven;
	MEMORY_MANAGEMENT
} theme_tag;
#line 524 "inweb/Chapter 2/The Parser.w"
typedef struct paragraph_tag {
	struct theme_tag *the_tag;
	struct paragraph_tag *next_tag;
	string caption;
	MEMORY_MANAGEMENT
} paragraph_tag;
#line 51 "inweb/Chapter 2/Paragraph Numbering.w"
typedef struct macro_usage {
	struct paragraph *used_in_paragraph;
	int multiplicity; /* for example, 2 if it's used twice in this paragraph */
	struct macro_usage *next_macro_usage; /* within the list of uses of the macro */
	MEMORY_MANAGEMENT
} macro_usage;
#line 195 "inweb/Chapter 3/The Analyser.w"
typedef struct hash_table_entry {
	char *hash_key;
	struct hash_table_entry *next_in_hash; /* i.e., in list of identifiers sharing this hash code */
	int reserved_word; /* in the language currently being woven, that is */
	struct hash_table_entry_usage *first_usage; /* a linked list of all known usages */
	struct hash_table_entry_usage *last_usage;
	MEMORY_MANAGEMENT
} hash_table_entry;
#line 255 "inweb/Chapter 3/The Analyser.w"
typedef struct hash_table_entry_usage {
	struct paragraph *usage_recorded_at;
	int form_of_usage; /* bitmap of the |*_USAGE| constants defined above */
	struct hash_table_entry_usage *next_usage; /* i.e., in the list of usages of this identifier */
	MEMORY_MANAGEMENT
} hash_table_entry_usage;
#line 72 "inweb/Chapter 3/The Swarm.w"
typedef struct weave_target {
	struct web *weave_web; /* which web we weave */
	string weave_sigil; /* which parts of the web in this weave */
	struct theme_tag *theme_match; /* pick out only paragraphs with this theme */
	string booklet_title;
	struct filename *weave_to; /* where to put it */
	struct weave_format *format; /* plain text, say, or HTML */
	struct filename *cover_sheet_to_use; /* leafname of the copy, or |NULL| for no cover */
	void *post_processing_results; /* optional typesetting diagnostics after running through */
	MEMORY_MANAGEMENT
} weave_target;
#line 249 "inweb/Chapter 3/The Swarm.w"
typedef struct contents_processor {
	char *tlines[MAX_TEMPLATE_LINES];
	int no_tlines;
	int repeat_stack_level[CI_STACK_CAPACITY];
	void *repeat_stack_variable[CI_STACK_CAPACITY];
	void *repeat_stack_threshold[CI_STACK_CAPACITY];
	int repeat_stack_startpos[CI_STACK_CAPACITY];
	int stack_pointer;
	char *restrict_to_subweb;
} contents_processor;
#line 65 "inweb/Chapter 3/The Weaver.w"
typedef struct weaver_state {
	int kind_of_material; /* one of the defined |*_MATERIAL| constants above */
	int line_break_pending;
	int weaving_suspended; /* because of ...and so on... markers? */
	int next_heading_without_vertical_skip;
	int show_section_toc_soon; /* is a table of contents for the section imminent? */
	int horizontal_rule_just_drawn;
	struct section *last_extract_from;
	struct paragraph *last_endnoted_para;
	int substantive_comment;
	string chaptermark;
	string sectionmark;
} weaver_state;
#line 24 "inweb/Chapter 4/Programming Languages.w"
typedef struct programming_language {
	char *language_name;
	char *file_extension; /* by default output to a file whose name has this extension */
	char *source_file_extension; /* by default input from a file whose name has this extension */
	char *shebang; /* compulsory content on line 1 */
	int c_like; /* does this belong to the C family of languages? */
	MEMORY_MANAGEMENT
} programming_language;
#line 27 "inweb/Chapter 4/C-Like Languages.w"
typedef struct c_structure {
	string structure_name;
	int tangled; /* whether the structure definition has been tangled out */
	struct source_line *typedef_begins; /* opening line of |typedef| */
	struct source_line *typedef_ends; /* closing line, where |}| appears */
	struct section *declared_owner;
	int declared_private;
	struct structure_dependence *first_dependence; /* double-ended linked list */
	struct structure_dependence *last_dependence;
	struct structure_element *first_element; /* double-ended linked list */
	struct structure_element *last_element;
	struct structure_permission *first_permission; /* double-ended linked list */
	struct structure_permission *last_permission;
	struct c_structure *next_c_structure; /* in the linked list for its web */
	struct c_structure *next_c_structure_in_para; /* and for its paragraph */
	struct c_structure *next_cst_alphabetically;
	MEMORY_MANAGEMENT
} c_structure;
#line 51 "inweb/Chapter 4/C-Like Languages.w"
typedef struct structure_element {
	string element_name;
	struct structure_element *next_element;
	struct source_line *element_created_at;
	int allow_sharing;
	MEMORY_MANAGEMENT
} structure_element;
#line 62 "inweb/Chapter 4/C-Like Languages.w"
typedef struct structure_permission {
	struct section *shared_with;
	struct source_line *granted_at;
	struct structure_permission *next_permission;
	MEMORY_MANAGEMENT
} structure_permission;
#line 74 "inweb/Chapter 4/C-Like Languages.w"
typedef struct structure_dependence {
	struct c_structure *incorporates; /* the structure being embedded */
	struct structure_dependence *next_dependence; /* in the linked list for its structure */
	MEMORY_MANAGEMENT
} structure_dependence;
#line 88 "inweb/Chapter 4/C-Like Languages.w"
typedef struct function {
	string function_name; /* e.g., |"cultivate"| */
	string function_type; /* e.g., |"tree *"| */
	string function_arguments; /* e.g., |"int rainfall)"|: note |)| */
	struct source_line *function_header_at; /* where the first line of the header begins */
	struct function *next_defined_in_paragraph;
	int within_namespace; /* written using C-for-Inform namespace dividers */
	int called_from_other_sections;
	int call_freely;
	MEMORY_MANAGEMENT
} function;
#line 21 "inweb/Chapter 4/C for Inform.w"
typedef struct preform_nonterminal {
	string nt_name; /* e.g., |"<action-clause>"| */
	string unangled_name; /* e.g., |"action-clause"| */
	string as_C_identifier; /* e.g., |"action_clause_NTM"| */
	int as_function; /* defined internally, that is, parsed by a C function */
	int voracious; /* a voracious nonterminal: see {\it The English Syntax of Inform} */
	int min_word_count; /* for internals only */
	int max_word_count;
	int takes_pointer_result; /* right-hand formula defines |*XP|, not |*X| */
	struct source_line *where_defined;
	struct preform_nonterminal *next_pnt_alphabetically;
	MEMORY_MANAGEMENT
} preform_nonterminal;
#line 35 "inweb/Chapter 4/C for Inform.w"
typedef struct nonterminal_variable {
	string ntv_name; /* e.g., |"num"| */
	string ntv_type; /* e.g., |"int"| */
	string ntv_identifier; /* e.g., |"num_NTMV"| */
	struct source_line *first_mention; /* first usage */
	MEMORY_MANAGEMENT
} nonterminal_variable;
#line 32 "inweb/Chapter 5/Weave Formats.w"
typedef struct weave_format {
	char *format_name;
	char *woven_extension;
	struct weave_format *intermediate;
	MEMORY_MANAGEMENT
} weave_format;
#line 22 "inweb/Chapter 5/Running Through TeX.w"
typedef struct tex_results {
	int overfull_hbox_count;
	int tex_error_count;
	int page_count;
	int pdf_size;
	struct filename *PDF_filename;
	MEMORY_MANAGEMENT
} tex_results;
#line 98 "inlib/Chapter 1/Inlib.w"
void  Inlib__start(void) ;
#line 155 "inlib/Chapter 1/Inlib.w"
void  Inlib__end(void) ;
#line 97 "inlib/Chapter 1/Platform-Specific Definitions.w"
int  Platform__Windows_isdigit(int c) ;
#line 151 "inlib/Chapter 1/Platform-Specific Definitions.w"
int  Platform__mkdir(char *path_to_folder) ;
#line 162 "inlib/Chapter 1/Platform-Specific Definitions.w"
void * Platform__opendir(char *path_to_folder) ;
#line 167 "inlib/Chapter 1/Platform-Specific Definitions.w"
int  Platform__readdir(void *folder, char *path_to_folder, 	char *leafname) ;
#line 183 "inlib/Chapter 1/Platform-Specific Definitions.w"
void  Platform__closedir(void *folder) ;
#line 201 "inlib/Chapter 1/Platform-Specific Definitions.w"
int  Platform__mkdir(char *path_to_folder) ;
#line 212 "inlib/Chapter 1/Platform-Specific Definitions.w"
void * Platform__opendir(char *path_to_folder) ;
#line 217 "inlib/Chapter 1/Platform-Specific Definitions.w"
int  Platform__readdir(void *folder, char *path_to_folder, 	char *leafname) ;
#line 234 "inlib/Chapter 1/Platform-Specific Definitions.w"
void  Platform__closedir(void *folder) ;
#line 266 "inlib/Chapter 1/Platform-Specific Definitions.w"
FILE * Platform__iso_fopen(filename *F, char *usage) ;
#line 275 "inlib/Chapter 1/Platform-Specific Definitions.w"
FILE * Platform__iso_fopen_caseless(filename *F, char *usage) ;
#line 288 "inlib/Chapter 1/Platform-Specific Definitions.w"
void  Platform__transcode_ISO_string_to_locale(char *from, char *to) ;
#line 294 "inlib/Chapter 1/Platform-Specific Definitions.w"
void  Platform__transcode_ISO_string_to_locale(char *from, char *to) ;
#line 29 "inlib/Chapter 2/C Strings.w"
int  CStrings__strlen_unbounded(const char *p) ;
#line 39 "inlib/Chapter 2/C Strings.w"
int  CStrings__check_len(int n) ;
#line 48 "inlib/Chapter 2/C Strings.w"
int  CStrings__len(char *str) ;
#line 59 "inlib/Chapter 2/C Strings.w"
void  CStrings__set_char(char *str, int i, int to) ;
#line 68 "inlib/Chapter 2/C Strings.w"
void  CStrings__truncate(char *str, int len) ;
#line 77 "inlib/Chapter 2/C Strings.w"
void  CStrings__copy(char *to, char *from) ;
#line 87 "inlib/Chapter 2/C Strings.w"
void  CStrings__concatenate(char *to, char *from) ;
#line 97 "inlib/Chapter 2/C Strings.w"
char * CStrings__trim_white_space(char *original) ;
#line 110 "inlib/Chapter 2/C Strings.w"
void  CStrings__extract_word(char *fword, char *line, int size, int word) ;
#line 130 "inlib/Chapter 2/C Strings.w"
int  CStrings__eq(char *A, char *B) ;
#line 134 "inlib/Chapter 2/C Strings.w"
int  CStrings__ne(char *A, char *B) ;
#line 141 "inlib/Chapter 2/C Strings.w"
int  CStrings__cmp(char *A, char *B) ;
#line 153 "inlib/Chapter 2/C Strings.w"
int  CStrings__eq_insensitive(char *A, char *B) ;
#line 168 "inlib/Chapter 2/C Strings.w"
void  CStrings__transcode_ISO_string_to_UTF8(char *p, char *dest) ;
#line 69 "inlib/Chapter 2/Debugging Log.w"
void  Log__declare_aspect(int a, wchar_t *name, int def, int alt) ;
#line 120 "inlib/Chapter 2/Debugging Log.w"
filename * Log__get_debug_log_filename(void) ;
#line 124 "inlib/Chapter 2/Debugging Log.w"
void  Log__set_debug_log_filename(filename *F) ;
#line 128 "inlib/Chapter 2/Debugging Log.w"
int  Log__open(void) ;
#line 140 "inlib/Chapter 2/Debugging Log.w"
void  Log__close(void) ;
#line 155 "inlib/Chapter 2/Debugging Log.w"
void  Log__new_phase_of_Informs_run(char *p, char *q) ;
#line 164 "inlib/Chapter 2/Debugging Log.w"
void  Log__new_stage_of_Informs_run(char *p) ;
#line 178 "inlib/Chapter 2/Debugging Log.w"
int  Log__aspect_switched_on(int aspect) ;
#line 185 "inlib/Chapter 2/Debugging Log.w"
void  Log__set_aspect(int aspect, int state) ;
#line 192 "inlib/Chapter 2/Debugging Log.w"
void  Log__set_all_aspects(int new_state) ;
#line 210 "inlib/Chapter 2/Debugging Log.w"
void  Log__set_aspect_from_command_line(text_stream *name) ;
#line 239 "inlib/Chapter 2/Debugging Log.w"
void  Log__tracing_on(int starred, text_stream *heading) ;
#line 259 "inlib/Chapter 2/Debugging Log.w"
void  Log__show_debugging_settings_with_state(int state) ;
#line 272 "inlib/Chapter 2/Debugging Log.w"
void  Log__show_debugging_contents(void) ;
#line 94 "inlib/Chapter 2/Memory.w"
void  Memory__start(void) ;
#line 174 "inlib/Chapter 2/Memory.w"
void  Memory__allocate_another_block(void) ;
#line 219 "inlib/Chapter 2/Memory.w"
void  Memory__free(void) ;
#line 264 "inlib/Chapter 2/Memory.w"
void  Memory__check_memory_integrity(void) ;
#line 275 "inlib/Chapter 2/Memory.w"
void  Memory__debug_memory_frames(int from, int to) ;
#line 292 "inlib/Chapter 2/Memory.w"
void * Memory__allocate(int mem_type, int extent) ;
#line 529 "inlib/Chapter 2/Memory.w"
char * Memory__description_of_reason(int r) ;
#line 554 "inlib/Chapter 2/Memory.w"
void * Memory__I7_calloc(int how_many, int size_in_bytes, int reason) ;
#line 557 "inlib/Chapter 2/Memory.w"
void * Memory__I7_malloc(int size_in_bytes, int reason) ;
#line 564 "inlib/Chapter 2/Memory.w"
void * Memory__I7_alloc(int N, int S, int R) ;
#line 621 "inlib/Chapter 2/Memory.w"
void  Memory__I7_free(void *pointer, int R) ;
#line 642 "inlib/Chapter 2/Memory.w"
void  Memory__I7_free_remaining(void) ;
#line 671 "inlib/Chapter 2/Memory.w"
char * Memory__new_string(char *from) ;
#line 688 "inlib/Chapter 2/Memory.w"
void  Memory__free_ssas(void) ;
#line 698 "inlib/Chapter 2/Memory.w"
int  Memory__log_usage(int total) ;
#line 717 "inlib/Chapter 2/Memory.w"
void  Memory__log_statistics(void) ;
#line 791 "inlib/Chapter 2/Memory.w"
int  Memory__compare_usage(const void *ent1, const void *ent2) ;
#line 801 "inlib/Chapter 2/Memory.w"
int  Memory__proportion(int bytes, int total) ;
#line 245 "inlib/Chapter 2/Streams.w"
void  Streams__initialise(text_stream *stream) ;
#line 260 "inlib/Chapter 2/Streams.w"
void  Streams__enable_debugging(text_stream *stream) ;
#line 264 "inlib/Chapter 2/Streams.w"
void  Streams__declare_as_HTML(text_stream *stream, HTML_file_state *hs) ;
#line 268 "inlib/Chapter 2/Streams.w"
HTML_file_state * Streams__get_HTML_file_state(text_stream *stream) ;
#line 275 "inlib/Chapter 2/Streams.w"
void  Streams__log(OUTPUT_STREAM, void *vS) ;
#line 298 "inlib/Chapter 2/Streams.w"
text_stream * Streams__get_stdout(void) ;
#line 316 "inlib/Chapter 2/Streams.w"
text_stream * Streams__get_stderr(void) ;
#line 335 "inlib/Chapter 2/Streams.w"
int  Streams__open_to_file(text_stream *stream, filename *name, int encoding) ;
#line 354 "inlib/Chapter 2/Streams.w"
int  Streams__open_to_file_append(text_stream *stream, filename *name, int encoding) ;
#line 375 "inlib/Chapter 2/Streams.w"
int  Streams__open_to_memory(text_stream *stream, int capacity) ;
#line 391 "inlib/Chapter 2/Streams.w"
text_stream  Streams__new_buffer(int capacity, wchar_t *at) ;
#line 409 "inlib/Chapter 2/Streams.w"
int  Streams__open_from_wide_string(text_stream *stream, wchar_t *c_string) ;
#line 417 "inlib/Chapter 2/Streams.w"
void  Streams__write_wide_string(text_stream *stream, wchar_t *c_string) ;
#line 425 "inlib/Chapter 2/Streams.w"
int  Streams__open_from_ISO_string(text_stream *stream, char *c_string) ;
#line 433 "inlib/Chapter 2/Streams.w"
void  Streams__write_ISO_string(text_stream *stream, char *c_string) ;
#line 440 "inlib/Chapter 2/Streams.w"
int  Streams__open_from_UTF8_string(text_stream *stream, char *c_string) ;
#line 448 "inlib/Chapter 2/Streams.w"
void  Streams__write_UTF8_string(text_stream *stream, char *c_string) ;
#line 467 "inlib/Chapter 2/Streams.w"
void  Streams__write_as_wide_string(wchar_t *C_string, text_stream *stream, int buffer_size) ;
#line 486 "inlib/Chapter 2/Streams.w"
void  Streams__write_as_ISO_string(char *C_string, text_stream *stream, int buffer_size) ;
#line 506 "inlib/Chapter 2/Streams.w"
void  Streams__write_as_UTF8_string(char *C_string, text_stream *stream, int buffer_size) ;
#line 537 "inlib/Chapter 2/Streams.w"
int  Streams__open_from_locale_string(text_stream *stream, char *C_string) ;
#line 546 "inlib/Chapter 2/Streams.w"
void  Streams__write_as_locale_string(char *C_string, text_stream *stream, int buffer_size) ;
#line 555 "inlib/Chapter 2/Streams.w"
void  Streams__write_locale_string(text_stream *stream, char *C_string) ;
#line 569 "inlib/Chapter 2/Streams.w"
void  Streams__flush(text_stream *stream) ;
#line 577 "inlib/Chapter 2/Streams.w"
void  Streams__close(text_stream *stream) ;
#line 636 "inlib/Chapter 2/Streams.w"
void  Streams__register_writer(int esc, void (*f)(text_stream *, char *, void *)) ;
#line 650 "inlib/Chapter 2/Streams.w"
void  Streams__dummy_writer(OUTPUT_STREAM, char *format_string, void *data) ;
#line 657 "inlib/Chapter 2/Streams.w"
void  Streams__write_wide_C_string(OUTPUT_STREAM, char *format_string, void *vW) ;
#line 665 "inlib/Chapter 2/Streams.w"
void  Streams__register_log_writer(int esc, void (*f)(text_stream *, void *)) ;
#line 677 "inlib/Chapter 2/Streams.w"
void  Streams__printf(text_stream *stream, char *fmt, ...) ;
#line 775 "inlib/Chapter 2/Streams.w"
void  Streams__putc(int c_int, text_stream *stream) ;
#line 872 "inlib/Chapter 2/Streams.w"
void  Streams__literal(text_stream *stream, char *p) ;
#line 886 "inlib/Chapter 2/Streams.w"
void  Streams__indent(text_stream *stream) ;
#line 891 "inlib/Chapter 2/Streams.w"
void  Streams__outdent(text_stream *stream) ;
#line 900 "inlib/Chapter 2/Streams.w"
void  Streams__set_indentation(text_stream *stream, int N) ;
#line 914 "inlib/Chapter 2/Streams.w"
int  Streams__get_position(text_stream *stream) ;
#line 928 "inlib/Chapter 2/Streams.w"
int  Streams__latest(text_stream *stream) ;
#line 944 "inlib/Chapter 2/Streams.w"
wchar_t  Streams__get_char_at_index(text_stream *stream, int position) ;
#line 955 "inlib/Chapter 2/Streams.w"
void  Streams__put_char_at_index(text_stream *stream, int position, wchar_t C) ;
#line 980 "inlib/Chapter 2/Streams.w"
void  Streams__set_position(text_stream *stream, int position) ;
#line 1003 "inlib/Chapter 2/Streams.w"
void  Streams__copy(text_stream *to, text_stream *from) ;
#line 1016 "inlib/Chapter 2/Streams.w"
void  Streams__write(OUTPUT_STREAM, char *format_string, void *vS) ;
#line 16 "inlib/Chapter 2/String Manipulation.w"
text_stream * Str__new(void) ;
#line 20 "inlib/Chapter 2/String Manipulation.w"
text_stream * Str__new_with_capacity(int c) ;
#line 31 "inlib/Chapter 2/String Manipulation.w"
text_stream * Str__new_from_wide_string(wchar_t *C_string) ;
#line 37 "inlib/Chapter 2/String Manipulation.w"
text_stream * Str__new_from_ISO_string(char *C_string) ;
#line 43 "inlib/Chapter 2/String Manipulation.w"
text_stream * Str__new_from_UTF8_string(char *C_string) ;
#line 49 "inlib/Chapter 2/String Manipulation.w"
text_stream * Str__new_from_locale_string(char *C_string) ;
#line 60 "inlib/Chapter 2/String Manipulation.w"
text_stream * Str__duplicate(text_stream *E) ;
#line 73 "inlib/Chapter 2/String Manipulation.w"
text_stream * Str__from_wide_string(text_stream *S, wchar_t *c_string) ;
#line 78 "inlib/Chapter 2/String Manipulation.w"
text_stream * Str__from_locale_string(text_stream *S, char *c_string) ;
#line 101 "inlib/Chapter 2/String Manipulation.w"
void  Str__copy_to_ISO_string(char *C_string, text_stream *S, int buffer_size) ;
#line 105 "inlib/Chapter 2/String Manipulation.w"
void  Str__copy_to_UTF8_string(char *C_string, text_stream *S, int buffer_size) ;
#line 109 "inlib/Chapter 2/String Manipulation.w"
void  Str__copy_to_wide_string(wchar_t *C_string, text_stream *S, int buffer_size) ;
#line 113 "inlib/Chapter 2/String Manipulation.w"
void  Str__copy_to_locale_string(char *C_string, text_stream *S, int buffer_size) ;
#line 120 "inlib/Chapter 2/String Manipulation.w"
int  Str__atoi(text_stream *S, int index) ;
#line 134 "inlib/Chapter 2/String Manipulation.w"
int  Str__len(text_stream *S) ;
#line 155 "inlib/Chapter 2/String Manipulation.w"
string_position  Str__start(text_stream *S) ;
#line 159 "inlib/Chapter 2/String Manipulation.w"
string_position  Str__at(text_stream *S, int i) ;
#line 165 "inlib/Chapter 2/String Manipulation.w"
string_position  Str__end(text_stream *S) ;
#line 172 "inlib/Chapter 2/String Manipulation.w"
string_position  Str__back(string_position P) ;
#line 176 "inlib/Chapter 2/String Manipulation.w"
string_position  Str__forward(string_position P) ;
#line 180 "inlib/Chapter 2/String Manipulation.w"
string_position  Str__plus(string_position P, int increment) ;
#line 184 "inlib/Chapter 2/String Manipulation.w"
int  Str__width_between(string_position P1, string_position P2) ;
#line 189 "inlib/Chapter 2/String Manipulation.w"
int  Str__in_range(string_position P) ;
#line 194 "inlib/Chapter 2/String Manipulation.w"
int  Str__index(string_position P) ;
#line 210 "inlib/Chapter 2/String Manipulation.w"
wchar_t  Str__get(string_position P) ;
#line 215 "inlib/Chapter 2/String Manipulation.w"
wchar_t  Str__get_at(text_stream *S, int index) ;
#line 219 "inlib/Chapter 2/String Manipulation.w"
wchar_t  Str__get_first_char(text_stream *S) ;
#line 223 "inlib/Chapter 2/String Manipulation.w"
wchar_t  Str__get_last_char(text_stream *S) ;
#line 229 "inlib/Chapter 2/String Manipulation.w"
void  Str__put(string_position P, wchar_t C) ;
#line 241 "inlib/Chapter 2/String Manipulation.w"
void  Str__put_at(text_stream *S, int index, wchar_t C) ;
#line 248 "inlib/Chapter 2/String Manipulation.w"
void  Str__clear(text_stream *S) ;
#line 252 "inlib/Chapter 2/String Manipulation.w"
void  Str__truncate(text_stream *S, int len) ;
#line 257 "inlib/Chapter 2/String Manipulation.w"
void  Str__concatenate(text_stream *S1, text_stream *S2) ;
#line 261 "inlib/Chapter 2/String Manipulation.w"
void  Str__copy(text_stream *S1, text_stream *S2) ;
#line 266 "inlib/Chapter 2/String Manipulation.w"
void  Str__copy_tail(text_stream *S1, text_stream *S2, int from) ;
#line 277 "inlib/Chapter 2/String Manipulation.w"
void  Str__set_to_wide_string(text_stream *S, wchar_t *text) ;
#line 281 "inlib/Chapter 2/String Manipulation.w"
void  Str__set_to_ISO_string(text_stream *S, char *text) ;
#line 288 "inlib/Chapter 2/String Manipulation.w"
int  Str__eq(text_stream *S1, text_stream *S2) ;
#line 293 "inlib/Chapter 2/String Manipulation.w"
int  Str__eq_insensitive(text_stream *S1, text_stream *S2) ;
#line 298 "inlib/Chapter 2/String Manipulation.w"
int  Str__ne(text_stream *S1, text_stream *S2) ;
#line 303 "inlib/Chapter 2/String Manipulation.w"
int  Str__ne_insensitive(text_stream *S1, text_stream *S2) ;
#line 308 "inlib/Chapter 2/String Manipulation.w"
int  Str__cmp(text_stream *S1, text_stream *S2) ;
#line 318 "inlib/Chapter 2/String Manipulation.w"
int  Str__cmp_insensitive(text_stream *S1, text_stream *S2) ;
#line 331 "inlib/Chapter 2/String Manipulation.w"
void  Str__copy_ISO_string(text_stream *S, char *C_string) ;
#line 336 "inlib/Chapter 2/String Manipulation.w"
void  Str__copy_UTF8_string(text_stream *S, char *C_string) ;
#line 341 "inlib/Chapter 2/String Manipulation.w"
void  Str__copy_wide_string(text_stream *S, wchar_t *C_string) ;
#line 346 "inlib/Chapter 2/String Manipulation.w"
int  Str__eq_C_string(text_stream *S1, wchar_t *S2) ;
#line 360 "inlib/Chapter 2/String Manipulation.w"
void  Str__trim_white_space(text_stream *S) ;
#line 392 "inlib/Chapter 2/String Manipulation.w"
void  Str__delete_first_character(text_stream *S) ;
#line 400 "inlib/Chapter 2/String Manipulation.w"
void  Str__substr(OUTPUT_STREAM, string_position from, string_position to) ;
#line 406 "inlib/Chapter 2/String Manipulation.w"
int  Str__begins_with_C_string(text_stream *S, wchar_t *prefix) ;
#line 13 "inlib/Chapter 2/Error Messages.w"
void  Errors__set_handler(int (*f)(text_stream *, int)) ;
#line 18 "inlib/Chapter 2/Error Messages.w"
int  Errors__have_occurred(void) ;
#line 23 "inlib/Chapter 2/Error Messages.w"
void  Errors__issue(text_stream *message, int fatality) ;
#line 38 "inlib/Chapter 2/Error Messages.w"
void  Errors__fatal(char *message) ;
#line 45 "inlib/Chapter 2/Error Messages.w"
void  Errors__fatal_with_C_string(char *message, char *parameter) ;
#line 54 "inlib/Chapter 2/Error Messages.w"
void  Errors__fatal_with_text(char *message, text_stream *parameter) ;
#line 63 "inlib/Chapter 2/Error Messages.w"
void  Errors__fatal_with_file(char *message, filename *F) ;
#line 70 "inlib/Chapter 2/Error Messages.w"
void  Errors__fatal_with_path(char *message, pathname *P) ;
#line 88 "inlib/Chapter 2/Error Messages.w"
void  Errors__enter_debugger_mode(void) ;
#line 93 "inlib/Chapter 2/Error Messages.w"
void  Errors__die(void) ;
#line 109 "inlib/Chapter 2/Error Messages.w"
void  Errors__nowhere(char *message) ;
#line 113 "inlib/Chapter 2/Error Messages.w"
void  Errors__in_text_file(char *message, text_file_position *here) ;
#line 123 "inlib/Chapter 2/Error Messages.w"
void  Errors__with_file(char *message, filename *F) ;
#line 130 "inlib/Chapter 2/Error Messages.w"
void  Errors__at_position(char *message, filename *file, int line) ;
#line 25 "inlib/Chapter 2/Command Line Arguments.w"
void  CommandLine__declare_switch(int id, wchar_t *name_literal, int val) ;
#line 35 "inlib/Chapter 2/Command Line Arguments.w"
void  CommandLine__read(int argc, char **argv, void *state, void (*f)(int, text_stream *, void *)) ;
#line 23 "inlib/Chapter 3/Filenames.w"
filename * Filenames__in_folder(pathname *P, char *file_name) ;
#line 27 "inlib/Chapter 3/Filenames.w"
filename * Filenames__in_folder_S(pathname *P, text_stream *file_name) ;
#line 31 "inlib/Chapter 3/Filenames.w"
filename * Filenames__primitive(char *c_string, text_stream *S, int from, int to, pathname *P) ;
#line 53 "inlib/Chapter 3/Filenames.w"
filename * Filenames__from_string(char *path) ;
#line 65 "inlib/Chapter 3/Filenames.w"
filename * Filenames__from_stream(text_stream *path) ;
#line 91 "inlib/Chapter 3/Filenames.w"
filename * Filenames__from_command_line_argument(char *arg) ;
#line 106 "inlib/Chapter 3/Filenames.w"
void  Filenames__to_string(char *to, filename *F) ;
#line 116 "inlib/Chapter 3/Filenames.w"
void  Filenames__to_string_Unixised(char *to, filename *F) ;
#line 126 "inlib/Chapter 3/Filenames.w"
void  Filenames__print_string(char *label, filename *F) ;
#line 135 "inlib/Chapter 3/Filenames.w"
void  Filenames__to_string_relative(char *to, filename *F, pathname *P) ;
#line 148 "inlib/Chapter 3/Filenames.w"
void  Filenames__write(OUTPUT_STREAM, char *format_string, void *vF) ;
#line 162 "inlib/Chapter 3/Filenames.w"
pathname * Filenames__get_path_to(filename *F) ;
#line 170 "inlib/Chapter 3/Filenames.w"
filename * Filenames__without_path(filename *F) ;
#line 174 "inlib/Chapter 3/Filenames.w"
text_stream * Filenames__get_leafname(filename *F) ;
#line 179 "inlib/Chapter 3/Filenames.w"
void  Filenames__write_unextended_leafname(OUTPUT_STREAM, filename *F) ;
#line 195 "inlib/Chapter 3/Filenames.w"
void  Filenames__write_extension(OUTPUT_STREAM, filename *F) ;
#line 204 "inlib/Chapter 3/Filenames.w"
filename * Filenames__set_extension(filename *F, char *extension) ;
#line 234 "inlib/Chapter 3/Filenames.w"
int  Filenames__guess_format(filename *F) ;
#line 55 "inlib/Chapter 3/Pathnames.w"
pathname * Pathnames__subfolder(pathname *P, char *folder_name) ;
#line 59 "inlib/Chapter 3/Pathnames.w"
pathname * Pathnames__primitive(char *c_string, text_stream *str, int from, int to, pathname *par) ;
#line 83 "inlib/Chapter 3/Pathnames.w"
pathname * Pathnames__from_string(char *path) ;
#line 87 "inlib/Chapter 3/Pathnames.w"
pathname * Pathnames__from_string_relative(pathname *P, char *path) ;
#line 100 "inlib/Chapter 3/Pathnames.w"
pathname * Pathnames__from_stream(text_stream *path) ;
#line 104 "inlib/Chapter 3/Pathnames.w"
pathname * Pathnames__from_stream_relative(pathname *P, text_stream *path) ;
#line 123 "inlib/Chapter 3/Pathnames.w"
pathname * Pathnames__from_command_line_argument(char *arg) ;
#line 138 "inlib/Chapter 3/Pathnames.w"
void  Pathnames__to_string(char *to, pathname *P) ;
#line 142 "inlib/Chapter 3/Pathnames.w"
void  Pathnames__to_string_Unixised(char *to, pathname *P) ;
#line 146 "inlib/Chapter 3/Pathnames.w"
void  Pathnames__to_string_inner(char *to, pathname *P, char divider) ;
#line 152 "inlib/Chapter 3/Pathnames.w"
int  Pathnames__to_string_r(char *to, pathname *P, int room_left, char divider) ;
#line 167 "inlib/Chapter 3/Pathnames.w"
void  Pathnames__write(OUTPUT_STREAM, char *format_string, void *vP) ;
#line 190 "inlib/Chapter 3/Pathnames.w"
void  Pathnames__to_string_relative(char *to, pathname *P, pathname *R) ;
#line 203 "inlib/Chapter 3/Pathnames.w"
pathname * Pathnames__modify_with_number(pathname *P, char *template, int val) ;
#line 215 "inlib/Chapter 3/Pathnames.w"
void  Pathnames__start(void) ;
#line 228 "inlib/Chapter 3/Pathnames.w"
int  Pathnames__create_in_file_system(pathname *P) ;
#line 252 "inlib/Chapter 3/Pathnames.w"
int  Pathnames__write_contents_to_file(filename *writeto, pathname *P) ;
#line 275 "inlib/Chapter 3/Pathnames.w"
int  Pathnames__write_contents_to_stream(OUTPUT_STREAM, pathname *P) ;
#line 54 "inlib/Chapter 3/Case-Insensitive Filenames.w"
FILE * CIFilingSystem__fopen(const char *path, const char *mode) ;
#line 213 "inlib/Chapter 3/Case-Insensitive Filenames.w"
int  CIFilingSystem__match_in_directory(void *vd, 	char *name, char *last_match) ;
#line 234 "inlib/Chapter 3/Case-Insensitive Filenames.w"
FILE * CIFilingSystem__fopen(const char *path, const char *mode) ;
#line 14 "inlib/Chapter 3/Shell.w"
void  Shell__quote_path(OUTPUT_STREAM, pathname *P) ;
#line 21 "inlib/Chapter 3/Shell.w"
void  Shell__quote_file(OUTPUT_STREAM, filename *F) ;
#line 28 "inlib/Chapter 3/Shell.w"
void  Shell__plain(OUTPUT_STREAM, char *raw) ;
#line 32 "inlib/Chapter 3/Shell.w"
void  Shell__plain_text(OUTPUT_STREAM, text_stream *raw) ;
#line 36 "inlib/Chapter 3/Shell.w"
void  Shell__quote_text(OUTPUT_STREAM, text_stream *raw) ;
#line 50 "inlib/Chapter 3/Shell.w"
void  Shell__apply(char *command, filename *F) ;
#line 62 "inlib/Chapter 3/Shell.w"
void  Shell__rm(filename *F) ;
#line 66 "inlib/Chapter 3/Shell.w"
void  Shell__copy(filename *F, pathname *T, char *options) ;
#line 80 "inlib/Chapter 3/Shell.w"
void  Shell__redirect(OUTPUT_STREAM, filename *F) ;
#line 92 "inlib/Chapter 3/Shell.w"
void  Shell__verbose(void) ;
#line 96 "inlib/Chapter 3/Shell.w"
int  Shell__run(OUTPUT_STREAM) ;
#line 18 "inlib/Chapter 3/Directories.w"
scan_directory * Directories__open(pathname *P) ;
#line 25 "inlib/Chapter 3/Directories.w"
int  Directories__next(scan_directory *D, char *leafname) ;
#line 29 "inlib/Chapter 3/Directories.w"
void  Directories__close(scan_directory *D) ;
#line 10 "inlib/Chapter 4/Characters.w"
char  Characters__tolower(char c) ;
#line 13 "inlib/Chapter 4/Characters.w"
char  Characters__toupper(char c) ;
#line 16 "inlib/Chapter 4/Characters.w"
int  Characters__isalpha(char c) ;
#line 19 "inlib/Chapter 4/Characters.w"
int  Characters__isdigit(char c) ;
#line 22 "inlib/Chapter 4/Characters.w"
int  Characters__is_space_or_tab(int c) ;
#line 30 "inlib/Chapter 4/Characters.w"
wchar_t  Characters__w_tolower(wchar_t c) ;
#line 33 "inlib/Chapter 4/Characters.w"
wchar_t  Characters__w_toupper(wchar_t c) ;
#line 36 "inlib/Chapter 4/Characters.w"
int  Characters__w_isalpha(wchar_t c) ;
#line 39 "inlib/Chapter 4/Characters.w"
int  Characters__w_isdigit(wchar_t c) ;
#line 48 "inlib/Chapter 4/Characters.w"
int  Characters__combine_accent(int accent, int letter) ;
#line 20 "inlib/Chapter 4/Text Files.w"
int  TextFiles__get_line_count(text_file_position *tfp) ;
#line 28 "inlib/Chapter 4/Text Files.w"
text_file_position  TextFiles__nowhere(void) ;
#line 41 "inlib/Chapter 4/Text Files.w"
int  TextFiles__exists(filename *F) ;
#line 58 "inlib/Chapter 4/Text Files.w"
int  TextFiles__read(filename *F, char *message, int serious, 	void (iterator)(text_stream *, text_file_position *, void *), 	text_file_position *start_at, void *state) ;
#line 163 "inlib/Chapter 4/Text Files.w"
int  TextFiles__read_with_lines_to_ISO(filename *F, char *message, int serious, 	void (iterator)(char *, text_file_position *, void *), text_file_position *start_at, 	void *state) ;
#line 257 "inlib/Chapter 4/Text Files.w"
void  TextFiles__lose_interest(text_file_position *tfp) ;
#line 290 "inlib/Chapter 4/Text Files.w"
unicode_file_buffer  TextFiles__create_ufb(void) ;
#line 296 "inlib/Chapter 4/Text Files.w"
int  TextFiles__utf8_fgetc(FILE *from, char **or_from, int escape_oddities, 	unicode_file_buffer *ufb) ;
#line 10 "inlib/Chapter 4/Pattern Matching.w"
int  Regexp__white_space(int c) ;
#line 20 "inlib/Chapter 4/Pattern Matching.w"
int  Regexp__identifier_char(int c) ;
#line 35 "inlib/Chapter 4/Pattern Matching.w"
int  Regexp__find_expansion(text_stream *text, wchar_t on1, wchar_t on2, 	wchar_t off1, wchar_t off2, int *len) ;
#line 51 "inlib/Chapter 4/Pattern Matching.w"
int  Regexp__find_open_brace(text_stream *text) ;
#line 62 "inlib/Chapter 4/Pattern Matching.w"
int  Regexp__string_is_white_space(text_stream *text) ;
#line 115 "inlib/Chapter 4/Pattern Matching.w"
match_results  Regexp__create_mr(void) ;
#line 122 "inlib/Chapter 4/Pattern Matching.w"
int  Regexp__match(match_results *mr, text_stream *text, wchar_t *pattern) ;
#line 134 "inlib/Chapter 4/Pattern Matching.w"
void  Regexp__dispose_of(match_results *mr) ;
#line 146 "inlib/Chapter 4/Pattern Matching.w"
int  Regexp__match_r(match_results *mr, text_stream *text, wchar_t *pattern, match_position *scan_from) ;
#line 279 "inlib/Chapter 4/Pattern Matching.w"
int  Regexp__get_cclass(wchar_t *pattern, int ppos, int *len, int *from, int *to, int *reverse) ;
#line 309 "inlib/Chapter 4/Pattern Matching.w"
int  Regexp__test_cclass(int c, int chcl, int range_from, int range_to, wchar_t *drawn_from, int reverse) ;
#line 11 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__white_space(int c) ;
#line 21 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__identifier_char(int c) ;
#line 36 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__find_expansion(char *original, char on1, char on2, char off1, char off2, int *len) ;
#line 51 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__find_open_brace(char *p) ;
#line 62 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__string_is_white_space(char *p) ;
#line 104 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__match_0(char *text, char *pattern) ;
#line 108 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__match_1(char *text, char *pattern, char *ft1) ;
#line 112 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__match_2(char *text, char *pattern, char *ft1, char *ft2) ;
#line 116 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__match_3(char *text, char *pattern, char *ft1, char *ft2, char *ft3) ;
#line 120 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__match_4(char *text, char *pattern, char *ft1, char *ft2, char *ft3, char *ft4) ;
#line 127 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__match_r(char *text, char *pattern, match_position *scan_from, char *ft1, char *ft2, char *ft3, char *ft4) ;
#line 270 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__get_cclass(char *pattern, int ppos, int *len, int *from, int *to, int *reverse) ;
#line 300 "inlib/Chapter 4/ISO Pattern Matching.w"
int  ISORegexp__test_cclass(char *text, int chcl, int range_from, int range_to, char *drawn_from, int reverse) ;
#line 19 "inlib/Chapter 5/HTML.w"
void  HTML__declare_as_HTML(OUTPUT_STREAM, int XHTML) ;
#line 26 "inlib/Chapter 5/HTML.w"
void  HTML__completed(OUTPUT_STREAM) ;
#line 38 "inlib/Chapter 5/HTML.w"
void  HTML__open(OUTPUT_STREAM, char *tag) ;
#line 41 "inlib/Chapter 5/HTML.w"
void  HTML__open_with_id(OUTPUT_STREAM, char *tag, char *id) ;
#line 44 "inlib/Chapter 5/HTML.w"
void  HTML__open_with_class(OUTPUT_STREAM, char *tag, char *class) ;
#line 48 "inlib/Chapter 5/HTML.w"
void  HTML__open_with_id_and_class(OUTPUT_STREAM, char *tag, char *class, char *id) ;
#line 64 "inlib/Chapter 5/HTML.w"
void  HTML__close(OUTPUT_STREAM, char *tag) ;
#line 85 "inlib/Chapter 5/HTML.w"
void  HTML__self_closing(OUTPUT_STREAM) ;
#line 94 "inlib/Chapter 5/HTML.w"
void  HTML__begin_head(OUTPUT_STREAM, filename *CSS_file) ;
#line 116 "inlib/Chapter 5/HTML.w"
void  HTML__end_head(OUTPUT_STREAM) ;
#line 123 "inlib/Chapter 5/HTML.w"
void  HTML__begin_body(OUTPUT_STREAM, char *class) ;
#line 127 "inlib/Chapter 5/HTML.w"
void  HTML__end_body(OUTPUT_STREAM) ;
#line 135 "inlib/Chapter 5/HTML.w"
void  HTML__begin_div_with_id(OUTPUT_STREAM, char *id) ;
#line 139 "inlib/Chapter 5/HTML.w"
void  HTML__begin_div_with_class(OUTPUT_STREAM, char *cl) ;
#line 143 "inlib/Chapter 5/HTML.w"
void  HTML__begin_div_with_class_and_id(OUTPUT_STREAM, char *cl, char *id, int hide) ;
#line 149 "inlib/Chapter 5/HTML.w"
void  HTML__end_div(OUTPUT_STREAM) ;
#line 156 "inlib/Chapter 5/HTML.w"
void  HTML__image(OUTPUT_STREAM, filename *F) ;
#line 164 "inlib/Chapter 5/HTML.w"
void  HTML__anchor(OUTPUT_STREAM, text_stream *id) ;
#line 169 "inlib/Chapter 5/HTML.w"
void  HTML__begin_link(OUTPUT_STREAM, text_stream *href) ;
#line 173 "inlib/Chapter 5/HTML.w"
void  HTML__end_link(OUTPUT_STREAM) ;
#line 180 "inlib/Chapter 5/HTML.w"
void  HTML__comment(OUTPUT_STREAM, char *text) ;
#line 184 "inlib/Chapter 5/HTML.w"
void  HTML__heading(OUTPUT_STREAM, char *tag, char *text) ;
#line 188 "inlib/Chapter 5/HTML.w"
void  HTML__hr(OUTPUT_STREAM, char *class) ;
#line 116 "inlib/Chapter 5/Epub Ebooks.w"
ebook * Epub__new(text_stream *title) ;
#line 130 "inlib/Chapter 5/Epub Ebooks.w"
void  Epub__use_CSS(ebook *B, filename *F) ;
#line 134 "inlib/Chapter 5/Epub Ebooks.w"
text_stream * Epub__attach_metadata(ebook *B, wchar_t *K, text_stream *V) ;
#line 149 "inlib/Chapter 5/Epub Ebooks.w"
text_stream * Epub__get_metadata(ebook *B, wchar_t *K) ;
#line 156 "inlib/Chapter 5/Epub Ebooks.w"
text_stream * Epub__ensure_metadata(ebook *B, wchar_t *K) ;
#line 162 "inlib/Chapter 5/Epub Ebooks.w"
ebook_page * Epub__note_page(ebook *B, filename *F, char *title, char *type) ;
#line 183 "inlib/Chapter 5/Epub Ebooks.w"
void  Epub__note_image(ebook *B, filename *F) ;
#line 191 "inlib/Chapter 5/Epub Ebooks.w"
ebook_volume * Epub__starts_volume(ebook *B, ebook_page *P, char *title) ;
#line 201 "inlib/Chapter 5/Epub Ebooks.w"
ebook_chapter * Epub__starts_chapter(ebook *B, ebook_page *P, char *title) ;
#line 215 "inlib/Chapter 5/Epub Ebooks.w"
pathname * Epub__begin_construction(ebook *B, pathname *P, filename *cover_image) ;
#line 302 "inlib/Chapter 5/Epub Ebooks.w"
void  Epub__end_construction(ebook *B) ;
#line 10 "inlib/Chapter 6/Binary Files.w"
int  BinaryFiles__read_int8(FILE *binary_file, unsigned int *result) ;
#line 18 "inlib/Chapter 6/Binary Files.w"
int  BinaryFiles__read_int16(FILE *binary_file, unsigned int *result) ;
#line 29 "inlib/Chapter 6/Binary Files.w"
int  BinaryFiles__read_int32(FILE *binary_file, unsigned int *result) ;
#line 44 "inlib/Chapter 6/Binary Files.w"
int  BinaryFiles__read_int64(FILE *binary_file, unsigned long long *result) ;
#line 73 "inlib/Chapter 6/Binary Files.w"
void  BinaryFiles__swap_bytes32(unsigned int *value) ;
#line 81 "inlib/Chapter 6/Binary Files.w"
void  BinaryFiles__swap_bytes64(unsigned long long *value) ;
#line 99 "inlib/Chapter 6/Binary Files.w"
int  BinaryFiles__read_variable_length_integer(FILE *binary_file, unsigned int *result) ;
#line 116 "inlib/Chapter 6/Binary Files.w"
int  BinaryFiles__read_float80(FILE *binary_file, unsigned int *result) ;
#line 141 "inlib/Chapter 6/Binary Files.w"
int  BinaryFiles__read_string(FILE *binary_file, char *string, unsigned int length) ;
#line 153 "inlib/Chapter 6/Binary Files.w"
long int  BinaryFiles__size(filename *F) ;
#line 170 "inlib/Chapter 6/Binary Files.w"
FILE * BinaryFiles__open_for_reading(filename *F) ;
#line 176 "inlib/Chapter 6/Binary Files.w"
FILE * BinaryFiles__try_to_open_for_reading(filename *F) ;
#line 180 "inlib/Chapter 6/Binary Files.w"
FILE * BinaryFiles__open_for_writing(filename *F) ;
#line 186 "inlib/Chapter 6/Binary Files.w"
FILE * BinaryFiles__try_to_open_for_writing(filename *F) ;
#line 190 "inlib/Chapter 6/Binary Files.w"
void  BinaryFiles__close(FILE *handle) ;
#line 199 "inlib/Chapter 6/Binary Files.w"
int  BinaryFiles__copy(filename *from, filename *to, int suppress_error) ;
#line 27 "inlib/Chapter 6/Image Dimensions.w"
int  ImageFiles__get_JPEG_dimensions(FILE *JPEG_file, unsigned int *width, unsigned int *height) ;
#line 80 "inlib/Chapter 6/Image Dimensions.w"
int  ImageFiles__get_PNG_dimensions(FILE *PNG_file, unsigned int *width, unsigned int *height) ;
#line 15 "inlib/Chapter 6/Sound Durations.w"
int  SoundFiles__get_AIFF_duration(FILE *pFile, unsigned int *pDuration, 	unsigned int *pBitsPerSecond, unsigned int *pChannels, unsigned int *pSampleRate) ;
#line 62 "inlib/Chapter 6/Sound Durations.w"
int  SoundFiles__get_OggVorbis_duration(FILE *pFile, unsigned int *pDuration, 	unsigned int *pBitsPerSecond, unsigned int *pChannels, unsigned int *pSampleRate) ;
#line 184 "inlib/Chapter 6/Sound Durations.w"
int  SoundFiles__get_MIDI_information(FILE *pFile, unsigned int *pType, 	unsigned int *pNumTracks) ;
#line 60 "inweb/Chapter 1/Program Control.w"
int  main(int argc, char **argv) ;
#line 96 "inweb/Chapter 1/Program Control.w"
void  Main__follow_instructions(inweb_instructions *ins) ;
#line 251 "inweb/Chapter 1/Program Control.w"
void  Main__error_in_web(char *message, source_line *sl) ;
#line 34 "inweb/Chapter 1/Configuration.w"
inweb_instructions  Configuration__read(int argc, char **argv) ;
#line 202 "inweb/Chapter 1/Configuration.w"
void  Configuration__enter_main_mode(inweb_instructions *args, int new_mode) ;
#line 214 "inweb/Chapter 1/Configuration.w"
void  Configuration__read_configuration_file(void) ;
#line 225 "inweb/Chapter 1/Configuration.w"
void  Configuration__scan_config_line(char *line, text_file_position *tfp, void *unused_state) ;
#line 30 "inweb/Chapter 2/Bibliographic Data.w"
int  Bibliographic__datum_can_be_declared(web *W, char *key) ;
#line 36 "inweb/Chapter 2/Bibliographic Data.w"
int  Bibliographic__datum_on_or_off(web *W, char *key) ;
#line 46 "inweb/Chapter 2/Bibliographic Data.w"
void  Bibliographic__initialise_data(web *W) ;
#line 74 "inweb/Chapter 2/Bibliographic Data.w"
void  Bibliographic__check_required_data(web *W) ;
#line 87 "inweb/Chapter 2/Bibliographic Data.w"
char * Bibliographic__get_data(web *W, char *key) ;
#line 93 "inweb/Chapter 2/Bibliographic Data.w"
int  Bibliographic__data_exists(web *W, char *key) ;
#line 99 "inweb/Chapter 2/Bibliographic Data.w"
bibliographic_datum * Bibliographic__look_up_datum(web *W, char *key) ;
#line 114 "inweb/Chapter 2/Bibliographic Data.w"
bibliographic_datum * Bibliographic__set_datum(web *W, char *key, char *val) ;
#line 39 "inweb/Chapter 2/Line Categories.w"
source_line * Lines__new_source_line(char *line, text_file_position *tfp) ;
#line 96 "inweb/Chapter 2/Line Categories.w"
char * Lines__category_name(int cat) ;
#line 57 "inweb/Chapter 2/Reading Sections.w"
web * Reader__load_web(pathname *P, pathname *I, int verbosely) ;
#line 80 "inweb/Chapter 2/Reading Sections.w"
void  Reader__print_web_statistics(web *W) ;
#line 179 "inweb/Chapter 2/Reading Sections.w"
void  Reader__read_contents_page(web *W, pathname *import_path, int verbosely) ;
#line 184 "inweb/Chapter 2/Reading Sections.w"
void  Reader__read_contents_page_from(web *W, pathname *import_path, int verbosely, pathname *path) ;
#line 214 "inweb/Chapter 2/Reading Sections.w"
void  Reader__scan_biblio_line(char *line, text_file_position *tfp, void *X) ;
#line 504 "inweb/Chapter 2/Reading Sections.w"
void  Reader__read_file(web *W, filename *OUT, char *titling_line, section *sect, 	int verbosely) ;
#line 526 "inweb/Chapter 2/Reading Sections.w"
void  Reader__scan_source_line(char *line, text_file_position *tfp, void *state) ;
#line 558 "inweb/Chapter 2/Reading Sections.w"
void  Reader__scan_line_categories(web *W, char *sigil) ;
#line 588 "inweb/Chapter 2/Reading Sections.w"
chapter * Reader__get_chapter_for_sigil(web *W, char *sigil) ;
#line 596 "inweb/Chapter 2/Reading Sections.w"
section * Reader__get_section_for_sigil(web *W, char *sigil) ;
#line 605 "inweb/Chapter 2/Reading Sections.w"
section * Reader__section_by_filename(web *W, text_stream *filename) ;
#line 624 "inweb/Chapter 2/Reading Sections.w"
int  Reader__sigil_within(char *sig1, char *sig2) ;
#line 656 "inweb/Chapter 2/Reading Sections.w"
tangle_target * Reader__add_tangle_target(web *W, programming_language *language) ;
#line 691 "inweb/Chapter 2/Reading Sections.w"
void  Reader__add_imported_header(web *W, filename *HF) ;
#line 9 "inweb/Chapter 2/The Parser.w"
void  Parser__parse_literate_source(web *W) ;
#line 486 "inweb/Chapter 2/The Parser.w"
cweb_macro * Parser__get_cweb_macro_by_name(char *name, section *scope) ;
#line 511 "inweb/Chapter 2/The Parser.w"
theme_tag * Parser__tag_by_name(char *p) ;
#line 539 "inweb/Chapter 2/The Parser.w"
theme_tag * Parser__declare_tag_from_contents(web *W, char *name, char *title, char *leaf, char *cover) ;
#line 551 "inweb/Chapter 2/The Parser.w"
theme_tag * Parser__add_tag_by_name(source_line *L, char *p) ;
#line 578 "inweb/Chapter 2/The Parser.w"
void  Parser__add_tag_to_para(paragraph *P, theme_tag *tag, char *caption) ;
#line 591 "inweb/Chapter 2/The Parser.w"
int  Parser__is_tagged_with(source_line *L, theme_tag *tag) ;
#line 16 "inweb/Chapter 2/Paragraph Numbering.w"
void  Numbering__number_web(web *W) ;
#line 134 "inweb/Chapter 2/Paragraph Numbering.w"
void  Numbering__settle_paragraph_number(paragraph *P) ;
#line 13 "inweb/Chapter 3/The Analyser.w"
void  Analyser__catalogue_the_sections(web *W, char *sigil, int functions_too) ;
#line 51 "inweb/Chapter 3/The Analyser.w"
void  Analyser__analyse_code(web *W) ;
#line 126 "inweb/Chapter 3/The Analyser.w"
void  Analyser__analyse_as_code(web *W, source_line *L, char *text, int mask, int transf) ;
#line 168 "inweb/Chapter 3/The Analyser.w"
int  Analyser__hash_code_from_word(char *text) ;
#line 210 "inweb/Chapter 3/The Analyser.w"
hash_table_entry * Analyser__find_hash_entry(section *S, char *text, int create) ;
#line 236 "inweb/Chapter 3/The Analyser.w"
void  Analyser__mark_reserved_word(section *S, char *p, int e) ;
#line 241 "inweb/Chapter 3/The Analyser.w"
int  Analyser__is_reserved_word(section *S, char *p, int e) ;
#line 265 "inweb/Chapter 3/The Analyser.w"
void  Analyser__analyse_find(web *W, source_line *L, char *identifier, int u) ;
#line 21 "inweb/Chapter 3/The Swarm.w"
void  Swarm__weave(web *W, char *subweb, int swarm_mode, theme_tag *tag, char *format) ;
#line 56 "inweb/Chapter 3/The Swarm.w"
weave_target * Swarm__weave_subset(web *W, char *subweb, int open_afterwards, theme_tag *tag, char *format) ;
#line 151 "inweb/Chapter 3/The Swarm.w"
void  Swarm__weave_index_templates(web *W, char *subweb, char *format) ;
#line 213 "inweb/Chapter 3/The Swarm.w"
void  Swarm__copy_files_into_weave(web *W, char *copy_list) ;
#line 230 "inweb/Chapter 3/The Swarm.w"
void  Swarm__copy_file_into_weave(web *W, filename *F) ;
#line 265 "inweb/Chapter 3/The Swarm.w"
void  Swarm__run_contents_interpreter(web *W, char *subset, 	filename *template_filename, text_stream *contents_page_leafname) ;
#line 312 "inweb/Chapter 3/The Swarm.w"
void  Swarm__save_template_line(char *line, text_file_position *tfp, void *unused_state) ;
#line 444 "inweb/Chapter 3/The Swarm.w"
void * Swarm__heading_topmost_on_stack(int level) ;
#line 458 "inweb/Chapter 3/The Swarm.w"
void  Swarm__start_CI_loop(int level, void *from, void *to, int pos) ;
#line 467 "inweb/Chapter 3/The Swarm.w"
void  Swarm__end_CI_loop(void) ;
#line 16 "inweb/Chapter 3/The Weaver.w"
int  Weaver__weave_source(web *W, weave_target *wv) ;
#line 594 "inweb/Chapter 3/The Weaver.w"
void  Weaver__show_endnotes_on_previous_paragraph(OUTPUT_STREAM, weave_target *wv, paragraph *P) ;
#line 717 "inweb/Chapter 3/The Weaver.w"
int  Weaver__weave_table_of_contents(OUTPUT_STREAM, weave_target *wv, section *S) ;
#line 768 "inweb/Chapter 3/The Weaver.w"
int  Weaver__weave_cover_from(OUTPUT_STREAM, web *W, filename *cs_filename, weave_target *wv, int halves) ;
#line 780 "inweb/Chapter 3/The Weaver.w"
void  Weaver__scan_cover_line(char *line, text_file_position *tfp, void *state) ;
#line 822 "inweb/Chapter 3/The Weaver.w"
source_line * Weaver__weave_interface_table_for_section(OUTPUT_STREAM, weave_target *wv, source_line *L) ;
#line 14 "inweb/Chapter 3/The Tangler.w"
void  Tangler__go(web *W, tangle_target *target, filename *dest_file) ;
#line 91 "inweb/Chapter 3/The Tangler.w"
void  Tangler__tangle_paragraph(OUTPUT_STREAM, paragraph *P) ;
#line 124 "inweb/Chapter 3/The Tangler.w"
void  Tangler__tangle_code(OUTPUT_STREAM, char *original, section *S, source_line *L) ;
#line 46 "inweb/Chapter 4/Programming Languages.w"
programming_language * Languages__default(void) ;
#line 54 "inweb/Chapter 4/Programming Languages.w"
void  Languages__create_programming_languages(void) ;
#line 74 "inweb/Chapter 4/Programming Languages.w"
programming_language * Languages__new_language(char *name, char *ext) ;
#line 85 "inweb/Chapter 4/Programming Languages.w"
programming_language * Languages__language_with_name(char *lname) ;
#line 97 "inweb/Chapter 4/Programming Languages.w"
int  Languages__special_data(OUTPUT_STREAM, programming_language *pl, char *data) ;
#line 108 "inweb/Chapter 4/Programming Languages.w"
void  Languages__further_parsing(web *W, programming_language *pl) ;
#line 113 "inweb/Chapter 4/Programming Languages.w"
void  Languages__subcategorise_code(programming_language *pl, source_line *L) ;
#line 121 "inweb/Chapter 4/Programming Languages.w"
int  Languages__tangles(programming_language *pl) ;
#line 129 "inweb/Chapter 4/Programming Languages.w"
void  Languages__shebang(OUTPUT_STREAM, programming_language *pl, web *W, tangle_target *target) ;
#line 144 "inweb/Chapter 4/Programming Languages.w"
void  Languages__start_definition(OUTPUT_STREAM, programming_language *pl, 	char *term, char *start, section *S, source_line *L) ;
#line 155 "inweb/Chapter 4/Programming Languages.w"
void  Languages__prolong_definition(OUTPUT_STREAM, programming_language *pl, 	char *more, section *S, source_line *L) ;
#line 163 "inweb/Chapter 4/Programming Languages.w"
void  Languages__end_definition(OUTPUT_STREAM, programming_language *pl, 	section *S, source_line *L) ;
#line 173 "inweb/Chapter 4/Programming Languages.w"
void  Languages__additional_predeclarations(OUTPUT_STREAM, programming_language *pl, web *W) ;
#line 184 "inweb/Chapter 4/Programming Languages.w"
int  Languages__will_insert_in_tangle(programming_language *pl, source_line *L) ;
#line 189 "inweb/Chapter 4/Programming Languages.w"
void  Languages__insert_in_tangle(OUTPUT_STREAM, programming_language *pl, source_line *L) ;
#line 201 "inweb/Chapter 4/Programming Languages.w"
void  Languages__insert_line_marker(OUTPUT_STREAM, programming_language *pl, source_line *L) ;
#line 210 "inweb/Chapter 4/Programming Languages.w"
void  Languages__before_macro_expansion(OUTPUT_STREAM, programming_language *pl, cweb_macro *cwm) ;
#line 214 "inweb/Chapter 4/Programming Languages.w"
void  Languages__after_macro_expansion(OUTPUT_STREAM, programming_language *pl, cweb_macro *cwm) ;
#line 221 "inweb/Chapter 4/Programming Languages.w"
void  Languages__comment(OUTPUT_STREAM, programming_language *pl, char *comm) ;
#line 231 "inweb/Chapter 4/Programming Languages.w"
int  Languages__parse_comment(programming_language *pl, 	char *line, char *part_before_comment, char *part_within_comment) ;
#line 257 "inweb/Chapter 4/Programming Languages.w"
void  Languages__tangle_code(OUTPUT_STREAM, programming_language *pl, char *original) ;
#line 265 "inweb/Chapter 4/Programming Languages.w"
void  Languages__gnabehs(OUTPUT_STREAM, programming_language *pl, web *W) ;
#line 274 "inweb/Chapter 4/Programming Languages.w"
void  Languages__additional_tangling(programming_language *pl, web *W, tangle_target *target) ;
#line 282 "inweb/Chapter 4/Programming Languages.w"
void  Languages__begin_weave(section *S, weave_target *wv) ;
#line 290 "inweb/Chapter 4/Programming Languages.w"
void  Languages__new_tag_declared(theme_tag *tag) ;
#line 294 "inweb/Chapter 4/Programming Languages.w"
int  Languages__skip_in_weaving(programming_language *pl, weave_target *wv, source_line *L) ;
#line 299 "inweb/Chapter 4/Programming Languages.w"
int  Languages__syntax_colour(OUTPUT_STREAM, programming_language *pl, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) ;
#line 312 "inweb/Chapter 4/Programming Languages.w"
int  Languages__weave_code_line(OUTPUT_STREAM, programming_language *pl, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) ;
#line 326 "inweb/Chapter 4/Programming Languages.w"
void  Languages__analysis(programming_language *pl, section *S, int functions_too) ;
#line 330 "inweb/Chapter 4/Programming Languages.w"
void  Languages__analyse_code(programming_language *pl, web *W) ;
#line 335 "inweb/Chapter 4/Programming Languages.w"
void  Languages__post_analysis(programming_language *pl, web *W) ;
#line 105 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__further_parsing(web *W) ;
#line 217 "inweb/Chapter 4/C-Like Languages.w"
c_structure * CLike__find_structure(web *W, char *name) ;
#line 224 "inweb/Chapter 4/C-Like Languages.w"
function * CLike__get_function_with_name(char *name) ;
#line 235 "inweb/Chapter 4/C-Like Languages.w"
c_structure * CLike__attach_structure(web *W, char *name, source_line *L) ;
#line 422 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__subcategorise_code(programming_language *pl, source_line *L) ;
#line 447 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__shebang(OUTPUT_STREAM, programming_language *pl, web *W, tangle_target *target) ;
#line 459 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__additional_predeclarations(OUTPUT_STREAM, programming_language *pl, web *W) ;
#line 503 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__tangle_structure(OUTPUT_STREAM, programming_language *pl, c_structure *str) ;
#line 525 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__insert_line_marker(OUTPUT_STREAM, programming_language *pl, source_line *L) ;
#line 534 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__comment(OUTPUT_STREAM, programming_language *pl, char *comm) ;
#line 541 "inweb/Chapter 4/C-Like Languages.w"
int  CLike__parse_comment(programming_language *pl, 	char *line, char *part_before_comment, char *part_within_comment) ;
#line 571 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__before_macro_expansion(OUTPUT_STREAM, programming_language *pl, cweb_macro *cwm) ;
#line 575 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__after_macro_expansion(OUTPUT_STREAM, programming_language *pl, cweb_macro *cwm) ;
#line 583 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__begin_weave(section *S, weave_target *wv) ;
#line 624 "inweb/Chapter 4/C-Like Languages.w"
int  CLike__syntax_colour(OUTPUT_STREAM, programming_language *pl, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) ;
#line 677 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__colour_ident(section *S, char *matter, char *colouring, int from, int to) ;
#line 697 "inweb/Chapter 4/C-Like Languages.w"
int  CLike__weave_code_line(OUTPUT_STREAM, programming_language *pl, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) ;
#line 705 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__analysis(programming_language *pl, section *S, int functions_too) ;
#line 718 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__analyse_code(programming_language *pl, web *W) ;
#line 779 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__post_analysis(programming_language *pl, web *W) ;
#line 857 "inweb/Chapter 4/C-Like Languages.w"
int  CLike__section_subset(c_structure *str, int report) ;
#line 56 "inweb/Chapter 4/C for Inform.w"
int  CForInform__special_data(OUTPUT_STREAM, char *data) ;
#line 73 "inweb/Chapter 4/C for Inform.w"
void  CForInform__further_parsing(web *W) ;
#line 264 "inweb/Chapter 4/C for Inform.w"
void  CForInform__additional_predeclarations(OUTPUT_STREAM, web *W) ;
#line 285 "inweb/Chapter 4/C for Inform.w"
void  CForInform__gnabehs(OUTPUT_STREAM, web *W) ;
#line 313 "inweb/Chapter 4/C for Inform.w"
int  CForInform__will_insert_in_tangle(source_line *L) ;
#line 334 "inweb/Chapter 4/C for Inform.w"
void  CForInform__insert_in_tangle(OUTPUT_STREAM, source_line *L) ;
#line 470 "inweb/Chapter 4/C for Inform.w"
void  CForInform__tangle_code(OUTPUT_STREAM, char *original) ;
#line 580 "inweb/Chapter 4/C for Inform.w"
preform_nonterminal * CForInform__nonterminal_by_name(char *name) ;
#line 594 "inweb/Chapter 4/C for Inform.w"
char * CForInform__nonterminal_variable_identifier(char *name) ;
#line 616 "inweb/Chapter 4/C for Inform.w"
void  CForInform__additional_tangling(programming_language *pl, web *W, tangle_target *target) ;
#line 670 "inweb/Chapter 4/C for Inform.w"
void  CForInform__weave_grammar_index(OUTPUT_STREAM) ;
#line 745 "inweb/Chapter 4/C for Inform.w"
void  CForInform__new_tag_declared(theme_tag *tag) ;
#line 751 "inweb/Chapter 4/C for Inform.w"
int  CForInform__skip_in_weaving(weave_target *wv, source_line *L) ;
#line 760 "inweb/Chapter 4/C for Inform.w"
void  CForInform__begin_weave(section *S, weave_target *wv) ;
#line 766 "inweb/Chapter 4/C for Inform.w"
int  CForInform__syntax_colour(OUTPUT_STREAM, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) ;
#line 771 "inweb/Chapter 4/C for Inform.w"
int  CForInform__weave_code_line(OUTPUT_STREAM, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) ;
#line 841 "inweb/Chapter 4/C for Inform.w"
void  CForInform__analyse_code(programming_language *pl, web *W) ;
#line 20 "inweb/Chapter 5/Weave Formats.w"
void  Formats__create_weave_formats(void) ;
#line 42 "inweb/Chapter 5/Weave Formats.w"
weave_format * Formats__create_weave_format(char *name, char *ext, weave_format *intermediate) ;
#line 53 "inweb/Chapter 5/Weave Formats.w"
weave_format * Formats__parse_format(char *name) ;
#line 61 "inweb/Chapter 5/Weave Formats.w"
int  Formats__html_like(weave_format *wf) ;
#line 67 "inweb/Chapter 5/Weave Formats.w"
char * Formats__weave_file_extension(weave_format *wf) ;
#line 75 "inweb/Chapter 5/Weave Formats.w"
int  Formats__begin_weaving(web *W, char *format) ;
#line 91 "inweb/Chapter 5/Weave Formats.w"
void  Formats__end_weaving(web *W, char *format) ;
#line 100 "inweb/Chapter 5/Weave Formats.w"
void  Formats__top(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 108 "inweb/Chapter 5/Weave Formats.w"
void  Formats__subheading(OUTPUT_STREAM, weave_target *wv, int level, char *comment, char *head) ;
#line 116 "inweb/Chapter 5/Weave Formats.w"
void  Formats__toc(OUTPUT_STREAM, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) ;
#line 124 "inweb/Chapter 5/Weave Formats.w"
void  Formats__chapter_tp(OUTPUT_STREAM, weave_target *wv, chapter *C) ;
#line 132 "inweb/Chapter 5/Weave Formats.w"
void  Formats__paragraph_heading(OUTPUT_STREAM, weave_target *wv, char *TeX_macro, 	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark, 	int weight) ;
#line 145 "inweb/Chapter 5/Weave Formats.w"
void  Formats__source_code(OUTPUT_STREAM, weave_target *wv, 	int tab_stops_of_indentation, 	char *prefatory, char *matter, char *colouring, char *concluding_comment, 	int starts, int finishes, int code_mode) ;
#line 159 "inweb/Chapter 5/Weave Formats.w"
void  Formats__source_fragment(OUTPUT_STREAM, weave_target *wv, char *fragment) ;
#line 174 "inweb/Chapter 5/Weave Formats.w"
void  Formats__comment_lines(OUTPUT_STREAM, weave_target *wv, source_line *from, source_line *to) ;
#line 182 "inweb/Chapter 5/Weave Formats.w"
void  Formats__display_line(OUTPUT_STREAM, weave_target *wv, char *from) ;
#line 190 "inweb/Chapter 5/Weave Formats.w"
void  Formats__item(OUTPUT_STREAM, weave_target *wv, int depth, char *label) ;
#line 198 "inweb/Chapter 5/Weave Formats.w"
void  Formats__bar(OUTPUT_STREAM, weave_target *wv) ;
#line 206 "inweb/Chapter 5/Weave Formats.w"
void  Formats__figure(OUTPUT_STREAM, weave_target *wv, char *figname, int cm) ;
#line 214 "inweb/Chapter 5/Weave Formats.w"
void  Formats__cweb_macro(OUTPUT_STREAM, weave_target *wv, cweb_macro *cwm, int defn) ;
#line 222 "inweb/Chapter 5/Weave Formats.w"
void  Formats__pagebreak(OUTPUT_STREAM, weave_target *wv) ;
#line 230 "inweb/Chapter 5/Weave Formats.w"
void  Formats__blank_line(OUTPUT_STREAM, weave_target *wv, int in_comment) ;
#line 238 "inweb/Chapter 5/Weave Formats.w"
void  Formats__code_note(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 246 "inweb/Chapter 5/Weave Formats.w"
void  Formats__change_mode(OUTPUT_STREAM, weave_target *wv, int old_mode, int new_mode, int content) ;
#line 267 "inweb/Chapter 5/Weave Formats.w"
void  Formats__change_colour(OUTPUT_STREAM, weave_target *wv, int col, int in_code) ;
#line 275 "inweb/Chapter 5/Weave Formats.w"
void  Formats__endnote(OUTPUT_STREAM, weave_target *wv, int end) ;
#line 283 "inweb/Chapter 5/Weave Formats.w"
void  Formats__identifier(OUTPUT_STREAM, weave_target *wv, char *id) ;
#line 287 "inweb/Chapter 5/Weave Formats.w"
void  Formats__identifier_r(OUTPUT_STREAM, weave_target *wv, char *id, int within) ;
#line 309 "inweb/Chapter 5/Weave Formats.w"
void  Formats__locale(OUTPUT_STREAM, weave_target *wv, paragraph *par1, paragraph *par2) ;
#line 317 "inweb/Chapter 5/Weave Formats.w"
void  Formats__tail(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 328 "inweb/Chapter 5/Weave Formats.w"
void  Formats__post_process_weave(weave_target *wv, int open_afterwards) ;
#line 333 "inweb/Chapter 5/Weave Formats.w"
void  Formats__report_on_post_processing(weave_target *wv) ;
#line 338 "inweb/Chapter 5/Weave Formats.w"
int  Formats__substitute_post_processing_data(char *to, weave_target *wv, char *detail) ;
#line 344 "inweb/Chapter 5/Weave Formats.w"
int  Formats__index_pdfs(char *format) ;
#line 9 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__top(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 16 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__subheading(OUTPUT_STREAM, weave_target *wv, int level, char *comment, char *head) ;
#line 24 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__toc(OUTPUT_STREAM, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) ;
#line 36 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__chapter_tp(OUTPUT_STREAM, weave_target *wv, chapter *C) ;
#line 46 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__paragraph_heading(OUTPUT_STREAM, weave_target *wv, char *TeX_macro, 	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark, 	int weight) ;
#line 61 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__source_code(OUTPUT_STREAM, weave_target *wv, 	int tab_stops_of_indentation, 	char *prefatory, char *matter, char *colouring, char *concluding_comment, 	int starts, int finishes, int code_mode) ;
#line 80 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__inline_code(OUTPUT_STREAM, weave_target *wv, int enter) ;
#line 86 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__comment_lines(OUTPUT_STREAM, weave_target *wv, source_line *from, source_line *to) ;
#line 92 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__display_line(OUTPUT_STREAM, weave_target *wv, char *from) ;
#line 99 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__item(OUTPUT_STREAM, weave_target *wv, int depth, char *label) ;
#line 107 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__bar(OUTPUT_STREAM, weave_target *wv) ;
#line 114 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__figure(OUTPUT_STREAM, weave_target *wv, char *figname, int cm) ;
#line 120 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__cweb_macro(OUTPUT_STREAM, weave_target *wv, cweb_macro *cwm, int defn) ;
#line 129 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__pagebreak(OUTPUT_STREAM, weave_target *wv) ;
#line 135 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__blank_line(OUTPUT_STREAM, weave_target *wv, int in_comment) ;
#line 142 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__code_note(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 149 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__change_mode(OUTPUT_STREAM, weave_target *wv, int old_mode, int new_mode, int content) ;
#line 155 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__change_colour(OUTPUT_STREAM, weave_target *wv, int col, int in_code) ;
#line 161 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__endnote(OUTPUT_STREAM, weave_target *wv, int end) ;
#line 168 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__identifier(OUTPUT_STREAM, weave_target *wv, char *id) ;
#line 175 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__locale(OUTPUT_STREAM, weave_target *wv, paragraph *par1, paragraph *par2) ;
#line 183 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__tail(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 9 "inweb/Chapter 5/TeX Format.w"
void  TeX__top(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 35 "inweb/Chapter 5/TeX Format.w"
void  TeX__subheading(OUTPUT_STREAM, weave_target *wv, int level, char *comment, char *head) ;
#line 52 "inweb/Chapter 5/TeX Format.w"
void  TeX__toc(OUTPUT_STREAM, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) ;
#line 73 "inweb/Chapter 5/TeX Format.w"
void  TeX__chapter_tp(OUTPUT_STREAM, weave_target *wv, chapter *C) ;
#line 83 "inweb/Chapter 5/TeX Format.w"
void  TeX__paragraph_heading(OUTPUT_STREAM, weave_target *wv, char *TeX_macro, 	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark, 	int weight) ;
#line 105 "inweb/Chapter 5/TeX Format.w"
void  TeX__source_code(OUTPUT_STREAM, weave_target *wv, 	int tab_stops_of_indentation, 	char *prefatory, char *matter, char *colouring, char *concluding_comment, 	int starts, int finishes, int code_mode) ;
#line 151 "inweb/Chapter 5/TeX Format.w"
void  TeX__inline_code(OUTPUT_STREAM, weave_target *wv, int enter) ;
#line 158 "inweb/Chapter 5/TeX Format.w"
void  TeX__change_colour(OUTPUT_STREAM, weave_target *wv, int col, int in_code) ;
#line 173 "inweb/Chapter 5/TeX Format.w"
void  TeX__comment_lines(OUTPUT_STREAM, weave_target *wv, source_line *from, source_line *to) ;
#line 179 "inweb/Chapter 5/TeX Format.w"
void  TeX__display_line(OUTPUT_STREAM, weave_target *wv, char *text) ;
#line 186 "inweb/Chapter 5/TeX Format.w"
void  TeX__item(OUTPUT_STREAM, weave_target *wv, int depth, char *label) ;
#line 199 "inweb/Chapter 5/TeX Format.w"
void  TeX__bar(OUTPUT_STREAM, weave_target *wv) ;
#line 211 "inweb/Chapter 5/TeX Format.w"
void  TeX__figure(OUTPUT_STREAM, weave_target *wv, char *figname, int cm) ;
#line 229 "inweb/Chapter 5/TeX Format.w"
void  TeX__cweb_macro(OUTPUT_STREAM, weave_target *wv, cweb_macro *cwm, int defn) ;
#line 258 "inweb/Chapter 5/TeX Format.w"
void  TeX__pagebreak(OUTPUT_STREAM, weave_target *wv) ;
#line 265 "inweb/Chapter 5/TeX Format.w"
void  TeX__blank_line(OUTPUT_STREAM, weave_target *wv, int in_comment) ;
#line 273 "inweb/Chapter 5/TeX Format.w"
void  TeX__endnote(OUTPUT_STREAM, weave_target *wv, int end) ;
#line 285 "inweb/Chapter 5/TeX Format.w"
void  TeX__identifier(OUTPUT_STREAM, weave_target *wv, char *id) ;
#line 305 "inweb/Chapter 5/TeX Format.w"
void  TeX__locale(OUTPUT_STREAM, weave_target *wv, paragraph *par1, paragraph *par2) ;
#line 313 "inweb/Chapter 5/TeX Format.w"
void  TeX__code_note(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 321 "inweb/Chapter 5/TeX Format.w"
void  TeX__change_mode(OUTPUT_STREAM, weave_target *wv, int old_mode, int new_mode, int content) ;
#line 348 "inweb/Chapter 5/TeX Format.w"
void  TeX__tail(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 21 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__p(OUTPUT_STREAM, char *class) ;
#line 26 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__cp(OUTPUT_STREAM) ;
#line 31 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__pre(OUTPUT_STREAM, char *class) ;
#line 36 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__cpre(OUTPUT_STREAM) ;
#line 45 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__go_to_depth(OUTPUT_STREAM, int depth) ;
#line 70 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__exit_current_paragraph(OUTPUT_STREAM) ;
#line 83 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__top(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 107 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__subheading(OUTPUT_STREAM, weave_target *wv, int level, char *comment, char *head) ;
#line 122 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__toc(OUTPUT_STREAM, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) ;
#line 154 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__chapter_tp(OUTPUT_STREAM, weave_target *wv, chapter *C) ;
#line 163 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__paragraph_heading(OUTPUT_STREAM, weave_target *wv, char *TeX_macro, 	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark, 	int weight) ;
#line 195 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__breadcrumb(OUTPUT_STREAM, char *text, char *link) ;
#line 216 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__source_code(OUTPUT_STREAM, weave_target *wv, int tab_stops_of_indentation, 	char *prefatory, char *matter, char *colouring, char *concluding_comment, 	int starts, int finishes, int code_mode) ;
#line 262 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__inline_code(OUTPUT_STREAM, weave_target *wv, int enter) ;
#line 274 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__comment_lines(OUTPUT_STREAM, weave_target *wv, source_line *from, source_line *to) ;
#line 280 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__display_line(OUTPUT_STREAM, weave_target *wv, char *from) ;
#line 292 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__item(OUTPUT_STREAM, weave_target *wv, int depth, char *label) ;
#line 302 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__bar(OUTPUT_STREAM, weave_target *wv) ;
#line 310 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__figure(OUTPUT_STREAM, weave_target *wv, char *figname, int cm) ;
#line 322 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__cweb_macro(OUTPUT_STREAM, weave_target *wv, cweb_macro *cwm, int defn) ;
#line 338 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__pagebreak(OUTPUT_STREAM, weave_target *wv) ;
#line 345 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__blank_line(OUTPUT_STREAM, weave_target *wv, int in_comment) ;
#line 359 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__code_note(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 369 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__change_mode(OUTPUT_STREAM, weave_target *wv, int old_mode, int new_mode, int content) ;
#line 438 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__change_colour(OUTPUT_STREAM, weave_target *wv, int col, int in_code) ;
#line 458 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__endnote(OUTPUT_STREAM, weave_target *wv, int end) ;
#line 470 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__identifier(OUTPUT_STREAM, weave_target *wv, char *id) ;
#line 486 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__locale(OUTPUT_STREAM, weave_target *wv, paragraph *par1, paragraph *par2) ;
#line 501 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__xref(OUTPUT_STREAM, weave_target *wv, paragraph *P, section *from, int a_link) ;
#line 521 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__tail(OUTPUT_STREAM, weave_target *wv, char *comment) ;
#line 37 "inweb/Chapter 5/Running Through TeX.w"
void  RunningTeX__post_process_weave(weave_target *wv, int open_afterwards) ;
#line 113 "inweb/Chapter 5/Running Through TeX.w"
void  RunningTeX__scan_console_line(char *line, text_file_position *tfp, void *unused_state) ;
#line 131 "inweb/Chapter 5/Running Through TeX.w"
void  RunningTeX__report_on_post_processing(weave_target *wv) ;
#line 145 "inweb/Chapter 5/Running Through TeX.w"
int  RunningTeX__substitute_post_processing_data(char *to, weave_target *wv, char *detail) ;
void register_tangled_nonterminals(void);
#line 38 "inlib/Chapter 1/Inlib.w"
#include <wchar.h>
#ifdef PLATFORM_WINDOWS
#include "inlib/Headers/win32.h"
#else
#include <pthread.h>
#include <unistd.h>
#endif

#line 67 "inlib/Chapter 1/Inlib.w"
#define WRITE(args...) Streams__printf(OUT, args)

#define PRINT(args...) Streams__printf(STDOUT, args)

#define WRITE_TO(stream, args...) Streams__printf(stream, args)

#define LOG(args...) Streams__printf(DL, args)

#define LOGIF(aspect, args...) { \
	if (Log__aspect_switched_on(aspect##_DA)) Streams__printf(DL, args); \
}

#line 90 "inlib/Chapter 1/Inlib.w"
#define CSTRING_WRITE(to, args...) \
	CStrings__check_len((int) snprintf(to, MAX_STRING_LENGTH, args))

#line 98 "inlib/Chapter 1/Inlib.w"
void Inlib__start(void) {
	Memory__start();

	
{
#line 113 "inlib/Chapter 1/Inlib.w"
	Streams__register_writer('f', &Filenames__write);
	Streams__register_writer('p', &Pathnames__write);
	Streams__register_writer('w', &Streams__write_wide_C_string);
	Streams__register_writer('S', &Streams__write);

}
#line 101 "inlib/Chapter 1/Inlib.w"
;
	
{
#line 124 "inlib/Chapter 1/Inlib.w"
	Log__declare_aspect(DEBUGGING_LOG_INCLUSIONS_DA, L"debugging log inclusions", FALSE, FALSE);
	Log__declare_aspect(SHELL_USAGE_DA, L"shell usage", FALSE, FALSE);
	Log__declare_aspect(MEMORY_USAGE_DA, L"memory usage", FALSE, FALSE);
	Log__declare_aspect(TEXT_FILES_DA, L"text files", FALSE, FALSE);

}
#line 102 "inlib/Chapter 1/Inlib.w"
;
	
{
#line 135 "inlib/Chapter 1/Inlib.w"
	Streams__register_log_writer('S', &Streams__log);

}
#line 103 "inlib/Chapter 1/Inlib.w"
;
	
{
#line 145 "inlib/Chapter 1/Inlib.w"
	CommandLine__declare_switch(LOG_CLSW, L"log", 2);
	CommandLine__declare_switch(PLATFORM_CLSW, L"platform", 2);
	CommandLine__declare_switch(CRASH_CLSW, L"crash", 1);

}
#line 104 "inlib/Chapter 1/Inlib.w"
;
}

#line 155 "inlib/Chapter 1/Inlib.w"
void Inlib__end(void) {
	if (Log__aspect_switched_on(MEMORY_USAGE_DA)) Memory__log_statistics();
	Log__close();
	Memory__free();
}

#line 11 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifndef PLATFORM_MACOSX
#ifndef PLATFORM_WINDOWS
#ifndef PLATFORM_UNIX
#ifndef PLATFORM_ANDROID
#define PLATFORM_MACOSX /* the original home, and still the default */
#endif
#endif
#endif
#endif

#line 27 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifndef CPU_WORDSIZE_MULTIPLIER
#define CPU_WORDSIZE_MULTIPLIER 1 /* the CPU word size is by default 32 bits */
#endif

#line 58 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifdef PLATFORM_MACOSX
#define PLATFORM_STRING "osx"
#define FOLDER_SEPARATOR '/'
#define SHELL_QUOTE_CHARACTER '\''
#define POSIX_DIRECTORY_HANDLING
#define JAVASCRIPT_MODEL_1
typedef long int pointer_sized_int;
#endif

#line 70 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifdef PLATFORM_WINDOWS
#define PLATFORM_STRING "windows"
#define LOCALE_IS_ISO
#define FOLDER_SEPARATOR '\\'
#define SHELL_QUOTE_CHARACTER '\"'
#define WINDOWS_DIRECTORY_HANDLING
#define JAVASCRIPT_MODEL_2
typedef long int pointer_sized_int;
#endif

#line 95 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifdef PLATFORM_WINDOWS
#define isdigit(x) Platform__Windows_isdigit(x)
int Platform__Windows_isdigit(int c) {
	return ((c >= '0') && (c <= '9')) ? 1 : 0;
}
#endif

#line 108 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifdef PLATFORM_UNIX
#include <strings.h>
#line 111 "inlib/Chapter 1/Platform-Specific Definitions.w"
#define PLATFORM_STRING "gnome"
#define FOLDER_SEPARATOR '/'
#define SHELL_QUOTE_CHARACTER '\''
#define POSIX_DIRECTORY_HANDLING
#define JAVASCRIPT_MODEL_1
typedef long int pointer_sized_int;
#endif

#line 122 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifdef PLATFORM_ANDROID
#include <strings.h>
#line 125 "inlib/Chapter 1/Platform-Specific Definitions.w"
#define PLATFORM_STRING "android"
#define SUPPRESS_MAIN
#define FOLDER_SEPARATOR '/'
#define SHELL_QUOTE_CHARACTER '\''
#define POSIX_DIRECTORY_HANDLING
#define JAVASCRIPT_MODEL_1
typedef long int pointer_sized_int;
#endif

#line 145 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifdef POSIX_DIRECTORY_HANDLING
#include <sys/stat.h>
#include <sys/types.h>
#line 149 "inlib/Chapter 1/Platform-Specific Definitions.w"
#include <dirent.h>

int Platform__mkdir(char *path_to_folder) {
	char transcoded_pathname[2*MAX_FILENAME_LENGTH];
	Platform__transcode_ISO_string_to_locale(path_to_folder, transcoded_pathname);
	int rv;
	errno = 0;
	rv = mkdir(transcoded_pathname, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
	if (rv == 0) return TRUE;
	if (errno == EEXIST) return TRUE;
	return FALSE;
}

void *Platform__opendir(char *path_to_folder) {
	DIR *dirp = opendir(path_to_folder);
	return (void *) dirp;
}

int Platform__readdir(void *folder, char *path_to_folder,
	char *leafname) {
	char path_to[2*MAX_FILENAME_LENGTH+2];
	struct stat file_status;
	int rv;
	DIR *dirp = (DIR *) folder;
	struct dirent *dp;
	if ((dp = readdir(dirp)) == NULL) return FALSE;
	sprintf(path_to, "%s%c%s", path_to_folder, FOLDER_SEPARATOR, dp->d_name);
	rv = stat(path_to, &file_status);
	if (rv != 0) return FALSE;
	if (S_ISDIR(file_status.st_mode)) sprintf(leafname, "%s/", dp->d_name);
	else strcpy(leafname, dp->d_name);
	return TRUE;
}

void Platform__closedir(void *folder) {
	DIR *dirp = (DIR *) folder;
	closedir(dirp);
}

#endif

#line 194 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifdef WINDOWS_DIRECTORY_HANDLING

#include <sys/stat.h>
#include <dirent.h>
#line 199 "inlib/Chapter 1/Platform-Specific Definitions.w"
#include <io.h>

int Platform__mkdir(char *path_to_folder) {
	char transcoded_pathname[2*MAX_FILENAME_LENGTH];
	Platform__transcode_ISO_string_to_locale(path_to_folder, transcoded_pathname);
	int rv;
	errno = 0;
	rv = _mkdir(transcoded_pathname);
	if (rv == 0) return TRUE;
	if (errno == EEXIST) return TRUE;
	return FALSE;
}

void *Platform__opendir(char *path_to_folder) {
	DIR *dirp = opendir(path_to_folder);
    return (void *) dirp;
}

int Platform__readdir(void *folder, char *path_to_folder,
	char *leafname) {
	char path_to[2*MAX_FILENAME_LENGTH+2];
	struct _stat file_status;
	int rv;
	DIR *dirp = (DIR *) folder;
	struct dirent *dp;
	if ((dp = readdir(dirp)) == NULL) return FALSE;
	sprintf(path_to, "%s%c%s", path_to_folder, FOLDER_SEPARATOR, dp->d_name);
	rv = _stat(path_to, &file_status);
	if (rv != 0) return FALSE;
	if (S_ISDIR(file_status.st_mode))
		sprintf(leafname, "%s%c", dp->d_name, FOLDER_SEPARATOR);
	else strcpy(leafname, dp->d_name);
	return TRUE;
}

void Platform__closedir(void *folder) {
	DIR *dirp = (DIR *) folder;
	closedir(dirp);
}

#endif

#line 248 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifndef LOCALE_IS_ISO
#ifndef LOCALE_IS_UTF8
#define LOCALE_IS_UTF8 1
#endif
#endif

#line 266 "inlib/Chapter 1/Platform-Specific Definitions.w"
FILE *Platform__iso_fopen(filename *F, char *usage) {
	char transcoded_pathname[4*MAX_FILENAME_LENGTH];
	TEMPORARY_TEXT(FN);
	WRITE_TO(FN, "%f", F);
	Str__copy_to_locale_string(transcoded_pathname, FN, 4*MAX_FILENAME_LENGTH);
	DISCARD_TEXT(FN);
	return fopen(transcoded_pathname, usage);
}

FILE *Platform__iso_fopen_caseless(filename *F, char *usage) {
	char transcoded_pathname[4*MAX_FILENAME_LENGTH];
	TEMPORARY_TEXT(FN);
	WRITE_TO(FN, "%f", F);
	Str__copy_to_locale_string(transcoded_pathname, FN, 4*MAX_FILENAME_LENGTH);
	DISCARD_TEXT(FN);
	return CIFilingSystem__fopen(transcoded_pathname, usage);
}

#line 287 "inlib/Chapter 1/Platform-Specific Definitions.w"
#ifdef LOCALE_IS_ISO
void Platform__transcode_ISO_string_to_locale(char *from, char *to) {
	CStrings__copy(to, from);
}
#endif

#ifdef LOCALE_IS_UTF8
void Platform__transcode_ISO_string_to_locale(char *from, char *to) {
	CStrings__transcode_ISO_string_to_UTF8(from, to);
}
#endif

#line 25 "inlib/Chapter 2/C Strings.w"

#line 29 "inlib/Chapter 2/C Strings.w"
int CStrings__strlen_unbounded(const char *p) {
	return (int) strlen(p);
}

#line 39 "inlib/Chapter 2/C Strings.w"
int CStrings__check_len(int n) {
	if ((n > MAX_STRING_LENGTH) || (n < 0)) Errors__fatal("String overflow\n");
	return n;
}

#line 48 "inlib/Chapter 2/C Strings.w"
int CStrings__len(char *str) {
	for (int i=0; i<=MAX_STRING_LENGTH; i++)
		if (str[i] == 0) return i;
	str[MAX_STRING_LENGTH] = 0;
	return MAX_STRING_LENGTH;
}


#line 59 "inlib/Chapter 2/C Strings.w"
void CStrings__set_char(char *str, int i, int to) {
	if ((i < 0) || (i > MAX_STRING_LENGTH)) CStrings__check_len(i);
	else str[i] = (char) to;
}

#line 68 "inlib/Chapter 2/C Strings.w"
void CStrings__truncate(char *str, int len) {
	if ((len < 0) || (len > MAX_STRING_LENGTH)) { CStrings__check_len(len); str[0] = 0; }
	else str[len] = 0;
}

#line 77 "inlib/Chapter 2/C Strings.w"
void CStrings__copy(char *to, char *from) {
	CStrings__check_len(CStrings__len(from));
	int i;
	for (i=0; ((from[i]) && (i < MAX_STRING_LENGTH)); i++) to[i] = from[i];
	to[i] = 0;
}

#line 87 "inlib/Chapter 2/C Strings.w"
void CStrings__concatenate(char *to, char *from) {
	int i, L = CStrings__len(to);
	CStrings__check_len(L + CStrings__len(from));
	for (i=0; ((from[i]) && (L+i < MAX_STRING_LENGTH)); i++) to[L+i] = from[i];
	to[L+i] = 0;
}

#line 97 "inlib/Chapter 2/C Strings.w"
char *CStrings__trim_white_space(char *original) {
	int i;
	for (i=0; Characters__is_space_or_tab(original[i]); i++) ;
	original += i;
	for (i=CStrings__strlen_unbounded(original)-1; ((i>=0) && (Characters__is_space_or_tab(original[i]))); i--)
		original[i] = 0;
	return original;
}

#line 110 "inlib/Chapter 2/C Strings.w"
void CStrings__extract_word(char *fword, char *line, int size, int word) {
	int i = 0;
	fword[0] = 0;
	while (word > 0) {
		word--;
		while (Characters__is_space_or_tab(line[i])) i++;
		int j = 0;
		while ((line[i]) && (!Characters__is_space_or_tab(line[i]))) {
			if (j < size-1) fword[j++] = Characters__tolower(line[i]);
			i++;
		}
		fword[j] = 0;
		if (line[i] == 0) break;
	}
	if (word > 0) fword[0] = 0;
}

#line 130 "inlib/Chapter 2/C Strings.w"
int CStrings__eq(char *A, char *B) {
	return (CStrings__cmp(A, B) == 0)?TRUE:FALSE;
}

int CStrings__ne(char *A, char *B) {
	return (CStrings__cmp(A, B) == 0)?FALSE:TRUE;
}

#line 141 "inlib/Chapter 2/C Strings.w"
int CStrings__cmp(char *A, char *B) {
	if ((A == NULL) || (A[0] == 0)) {
		if ((B == NULL) || (B[0] == 0)) return 0;
		return -1;
	}
	if ((B == NULL) || (B[0] == 0)) return 1;
	return strcmp(A, B);
}

#line 153 "inlib/Chapter 2/C Strings.w"
int CStrings__eq_insensitive(char *A, char *B) {
	int i;
	for (i=0; ((A[i]) && (B[i])); i++)
		if (tolower(A[i]) != tolower(B[i])) return FALSE;
	if ((A[i] == 0) && (B[i] == 0)) return TRUE;
	return FALSE;
}

#line 168 "inlib/Chapter 2/C Strings.w"
void CStrings__transcode_ISO_string_to_UTF8(char *p, char *dest) {
	int i, j;
	for (i=0, j=0; p[i]; i++) {
		int charcode = (int) (((unsigned char *)p)[i]);
		if (charcode >= 128) {
			dest[j++] = (char) (0xC0 + (charcode >> 6));
			dest[j++] = (char) (0x80 + (charcode & 0x3f));
		} else {
			dest[j++] = p[i];
		}
	}
	dest[j] = 0;
}

#line 10 "inlib/Chapter 2/Debugging Log.w"
text_stream debug_log_file_struct; /* The actual debugging log file */
text_stream *debug_log_file = &debug_log_file_struct; /* The actual debugging log file */
text_stream *DL = NULL; /* Current destination of debugging text: kept |NULL| until opened */

#line 50 "inlib/Chapter 2/Debugging Log.w"

#line 66 "inlib/Chapter 2/Debugging Log.w"
int das_created = FALSE;
debugging_aspect the_debugging_aspects[MAX_DAS];

void Log__declare_aspect(int a, wchar_t *name, int def, int alt) {
	if (das_created == FALSE) {
		das_created = TRUE;
		
{
#line 83 "inlib/Chapter 2/Debugging Log.w"
	for (int a=0; a<MAX_DAS; a++) {
		debugging_aspect *da = &(the_debugging_aspects[a]);
		da->hyphenated_name = Str__new();
		da->unhyphenated_name = Str__new();
		da->negated_name = Str__new();
		da->on_or_off = FALSE;
		da->alternate = FALSE;
	}

}
#line 72 "inlib/Chapter 2/Debugging Log.w"
;
	}
	if ((a < 0) || (a >= MAX_DAS)) internal_error("aspect out of range");

	debugging_aspect *da = &(the_debugging_aspects[a]);
	
{
#line 95 "inlib/Chapter 2/Debugging Log.w"
	WRITE_TO(da->negated_name, "no-");
	for (int i=0; name[i]; i++) {
		wchar_t c = name[i];
		PUT_TO(da->unhyphenated_name, c);
		if (Characters__is_space_or_tab(c)) c = '-';
		PUT_TO(da->hyphenated_name, c);
		PUT_TO(da->negated_name, c);
	}
	da->on_or_off = def;
	da->alternate = alt;

}
#line 77 "inlib/Chapter 2/Debugging Log.w"
;
}

#line 118 "inlib/Chapter 2/Debugging Log.w"
filename *debug_log_filename = NULL;

filename *Log__get_debug_log_filename(void) {
	return debug_log_filename;
}

void Log__set_debug_log_filename(filename *F) {
	debug_log_filename = F;
}

int Log__open(void) {
	if ((debug_log_filename) && (DL == NULL)) {
		if (STREAM_OPEN_TO_FILE(debug_log_file, debug_log_filename, ISO_ENC) == FALSE)
			return FALSE;
		DL = debug_log_file;
		Streams__enable_debugging(DL);
		LOG("Debugging log of %s\n", INTOOL_NAME);
		return TRUE;
	}
	return FALSE;
}

void Log__close(void) {
	if (DL) {
		Log__show_debugging_contents();
		STREAM_CLOSE(debug_log_file); DL = NULL;
	}
}

#line 153 "inlib/Chapter 2/Debugging Log.w"
char debug_log_phase[32];
int debug_log_subheading = 1;
void Log__new_phase_of_Informs_run(char *p, char *q) {
	strcpy(debug_log_phase, p);
	LOG("\n\n-----------------------------------------------------\n");
	LOG("Phase %s ... %s", p, q);
	LOG("\n-----------------------------------------------------\n\n");
	STREAM_FLUSH(DL);
	debug_log_subheading = 1;
}

void Log__new_stage_of_Informs_run(char *p) {
	LOG("\n\n==== Phase %s.%d ... %s ====\n\n", debug_log_phase, debug_log_subheading, p);
	debug_log_subheading++;
	STREAM_FLUSH(DL);
}

#line 178 "inlib/Chapter 2/Debugging Log.w"
int Log__aspect_switched_on(int aspect) {
	int decision = the_debugging_aspects[aspect].on_or_off;
	if (aspect == DEBUGGING_LOG_INCLUSIONS_DA) decision = TRUE;
	if (decision) STREAM_FLUSH(DL);
	return decision;
}

void Log__set_aspect(int aspect, int state) {
	the_debugging_aspects[aspect].on_or_off = state;
}

#line 192 "inlib/Chapter 2/Debugging Log.w"
void Log__set_all_aspects(int new_state) {
	if (DL) LOGIF(DEBUGGING_LOG_INCLUSIONS, "Set debugging aspect: everything -> %s\n",
		new_state?"TRUE":"FALSE");
	for (int a=0; a<MAX_DAS; a++) {
		debugging_aspect *da = &(the_debugging_aspects[a]);
		da->on_or_off = new_state;
	}
}

#line 210 "inlib/Chapter 2/Debugging Log.w"
void Log__set_aspect_from_command_line(text_stream *name) {
	int list_mode = FALSE;
	if (Str__eq_C_string(name, L"everything")) { Log__set_all_aspects(TRUE); return; }
	if (Str__eq_C_string(name, L"nothing")) { Log__set_all_aspects(FALSE); return; }
	if (Str__eq_C_string(name, L"list")) list_mode = TRUE;

	for (int i=0; i<MAX_DAS; i++) {
		debugging_aspect *da = &(the_debugging_aspects[i]);
		if (Str__eq(name, da->negated_name)) {
			da->on_or_off = FALSE; return;
		}
		if ((Str__eq(name, da->hyphenated_name)) ||
			(Str__eq(name, da->unhyphenated_name))) {
			da->on_or_off = TRUE; return;
		}
		if ((list_mode) && (Str__len(da->hyphenated_name) > 0)) {
			PRINT("--log=%S  (%s)\n", da->hyphenated_name, (da->on_or_off)?"on":"off");
		}
	}
	if (list_mode == FALSE)
		PRINT("No such debugging log aspect as '%S'.\n"
			"(Try running -log list for a list of the valid aspects.)\n", name);
}

#line 239 "inlib/Chapter 2/Debugging Log.w"
void Log__tracing_on(int starred, text_stream *heading) {
	if (starred) {
		LOG("\n*** Entering sentence trace mode: %S ***\n", heading);
	} else {
		LOG("\n*** Leaving sentence trace mode: %S ***\n\n", heading);
	}
	for (int i=0; i<MAX_DAS; i++) {
		debugging_aspect *da = &(the_debugging_aspects[i]);
		int j = da->on_or_off;
		da->on_or_off = da->alternate;
		da->alternate = j;
	}
}

#line 259 "inlib/Chapter 2/Debugging Log.w"
void Log__show_debugging_settings_with_state(int state) {
	int c = 0;
	for (int i=0; i<MAX_DAS; i++) {
		debugging_aspect *da = &(the_debugging_aspects[i]);
		if (da->on_or_off == state) {
			c++;
			LOG("  %S", da->hyphenated_name);
			if (c % 6 == 0) LOG("\n");
		}
	}
	if (c == 0) { LOG("  (nothing)\n"); } else { LOG("\n"); }
}

void Log__show_debugging_contents(void) {
	if (Log__aspect_switched_on(DEBUGGING_LOG_INCLUSIONS_DA) == FALSE) return;
	LOG("\n\nThat concludes the debugging log from this run.\n"
		"Its contents were as follows -\n\n");
	LOG("Included:\n"); Log__show_debugging_settings_with_state(TRUE);
	LOG("Omitted:\n"); Log__show_debugging_settings_with_state(FALSE);
}

#line 39 "inlib/Chapter 2/Memory.w"

#line 86 "inlib/Chapter 2/Memory.w"

#line 92 "inlib/Chapter 2/Memory.w"
allocation_status_structure alloc_status[NO_MEMORY_TYPES];

void Memory__start(void) {
	int i;
	for (i=0; i<NO_MEMORY_TYPES; i++) {
		alloc_status[i].first_in_memory = NULL;
		alloc_status[i].last_in_memory = NULL;
		alloc_status[i].objects_allocated = 0;
		alloc_status[i].objects_count = 0;
		alloc_status[i].bytes_allocated = 0;
		alloc_status[i].no_allocated_together = 1;
		alloc_status[i].name_of_type = "unused";
	}
}

#line 147 "inlib/Chapter 2/Memory.w"
int no_blocks_allocated = 0;
int total_objects_allocated = 0; /* a potentially larger number, used only for the debugging log */

#line 161 "inlib/Chapter 2/Memory.w"

#line 165 "inlib/Chapter 2/Memory.w"
memblock_header *first_memblock_header = NULL; /* head of list of memory blocks */
memblock_header *current_memblock_header = NULL; /* tail of list of memory blocks */

int used_in_current_memblock = 0; /* number of bytes so far used in the tail memory block */

#line 174 "inlib/Chapter 2/Memory.w"
void Memory__allocate_another_block(void) {
	unsigned char *cp;
	memblock_header *mh;

	
{
#line 191 "inlib/Chapter 2/Memory.w"
	int i;
	if (no_blocks_allocated++ >= MAX_BLOCKS_ALLOWED)
		Errors__fatal(
			"the memory manager has halted inweb, which seems to be generating "
			"endless structures. Presumably it is trapped in a loop");
	Memory__check_memory_integrity();
	cp = (unsigned char *) (malloc(MEMORY_GRANULARITY));
	if (cp == NULL) Errors__fatal("Run out of memory: malloc failed");
	for (i=0; i<MEMORY_GRANULARITY; i++) cp[i] = 0;

}
#line 178 "inlib/Chapter 2/Memory.w"
;

	mh = (memblock_header *) cp;
	used_in_current_memblock = sizeof(memblock_header) + SAFETY_MARGIN;
	mh->the_memory = (void *) (cp + used_in_current_memblock);

	
{
#line 205 "inlib/Chapter 2/Memory.w"
	if (current_memblock_header == NULL) {
		mh->block_number = 0;
		first_memblock_header = mh;
	} else {
		mh->block_number = current_memblock_header->block_number + 1;
		current_memblock_header->next = mh;
	}
	current_memblock_header = mh;

}
#line 184 "inlib/Chapter 2/Memory.w"
;
}

#line 219 "inlib/Chapter 2/Memory.w"
void Memory__free(void) {
	Memory__free_ssas();
	memblock_header *mh = first_memblock_header;
	while (mh != NULL) {
		memblock_header *next_mh = mh->next;
		void *p = (void *) mh;
		free(p);
		mh = next_mh;
	}
}

#line 246 "inlib/Chapter 2/Memory.w"

#line 252 "inlib/Chapter 2/Memory.w"
memory_frame *first_memory_frame = NULL; /* earliest memory frame ever allocated */
memory_frame *last_memory_frame = NULL;  /* most recent memory frame allocated */

#line 263 "inlib/Chapter 2/Memory.w"
int calls_to_cmi = 0;
void Memory__check_memory_integrity(void) {
	int c;
	memory_frame *mf;
	c = calls_to_cmi++;
	if (!((c<10) || (c == 100) || (c == 1000) || (c == 10000))) return;

	for (c = 0, mf = first_memory_frame; mf; c++, mf = mf->next_frame)
		if (mf->integrity_check != INTEGRITY_NUMBER)
			Errors__fatal("Memory manager failed integrity check");
}

void Memory__debug_memory_frames(int from, int to) {
	int c;
	memory_frame *mf;
	for (c = 0, mf = first_memory_frame; (mf) && (c <= to); c++, mf = mf->next_frame)
		if (c >= from) {
			char *desc = "corrupt";
			if (mf->integrity_check == INTEGRITY_NUMBER)
				desc = alloc_status[mf->mem_type].name_of_type;
		}
}

#line 292 "inlib/Chapter 2/Memory.w"
void *Memory__allocate(int mem_type, int extent) {
	static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
	pthread_mutex_lock(&mutex);

	unsigned char *cp;
	memory_frame *mf;
	int bytes_free_in_current_memblock, extent_without_overheads = extent;

	extent += sizeof(memory_frame); /* each allocation is preceded by a memory frame */
	extent += SAFETY_MARGIN; /* each allocation is followed by |SAFETY_MARGIN| null bytes */

	
{
#line 329 "inlib/Chapter 2/Memory.w"
	if (current_memblock_header == NULL) Memory__allocate_another_block();
	bytes_free_in_current_memblock = MEMORY_GRANULARITY - (used_in_current_memblock + extent);
	if (bytes_free_in_current_memblock < BLANK_END_SIZE) {
		Memory__allocate_another_block();
		if (extent+BLANK_END_SIZE >= MEMORY_GRANULARITY)
			Errors__fatal("Memory manager failed because granularity too low");
	}

}
#line 303 "inlib/Chapter 2/Memory.w"
;

	cp = ((unsigned char *) (current_memblock_header->the_memory)) + used_in_current_memblock;
	used_in_current_memblock += extent;

	mf = (memory_frame *) cp; /* the new memory frame, */
	cp = cp + sizeof(memory_frame); /* following which is the actual allocated data */

	mf->integrity_check = INTEGRITY_NUMBER;
	mf->allocation_id = alloc_status[mem_type].objects_allocated;
	mf->mem_type = mem_type;

	
{
#line 340 "inlib/Chapter 2/Memory.w"
	mf->next_frame = NULL;
	if (first_memory_frame == NULL) first_memory_frame = mf;
	else last_memory_frame->next_frame = mf;
	last_memory_frame = mf;

}
#line 315 "inlib/Chapter 2/Memory.w"
;
	
{
#line 348 "inlib/Chapter 2/Memory.w"
	if (alloc_status[mem_type].first_in_memory == NULL)
		alloc_status[mem_type].first_in_memory = (void *) cp;
	alloc_status[mem_type].last_in_memory = (void *) cp;
	alloc_status[mem_type].objects_allocated++;
	alloc_status[mem_type].bytes_allocated += extent_without_overheads;

}
#line 316 "inlib/Chapter 2/Memory.w"
;

	total_objects_allocated++;

	pthread_mutex_unlock(&mutex);
	return (void *) cp;
}

#line 493 "inlib/Chapter 2/Memory.w"
ALLOCATE_INDIVIDUALLY(filename)
ALLOCATE_INDIVIDUALLY(pathname)
ALLOCATE_INDIVIDUALLY(string_storage_area)
ALLOCATE_INDIVIDUALLY(simple_memory_claim)
ALLOCATE_INDIVIDUALLY(scan_directory)
ALLOCATE_INDIVIDUALLY(ebook)
ALLOCATE_INDIVIDUALLY(ebook_datum)
ALLOCATE_INDIVIDUALLY(ebook_volume)
ALLOCATE_INDIVIDUALLY(ebook_chapter)
ALLOCATE_INDIVIDUALLY(ebook_page)
ALLOCATE_INDIVIDUALLY(ebook_image)
ALLOCATE_INDIVIDUALLY(HTML_file_state)
ALLOCATE_INDIVIDUALLY(command_line_switch)

ALLOCATE_IN_ARRAYS(text_stream, 100)

#line 522 "inlib/Chapter 2/Memory.w"
char *extra_memory_needs[];
char *memory_needs[NUMBER_OF_MREASONS] = {
	"text stream storage",
	"filename/pathname storage",
	"string storage"
};

char *Memory__description_of_reason(int r) {
	if (r < NO_INLIB_MREASONS) return memory_needs[r];
	return extra_memory_needs[r - NO_INLIB_MREASONS];
}

#line 542 "inlib/Chapter 2/Memory.w"
int max_memory_at_once_for_each_need[NUMBER_OF_MREASONS],
	memory_claimed_for_each_need[NUMBER_OF_MREASONS],
	number_of_claims_for_each_need[NUMBER_OF_MREASONS];
int total_claimed_simply = 0;

#line 554 "inlib/Chapter 2/Memory.w"
void *Memory__I7_calloc(int how_many, int size_in_bytes, int reason) {
	return Memory__I7_alloc(how_many, size_in_bytes, reason);
}
void *Memory__I7_malloc(int size_in_bytes, int reason) {
	return Memory__I7_alloc(-1, size_in_bytes, reason);
}

#line 564 "inlib/Chapter 2/Memory.w"
void *Memory__I7_alloc(int N, int S, int R) {
	void *pointer;
	int bytes_needed;
	if ((R < 0) || (R >= NUMBER_OF_MREASONS)) internal_error("no such memory reason");
	if (total_claimed_simply == 0) 
{
#line 598 "inlib/Chapter 2/Memory.w"
	int i;
	for (i=0; i<NUMBER_OF_MREASONS; i++) {
		max_memory_at_once_for_each_need[i] = 0;
		memory_claimed_for_each_need[i] = 0;
		number_of_claims_for_each_need[i] = 0;
	}

}
#line 568 "inlib/Chapter 2/Memory.w"
;
	
{
#line 582 "inlib/Chapter 2/Memory.w"
	if (N > 0) {
		pointer = calloc((size_t) N, (size_t) S);
		bytes_needed = N*S;
	} else {
		pointer = malloc((size_t) S);
		bytes_needed = S;
	}
	if (pointer == NULL) {
		Errors__fatal_with_C_string("Out of memory for %s", Memory__description_of_reason(R));
	}

}
#line 569 "inlib/Chapter 2/Memory.w"
;
	
{
#line 608 "inlib/Chapter 2/Memory.w"
	memory_claimed_for_each_need[R] += bytes_needed;
	total_claimed_simply += bytes_needed;
	number_of_claims_for_each_need[R]++;
	if (memory_claimed_for_each_need[R] > max_memory_at_once_for_each_need[R])
		max_memory_at_once_for_each_need[R] = memory_claimed_for_each_need[R];

}
#line 570 "inlib/Chapter 2/Memory.w"
;
	simple_memory_claim *smc = CREATE(simple_memory_claim);
	smc->memory_claimed = pointer;
	smc->extent_of_claim = bytes_needed;
	return pointer;
}

#line 621 "inlib/Chapter 2/Memory.w"
void Memory__I7_free(void *pointer, int R) {
	if ((R < 0) || (R >= NUMBER_OF_MREASONS)) internal_error("no such memory reason");
	if (pointer == NULL) internal_error("can't free NULL memory");
	simple_memory_claim *smc;
	LOOP_OVER(smc, simple_memory_claim)
		if (smc->memory_claimed == pointer) {
			free(pointer);
			memory_claimed_for_each_need[R] -= smc->extent_of_claim;
			total_claimed_simply -= smc->extent_of_claim;
			DESTROY(smc, simple_memory_claim);
			return;
		}
	internal_error("can't free this memory, which is not now allocated");
}

#line 642 "inlib/Chapter 2/Memory.w"
void Memory__I7_free_remaining(void) {
	simple_memory_claim *smc;
	LOOP_OVER(smc, simple_memory_claim) {
		free (smc->memory_claimed);
		total_claimed_simply -= smc->extent_of_claim;
	}
	if (total_claimed_simply != 0)
		internal_error("memory not freed exactly correctly");
}

#line 663 "inlib/Chapter 2/Memory.w"

string_storage_area *current_ssa = NULL;

#line 671 "inlib/Chapter 2/Memory.w"
char *Memory__new_string(char *from) {
	int length_needed = CStrings__len(from) + 1;
	if (!((current_ssa) &&
		(current_ssa->first_free_byte + length_needed < SSA_CAPACITY))) {
		current_ssa = CREATE(string_storage_area);
		current_ssa->storage_at = Memory__I7_malloc(SSA_CAPACITY, STRING_STORAGE_MREASON);
		current_ssa->first_free_byte = 0;
	}
	char *rp = current_ssa->storage_at + current_ssa->first_free_byte;
	current_ssa->first_free_byte += length_needed;
	strcpy(rp, from);
	return rp;
}

#line 688 "inlib/Chapter 2/Memory.w"
void Memory__free_ssas(void) {
	string_storage_area *ssa;
	LOOP_OVER(ssa, string_storage_area)
		Memory__I7_free(ssa->storage_at, STRING_STORAGE_MREASON);
}

#line 698 "inlib/Chapter 2/Memory.w"
int Memory__log_usage(int total) {
	if (total_claimed_simply == 0) return 0;
	int i, t = 0;
	for (i=0; i<NUMBER_OF_MREASONS; i++) {
		t += max_memory_at_once_for_each_need[i];
		if (total > 0)
			LOG("0.%03d: %s - %d bytes in %d claim(s)\n",
				Memory__proportion(max_memory_at_once_for_each_need[i], total),
				Memory__description_of_reason(i),
				max_memory_at_once_for_each_need[i],
				number_of_claims_for_each_need[i]);
	}
	return t;
}

#line 717 "inlib/Chapter 2/Memory.w"
void Memory__log_statistics(void) {
	int total_for_objects = MEMORY_GRANULARITY*no_blocks_allocated; /* usage in bytes */
	int total_for_SMAs = Memory__log_usage(0); /* usage in bytes */
	int sorted_usage[NO_MEMORY_TYPES]; /* memory type numbers, in usage order */
	int total = (total_for_objects + total_for_SMAs)/1024; /* total memory usage in KB */

	
{
#line 752 "inlib/Chapter 2/Memory.w"
	int i;
	for (i=0; i<NO_MEMORY_TYPES; i++) sorted_usage[i] = i;
	qsort(sorted_usage, (size_t) NO_MEMORY_TYPES, sizeof(int), Memory__compare_usage);

}
#line 723 "inlib/Chapter 2/Memory.w"
;

	int total_for_objects_used = 0; /* out of the |total_for_objects|, the bytes used */
	int total_objects = 0;
	
{
#line 735 "inlib/Chapter 2/Memory.w"
	int i, j;
	for (j=0; j<NO_MEMORY_TYPES; j++) {
		i = sorted_usage[j];
		if (alloc_status[i].objects_allocated != 0) {
			if (alloc_status[i].no_allocated_together == 1)
				total_objects += alloc_status[i].objects_allocated;
			else
				total_objects += alloc_status[i].objects_allocated*
									alloc_status[i].no_allocated_together;
			total_for_objects_used += alloc_status[i].bytes_allocated;
		}
	}

}
#line 727 "inlib/Chapter 2/Memory.w"
;
	int overhead_for_objects = total_for_objects - total_for_objects_used; /* bytes wasted */
	
{
#line 759 "inlib/Chapter 2/Memory.w"
	LOG("\nReport by memory manager:\n\n");
	LOG("Total consumption was %dK = %dMB, divided up in the following proportions:\n",
		total, (total+512)/1024);

	LOG("0.%03d: %d objects in %d frames in %d memory blocks (of %dK each):\n",
		Memory__proportion(total_for_objects, total),
		total_objects, total_objects_allocated, no_blocks_allocated, MEMORY_GRANULARITY/1024);
	LOG("    0.%03d: memory manager overhead - %d bytes\n",
		Memory__proportion(overhead_for_objects, total), overhead_for_objects);
	int i, j;
	for (j=0; j<NO_MEMORY_TYPES; j++) {
		i = sorted_usage[j];
		if (alloc_status[i].objects_allocated != 0) {
			LOG("    0.%03d: %s  -  ",
				Memory__proportion(alloc_status[i].bytes_allocated, total),
				alloc_status[i].name_of_type);
			if (alloc_status[i].no_allocated_together == 1) {
				LOG("%d ", alloc_status[i].objects_count);
				if (alloc_status[i].objects_count != alloc_status[i].objects_allocated)
					LOG("(+%d deleted) ",
						alloc_status[i].objects_allocated - alloc_status[i].objects_count);
			} else LOG("%d blocks of %d = %d ",
				alloc_status[i].objects_allocated, alloc_status[i].no_allocated_together,
				alloc_status[i].objects_allocated*alloc_status[i].no_allocated_together);
			LOG("objects, %d bytes\n", alloc_status[i].bytes_allocated);
		}
	}
	Memory__log_usage(total);

}
#line 729 "inlib/Chapter 2/Memory.w"
;
}

#line 791 "inlib/Chapter 2/Memory.w"
int Memory__compare_usage(const void *ent1, const void *ent2) {
	int ix1 = *((const int *) ent1);
	int ix2 = *((const int *) ent2);
	return alloc_status[ix2].bytes_allocated - alloc_status[ix1].bytes_allocated;
}

#line 801 "inlib/Chapter 2/Memory.w"
int Memory__proportion(int bytes, int total) {
	float B = (float) bytes, T = (float) total;
	float P = (1000*B)/(1024*T);
	return (int) P;
}

#line 221 "inlib/Chapter 2/Streams.w"

#line 232 "inlib/Chapter 2/Streams.w"
int total_file_writes = 0; /* number of text files opened for writing during the run */

#line 245 "inlib/Chapter 2/Streams.w"
void Streams__initialise(text_stream *stream) {
	if (stream == NULL) internal_error("tried to initialise NULL stream");
	stream->stream_flags = 0;
	stream->write_to_file = NULL;
	stream->write_to_memory = NULL;
	stream->chars_written = 0;
	stream->chars_capacity = 2147483647;
	stream->stream_continues = NULL;
	stream->as_HTML = NULL;
	stream->file_written = NULL;
}

#line 260 "inlib/Chapter 2/Streams.w"
void Streams__enable_debugging(text_stream *stream) {
	stream->stream_flags |= USES_LOG_ESCAPES_STRF;
}

void Streams__declare_as_HTML(text_stream *stream, HTML_file_state *hs) {
	stream->as_HTML = hs;
}

HTML_file_state *Streams__get_HTML_file_state(text_stream *stream) {
	return stream->as_HTML;
}

#line 275 "inlib/Chapter 2/Streams.w"
void Streams__log(OUTPUT_STREAM, void *vS) {
	text_stream *stream = (text_stream *) vS;
	if (stream == NULL) {
		WRITE("NULL");
	} else if (stream->write_to_file) {
		WRITE("F'%f'(%d)", stream->file_written, stream->chars_written);
	} else {
		WRITE("S%x(", (long int) stream);
		while (stream) {
			WRITE("%d/%d", stream->chars_written, stream->chars_capacity);
			if (stream->stream_continues) WRITE("+");
			stream = stream->stream_continues;
		}
		WRITE(")");
	}
}

#line 297 "inlib/Chapter 2/Streams.w"
text_stream STDOUT_struct; int stdout_wrapper_initialised = FALSE;
text_stream *Streams__get_stdout(void) {
	if (stdout_wrapper_initialised == FALSE) {
		Streams__initialise(&STDOUT_struct); STDOUT_struct.write_to_file = stdout;
		stdout_wrapper_initialised = TRUE;
		#ifdef LOCALE_IS_ISO
		STDOUT_struct.stream_flags |= FILE_ENCODING_ISO_STRF;
		#endif
		#ifdef LOCALE_IS_UTF8
		STDOUT_struct.stream_flags |= FILE_ENCODING_UTF8_STRF;
		#endif
	}
	return &STDOUT_struct;
}

#line 315 "inlib/Chapter 2/Streams.w"
text_stream STDERR_struct; int stderr_wrapper_initialised = FALSE;
text_stream *Streams__get_stderr(void) {
	if (stderr_wrapper_initialised == FALSE) {
		Streams__initialise(&STDERR_struct); STDERR_struct.write_to_file = stderr;
		stderr_wrapper_initialised = TRUE;
		#ifdef LOCALE_IS_ISO
		STDERR_struct.stream_flags |= FILE_ENCODING_ISO_STRF;
		#endif
		#ifdef LOCALE_IS_UTF8
		STDERR_struct.stream_flags |= FILE_ENCODING_UTF8_STRF;
		#endif
	}
	return &STDERR_struct;
}

#line 335 "inlib/Chapter 2/Streams.w"
int Streams__open_to_file(text_stream *stream, filename *name, int encoding) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	if (name == NULL) internal_error("stream_open_to_file on null filename");
	Streams__initialise(stream);
	switch(encoding) {
		case UTF8_ENC: stream->stream_flags |= FILE_ENCODING_UTF8_STRF; break;
		case ISO_ENC: stream->stream_flags |= FILE_ENCODING_ISO_STRF; break;
		default: internal_error("stream has unknown text encoding");
	}
	stream->write_to_file = Platform__iso_fopen(name, "w");
	if (stream->write_to_file == NULL) return FALSE;
	stream->file_written = name;
	total_file_writes++;
	return TRUE;
}

#line 354 "inlib/Chapter 2/Streams.w"
int Streams__open_to_file_append(text_stream *stream, filename *name, int encoding) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	if (name == NULL) internal_error("stream_open_to_file on null filename");
	Streams__initialise(stream);
	switch(encoding) {
		case UTF8_ENC: stream->stream_flags |= FILE_ENCODING_UTF8_STRF; break;
		case ISO_ENC: stream->stream_flags |= FILE_ENCODING_ISO_STRF; break;
		default: internal_error("stream has unknown text encoding");
	}
	stream->write_to_file = Platform__iso_fopen(name, "a");
	if (stream->write_to_file == NULL) return FALSE;
	total_file_writes++;
	return TRUE;
}

#line 375 "inlib/Chapter 2/Streams.w"
int Streams__open_to_memory(text_stream *stream, int capacity) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	if (capacity < SPACE_AT_END_OF_STREAM) capacity += SPACE_AT_END_OF_STREAM;
	Streams__initialise(stream);
	stream->write_to_memory = Memory__I7_calloc(capacity, sizeof(wchar_t), STREAM_MREASON);
	if (stream->write_to_memory == NULL) return FALSE;
	(stream->write_to_memory)[0] = 0;
	stream->stream_flags |= MALLOCED_STRF;
	stream->chars_capacity = capacity;
	return TRUE;
}

#line 391 "inlib/Chapter 2/Streams.w"
text_stream Streams__new_buffer(int capacity, wchar_t *at) {
	if (at == NULL) internal_error("tried to make stream wrapper for NULL string");
	if (capacity < SPACE_AT_END_OF_STREAM)
		internal_error("memory stream too small");
	text_stream stream;
	Streams__initialise(&stream);
	stream.write_to_memory = at;
	(stream.write_to_memory)[0] = 0;
	stream.chars_capacity = capacity;
	return stream;
}

#line 409 "inlib/Chapter 2/Streams.w"
int Streams__open_from_wide_string(text_stream *stream, wchar_t *c_string) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	int capacity = (c_string)?((int) wcslen(c_string)):0;
	
{
#line 458 "inlib/Chapter 2/Streams.w"
	if (capacity < 8) capacity = 8;
	capacity += 1+SPACE_AT_END_OF_STREAM;
	int rv = Streams__open_to_memory(stream, capacity);
	if (rv == FALSE) return FALSE;

}
#line 412 "inlib/Chapter 2/Streams.w"
;
	if (c_string) Streams__write_wide_string(stream, c_string);
	return TRUE;
}

void Streams__write_wide_string(text_stream *stream, wchar_t *c_string) {
	for (int i=0; c_string[i]; i++) Streams__putc(c_string[i], stream);
}

#line 425 "inlib/Chapter 2/Streams.w"
int Streams__open_from_ISO_string(text_stream *stream, char *c_string) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	int capacity = (c_string)?((int) CStrings__strlen_unbounded(c_string)):0;
	
{
#line 458 "inlib/Chapter 2/Streams.w"
	if (capacity < 8) capacity = 8;
	capacity += 1+SPACE_AT_END_OF_STREAM;
	int rv = Streams__open_to_memory(stream, capacity);
	if (rv == FALSE) return FALSE;

}
#line 428 "inlib/Chapter 2/Streams.w"
;
	if (c_string) Streams__write_ISO_string(stream, c_string);
	return TRUE;
}

void Streams__write_ISO_string(text_stream *stream, char *c_string) {
	for (int i=0; c_string[i]; i++) Streams__putc(c_string[i], stream);
}

#line 440 "inlib/Chapter 2/Streams.w"
int Streams__open_from_UTF8_string(text_stream *stream, char *c_string) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	int capacity = (c_string)?((int) CStrings__strlen_unbounded(c_string)):0;
	
{
#line 458 "inlib/Chapter 2/Streams.w"
	if (capacity < 8) capacity = 8;
	capacity += 1+SPACE_AT_END_OF_STREAM;
	int rv = Streams__open_to_memory(stream, capacity);
	if (rv == FALSE) return FALSE;

}
#line 443 "inlib/Chapter 2/Streams.w"
;
	if (c_string) Streams__write_UTF8_string(stream, c_string);
	return TRUE;
}

void Streams__write_UTF8_string(text_stream *stream, char *c_string) {
	unicode_file_buffer ufb = TextFiles__create_ufb();
	int c;
	while ((c = TextFiles__utf8_fgetc(NULL, &c_string, FALSE, &ufb)) != 0)
		Streams__putc(c, stream);
}

#line 467 "inlib/Chapter 2/Streams.w"
void Streams__write_as_wide_string(wchar_t *C_string, text_stream *stream, int buffer_size) {
	if (buffer_size == 0) return;
	if (stream == NULL) { C_string[0] = 0; return; }
	if (stream->write_to_file) internal_error("stream_get_text on file stream");
	int i = 0;
	while (stream) {
		for (int j=0; j<stream->chars_written; j++) {
			if (i >= buffer_size-1) break;
			C_string[i++] = stream->write_to_memory[j];
		}
		stream = stream->stream_continues;
	}
	C_string[i] = 0;
}

#line 486 "inlib/Chapter 2/Streams.w"
void Streams__write_as_ISO_string(char *C_string, text_stream *stream, int buffer_size) {
	if (buffer_size == 0) return;
	if (stream == NULL) { C_string[0] = 0; return; }
	if (stream->write_to_file) internal_error("stream_get_text on file stream");
	int i = 0;
	while (stream) {
		for (int j=0; j<stream->chars_written; j++) {
			if (i >= buffer_size-1) break;
			wchar_t c = stream->write_to_memory[j];
			if (c < 256) C_string[i++] = (char) c; else C_string[i++] = '?';
		}
		stream = stream->stream_continues;
	}
	C_string[i] = 0;
}

#line 506 "inlib/Chapter 2/Streams.w"
void Streams__write_as_UTF8_string(char *C_string, text_stream *stream, int buffer_size) {
	if (buffer_size == 0) return;
	if (stream == NULL) { C_string[0] = 0; return; }
	if (stream->write_to_file) internal_error("stream_get_text on file stream");
	unsigned char *to = (unsigned char *) C_string;
	int i = 0;
	while (stream) {
		for (int j=0; j<stream->chars_written; j++) {
			unsigned int c = (unsigned int) stream->write_to_memory[j];
			if (c >= 0x800) {
				if (i >= buffer_size-3) break;
				to[i++] = 0xE0 + (unsigned char) (c >> 12);
				to[i++] = 0x80 + (unsigned char) ((c >> 6) & 0x3f);
				to[i++] = 0x80 + (unsigned char) (c & 0x3f);
			} else if (c >= 0x80) {
				if (i >= buffer_size-2) break;
				to[i++] = 0xC0 + (unsigned char) (c >> 6);
				to[i++] = 0x80 + (unsigned char) (c & 0x3f);
			} else {
				if (i >= buffer_size-1) break;
				to[i++] = (unsigned char) c;
			}
		}
		stream = stream->stream_continues;
	}
	to[i] = 0;
}

#line 537 "inlib/Chapter 2/Streams.w"
int Streams__open_from_locale_string(text_stream *stream, char *C_string) {
	#ifdef LOCALE_IS_UTF8
	return Streams__open_from_ISO_string(stream, C_string);
	#endif
	#ifdef LOCALE_IS_ISO
	return Streams__open_from_ISO_string(stream, C_string);
	#endif
}

void Streams__write_as_locale_string(char *C_string, text_stream *stream, int buffer_size) {
	#ifdef LOCALE_IS_UTF8
	Streams__write_as_UTF8_string(C_string, stream, buffer_size);
	#endif
	#ifdef LOCALE_IS_ISO
	Streams__write_as_ISO_string(C_string, stream, buffer_size);
	#endif
}

void Streams__write_locale_string(text_stream *stream, char *C_string) {
	#ifdef LOCALE_IS_UTF8
	Streams__write_UTF8_string(stream, C_string);
	#endif
	#ifdef LOCALE_IS_ISO
	Streams__write_ISO_string(stream, C_string);
	#endif
}

#line 569 "inlib/Chapter 2/Streams.w"
void Streams__flush(text_stream *stream) {
	if (stream == NULL) return;
	if (stream->write_to_file) fflush(stream->write_to_file);
}

#line 577 "inlib/Chapter 2/Streams.w"
void Streams__close(text_stream *stream) {
	if (stream == NULL) internal_error("tried to close NULL stream");
	if (stream == &STDOUT_struct) internal_error("tried to close STDOUT stream");
	if (stream == &STDERR_struct) internal_error("tried to close STDERR stream");
	if (stream->chars_capacity == -1) internal_error("stream closed twice");
	if (stream->stream_continues) {
		Streams__close(stream->stream_continues);
		stream->stream_continues = NULL;
	}
	stream->chars_capacity = -1; /* mark as closed */
	if (stream->write_to_file) 
{
#line 598 "inlib/Chapter 2/Streams.w"
	if ((ferror(stream->write_to_file)) || (fclose(stream->write_to_file) == EOF))
		Errors__fatal("The host computer reported an error trying to write a text file");
	if (stream != DL)
		LOGIF(TEXT_FILES, "Text file '%f' (%s): %d characters written\n",
			stream->file_written,
			(stream->stream_flags & FILE_ENCODING_UTF8_STRF)?"UTF8":"ISO",
			stream->chars_written);
	stream->write_to_file = NULL;

}
#line 587 "inlib/Chapter 2/Streams.w"
;
	if (stream->write_to_memory) 
{
#line 617 "inlib/Chapter 2/Streams.w"
	if ((stream->stream_flags) & MALLOCED_STRF) {
		Memory__I7_free(stream->write_to_memory, STREAM_MREASON);
		stream->write_to_memory = NULL;
		stream = NULL;
	}

}
#line 588 "inlib/Chapter 2/Streams.w"
;
}

#line 629 "inlib/Chapter 2/Streams.w"
typedef void (*writer_function)(text_stream *, char *, void *);
typedef void (*log_function)(text_stream *, void *);
int escapes_registered = FALSE;
writer_function the_escapes[256];
int log_escapes_registered = FALSE;
log_function log_escapes[256];

void Streams__register_writer(int esc, void (*f)(text_stream *, char *, void *)) {
	if (escapes_registered == FALSE) {
		escapes_registered = TRUE;
		for (int i=0; i<256; i++) the_escapes[i] = NULL;
		char *directly_handled = "cdgisx";
		for (int i=0; directly_handled[i]; i++) the_escapes[i] = &Streams__dummy_writer;
	}
	if ((esc < 0) || (esc > 255) || (Characters__isalpha((char) esc) == FALSE))
		internal_error("nonalphabetic escape");
	if ((the_escapes[esc]) && (the_escapes[esc] != f))
		internal_error("clash of escapes");
	the_escapes[esc] = f;
}

void Streams__dummy_writer(OUTPUT_STREAM, char *format_string, void *data) {
	internal_error("error in stream writer");
}

#line 657 "inlib/Chapter 2/Streams.w"
void Streams__write_wide_C_string(OUTPUT_STREAM, char *format_string, void *vW) {
	wchar_t *W = (wchar_t *) vW;
	for (int j = 0; W[j]; j++) PUT(W[j]);
}

#line 665 "inlib/Chapter 2/Streams.w"
void Streams__register_log_writer(int esc, void (*f)(text_stream *, void *)) {
	if (log_escapes_registered == FALSE) {
		log_escapes_registered = TRUE;
		for (int i=0; i<256; i++) log_escapes[i] = NULL;
	}
	if ((esc < 0) || (esc > 255) || (Characters__isalpha((char) esc) == FALSE))
		internal_error("nonalphabetic escape");
	if ((log_escapes[esc]) && (log_escapes[esc] != f))
		internal_error("clash of escapes");
	log_escapes[esc] = f;
}

void Streams__printf(text_stream *stream, char *fmt, ...) {
	va_list ap; /* the variable argument list signified by the dots */
	char *p;
	if (stream == NULL) return;
	va_start(ap, fmt); /* macro to begin variable argument processing */
	for (p = fmt; *p; p++) {
		switch (*p) {
			case '%': 
{
#line 706 "inlib/Chapter 2/Streams.w"
	int ival; double dval; char *sval;
	char format_string[8], category = ' ';
	int i = 1;
	format_string[0] = '%';
	p++;
	while (*p) {
		format_string[i++] = *p;
		if ((islower(*p)) || (isupper(*p)) || (*p == '%')) category = *p;
		p++;
		if ((category != ' ') || (i==6)) break;
	}
	format_string[i] = 0; p--;
	#pragma clang diagnostic push
	#pragma clang diagnostic ignored "-Wformat-nonliteral"
	switch (category) {
		case 'c': case 'd': case 'i': case 'x': { /* |char| is promoted to |int| in variable arguments */
			ival = va_arg(ap, int);
			char temp[256];
			if (snprintf(temp, 255, format_string, ival) >= 255) strcpy(temp, "?");
			for (int j = 0; temp[j]; j++) Streams__putc(temp[j], stream);
			break;
		}
		case 'g': {
			dval = va_arg(ap, double);
			char temp[256];
			if (snprintf(temp, 255, format_string, dval) >= 255) strcpy(temp, "?");
			for (int j = 0; temp[j]; j++) Streams__putc(temp[j], stream);
			break;
		}
		case 's':
			for (sval = va_arg(ap, char *); *sval; sval++) Streams__putc(*sval, stream);
			break;
		case '%': Streams__putc('%', stream); break;
		case '$': Streams__putc('$', stream); break;
		default: {
			void *q = va_arg(ap, void *);
			int i = (int) category;
			if ((i<0) || (i > 255)) i = 0;
			writer_function f = the_escapes[i];
			if (f) {
				(*f)(stream, format_string, q);
				break;
			}
			fprintf(stderr, "*** Bad escape: <%s> ***\n", format_string);
			internal_error("Unknown % string escape in stream_printf");
		}
	}
	#pragma clang diagnostic pop

}
#line 684 "inlib/Chapter 2/Streams.w"
; break;
			case '$': 
{
#line 758 "inlib/Chapter 2/Streams.w"
	if ((stream->stream_flags) & USES_LOG_ESCAPES_STRF) {
		char category = *(++p);
		void *q = va_arg(ap, void *);
		int i = (int) category;
		if ((i<0) || (i > 255)) i = 0;
		log_function f = log_escapes[i];
		if (f) {
			(*f)(stream, q);
			break;
		}
		fprintf(stderr, "*** Bad log escape: <%c> ***\n", category);
		internal_error("Unknown $ string escape in log");
	} else Streams__putc('$', stream);

}
#line 685 "inlib/Chapter 2/Streams.w"
; break;
			default: Streams__putc(*p, stream); break;
		}
	}
	va_end(ap); /* macro to end variable argument processing */
}

#line 775 "inlib/Chapter 2/Streams.w"
void Streams__putc(int c_int, text_stream *stream) {
	unsigned int c;
	if (c_int >= 0) c = (unsigned int) c_int; else c = (unsigned int) (c_int + 256);
	if (stream == NULL) return;
	text_stream *first_stream = stream;
	if (c != '\n') 
{
#line 825 "inlib/Chapter 2/Streams.w"
	if (first_stream->stream_flags & INDENT_PENDING_STRF) {
		first_stream->stream_flags -= INDENT_PENDING_STRF;
		int L = (first_stream->stream_flags & INDENTATION_MASK_STRF)/INDENTATION_BASE_STRF;
		for (int i=0; i<L; i++) {
			Streams__putc(' ', first_stream); Streams__putc(' ', first_stream);
			Streams__putc(' ', first_stream); Streams__putc(' ', first_stream);
		}
	}

}
#line 780 "inlib/Chapter 2/Streams.w"
;
	if ((stream->stream_flags) & USES_XML_ESCAPES_STRF) {
		switch(c) {
			case NEWLINE_IN_STRING: Streams__literal(stream, "<br>"); return;
			case '&': Streams__literal(stream, "&amp;"); return;
			case '<': Streams__literal(stream, "&lt;"); return;
			case '>': Streams__literal(stream, "&gt;"); return;
		}
	}
	while (stream->stream_continues) stream = stream->stream_continues;
	
{
#line 852 "inlib/Chapter 2/Streams.w"
	if (stream->chars_written + SPACE_AT_END_OF_STREAM >= stream->chars_capacity) {
		if (stream->write_to_file) return; /* write nothing further */
		if (stream->write_to_memory) {
			int offset = (32 + 2*(stream->chars_capacity))*((int) sizeof(wchar_t));
			int needed = offset + ((int) sizeof(text_stream)) + 32;
			void *further_allocation = Memory__I7_malloc(needed, STREAM_MREASON);
			if (further_allocation == NULL) Errors__fatal("Out of memory");
			text_stream *continuation = (text_stream *) (further_allocation + offset);
			Streams__initialise(continuation);
			continuation->write_to_memory = further_allocation;
			continuation->chars_capacity = 2*stream->chars_capacity;
			(continuation->write_to_memory)[0] = 0;
			stream->stream_continues = continuation;
			stream = continuation;
		}
	}

}
#line 790 "inlib/Chapter 2/Streams.w"
;
	if (stream->write_to_file) {
		if (stream->stream_flags & FILE_ENCODING_UTF8_STRF)
			
{
#line 813 "inlib/Chapter 2/Streams.w"
	if (c >= 0x800) {
		fputc(0xE0 + (c >> 12), stream->write_to_file);
		fputc(0x80 + ((c >> 6) & 0x3f), stream->write_to_file);
		fputc(0x80 + (c & 0x3f), stream->write_to_file);
	} else if (c >= 0x80) {
		fputc(0xC0 + (c >> 6), stream->write_to_file);
		fputc(0x80 + (c & 0x3f), stream->write_to_file);
	} else fputc((int) c, stream->write_to_file);

}
#line 793 "inlib/Chapter 2/Streams.w"

		else if (stream->stream_flags & FILE_ENCODING_ISO_STRF) {
		 	if (c >= 0x100) c = '?';
			fputc((int) c, stream->write_to_file);
		} else internal_error("stream has unknown text encoding");
	} else if (stream->write_to_memory) {
		if ((c >= 0x0300) && (c <= 0x036F) && (stream->chars_written > 0)) {
			c = (unsigned int) Characters__combine_accent(
				(int) c, (stream->write_to_memory)[stream->chars_written - 1]);
			stream->chars_written--;
		}
		(stream->write_to_memory)[stream->chars_written] = (wchar_t) c;
	}
	if (c == '\n') first_stream->stream_flags |= INDENT_PENDING_STRF;
	stream->chars_written++;
}

#line 872 "inlib/Chapter 2/Streams.w"
void Streams__literal(text_stream *stream, char *p) {
	if (stream == NULL) return;
	int i, x = ((stream->stream_flags) & USES_XML_ESCAPES_STRF);
	if (x) stream->stream_flags -= USES_XML_ESCAPES_STRF;
	for (i=0; p[i]; i++) Streams__putc((int) p[i], stream);
	if (x) stream->stream_flags += USES_XML_ESCAPES_STRF;
}

#line 886 "inlib/Chapter 2/Streams.w"
void Streams__indent(text_stream *stream) {
	if (stream == NULL) return;
	stream->stream_flags += INDENTATION_BASE_STRF;
}

void Streams__outdent(text_stream *stream) {
	if (stream == NULL) return;
	if ((stream->stream_flags & INDENTATION_MASK_STRF) == 0) {
		if (Errors__have_occurred() == FALSE) internal_error("stream indentation negative");
		return;
	}
	stream->stream_flags -= INDENTATION_BASE_STRF;
}

void Streams__set_indentation(text_stream *stream, int N) {
	if (stream == NULL) return;
	int B = stream->stream_flags & INDENTATION_MASK_STRF;
	stream->stream_flags -= B;
	stream->stream_flags += N*INDENTATION_BASE_STRF;
}

#line 914 "inlib/Chapter 2/Streams.w"
int Streams__get_position(text_stream *stream) {
	int t = 0;
	while (stream) {
		t += stream->chars_written;
		stream = stream->stream_continues;
	}
	return t;
}

#line 928 "inlib/Chapter 2/Streams.w"
int Streams__latest(text_stream *stream) {
	if (stream == NULL) return 0;
	if (stream->write_to_file) internal_error("stream_latest on file stream");
	while ((stream->stream_continues) && (stream->stream_continues->chars_written > 0))
		stream = stream->stream_continues;
	if (stream->write_to_memory) {
		if (stream->chars_written > 0)
			return (int) ((stream->write_to_memory)[stream->chars_written - 1]);
	}
	return 0;
}

#line 944 "inlib/Chapter 2/Streams.w"
wchar_t Streams__get_char_at_index(text_stream *stream, int position) {
	if (stream == NULL) internal_error("examining null stream");
	if (stream->write_to_file) internal_error("examining file stream");
	while (position >= stream->chars_written) {
		position = position - stream->chars_written;
		stream = stream->stream_continues;
		if (stream == NULL) return 0;
	}
	return (stream->write_to_memory)[position];
}

void Streams__put_char_at_index(text_stream *stream, int position, wchar_t C) {
	if (stream == NULL) internal_error("modifying null stream");
	if (stream->write_to_file) internal_error("modifying file stream");
	while (position >= stream->chars_written) {
		position = position - stream->chars_written;
		stream = stream->stream_continues;
		if (stream == NULL) internal_error("overrun memory stream");
	}
	(stream->write_to_memory)[position] = C;
	if (C == 0) {
		stream->chars_written = position;
		if (stream->stream_continues) {
			Streams__close(stream->stream_continues);
			stream->stream_continues = NULL;
		}
	}
}

#line 980 "inlib/Chapter 2/Streams.w"
void Streams__set_position(text_stream *stream, int position) {
	if (stream == NULL) return;
	if (position < 0) position = 0; /* to simplify the implementation of backspacing */
	if (stream->write_to_file) internal_error("stream_set_position on file stream");
	if (stream->write_to_memory) {
		while (position > stream->chars_written) {
			position = position - stream->chars_written;
			stream = stream->stream_continues;
			if (stream == NULL) internal_error("can't set position forwards");
		}
		stream->chars_written = position;
		(stream->write_to_memory)[stream->chars_written] = 0;
		if (stream->stream_continues) {
			Streams__close(stream->stream_continues);
			stream->stream_continues = NULL;
		}
	}
}

#line 1003 "inlib/Chapter 2/Streams.w"
void Streams__copy(text_stream *to, text_stream *from) {
	if ((from == NULL) || (to == NULL)) return;
	if (from->write_to_file) internal_error("stream_copy from file stream");
	if (from->write_to_memory) {
		int i;
		for (i=0; i<from->chars_written; i++) {
			int c = (int) ((from->write_to_memory)[i]);
			Streams__putc(c, to);
		}
		if (from->stream_continues) Streams__copy(to, from->stream_continues);
	}
}

void Streams__write(OUTPUT_STREAM, char *format_string, void *vS) {
	text_stream *S = (text_stream *) vS;
	Streams__copy(OUT, S);
}

#line 16 "inlib/Chapter 2/String Manipulation.w"
text_stream *Str__new(void) {
	return Str__new_with_capacity(32);
}

text_stream *Str__new_with_capacity(int c) {
	text_stream *S = CREATE(text_stream);
	if (Streams__open_to_memory(S, c)) return S;
	return NULL;
}

#line 31 "inlib/Chapter 2/String Manipulation.w"
text_stream *Str__new_from_wide_string(wchar_t *C_string) {
	text_stream *S = CREATE(text_stream);
	if (Streams__open_from_wide_string(S, C_string)) return S;
	return NULL;
}

text_stream *Str__new_from_ISO_string(char *C_string) {
	text_stream *S = CREATE(text_stream);
	if (Streams__open_from_ISO_string(S, C_string)) return S;
	return NULL;
}

text_stream *Str__new_from_UTF8_string(char *C_string) {
	text_stream *S = CREATE(text_stream);
	if (Streams__open_from_UTF8_string(S, C_string)) return S;
	return NULL;
}

text_stream *Str__new_from_locale_string(char *C_string) {
	text_stream *S = CREATE(text_stream);
	if (Streams__open_from_locale_string(S, C_string)) return S;
	return NULL;
}

#line 60 "inlib/Chapter 2/String Manipulation.w"
text_stream *Str__duplicate(text_stream *E) {
	if (E == NULL) return Str__new();
	text_stream *S = CREATE(text_stream);
	if (Streams__open_to_memory(S, E->chars_capacity)) {
		Streams__copy(S, E);
		return S;
	}
	return NULL;
}

#line 73 "inlib/Chapter 2/String Manipulation.w"
text_stream *Str__from_wide_string(text_stream *S, wchar_t *c_string) {
	if (Streams__open_from_wide_string(S, c_string) == FALSE) return NULL;
	return S;
}

text_stream *Str__from_locale_string(text_stream *S, char *c_string) {
	if (Streams__open_from_locale_string(S, c_string) == FALSE) return NULL;
	return S;
}


#line 101 "inlib/Chapter 2/String Manipulation.w"
void Str__copy_to_ISO_string(char *C_string, text_stream *S, int buffer_size) {
	Streams__write_as_ISO_string(C_string, S, buffer_size);
}

void Str__copy_to_UTF8_string(char *C_string, text_stream *S, int buffer_size) {
	Streams__write_as_UTF8_string(C_string, S, buffer_size);
}

void Str__copy_to_wide_string(wchar_t *C_string, text_stream *S, int buffer_size) {
	Streams__write_as_wide_string(C_string, S, buffer_size);
}

void Str__copy_to_locale_string(char *C_string, text_stream *S, int buffer_size) {
	Streams__write_as_locale_string(C_string, S, buffer_size);
}

#line 120 "inlib/Chapter 2/String Manipulation.w"
int Str__atoi(text_stream *S, int index) {
	char buffer[32];
	int i = 0;
	for (string_position P = Str__at(S, index);
		((i < 31) && (P.index < Str__len(S))); P = Str__forward(P))
		buffer[i++] = (char) Str__get(P);
	buffer[i] = 0;
	return atoi(buffer);
}

#line 134 "inlib/Chapter 2/String Manipulation.w"
int Str__len(text_stream *S) {
	return Streams__get_position(S);
}

#line 151 "inlib/Chapter 2/String Manipulation.w"

#line 155 "inlib/Chapter 2/String Manipulation.w"
string_position Str__start(text_stream *S) {
	string_position P; P.S = S; P.index = 0; return P;
}

string_position Str__at(text_stream *S, int i) {
	if (i < 0) i = 0;
	if (i > Str__len(S)) i = Str__len(S);
	string_position P; P.S = S; P.index = i; return P;
}

string_position Str__end(text_stream *S) {
	string_position P; P.S = S; P.index = Str__len(S); return P;
}

#line 172 "inlib/Chapter 2/String Manipulation.w"
string_position Str__back(string_position P) {
	if (P.index > 0) P.index--; return P;
}

string_position Str__forward(string_position P) {
	P.index++; return P;
}

string_position Str__plus(string_position P, int increment) {
	P.index += increment; return P;
}

int Str__width_between(string_position P1, string_position P2) {
	if (P1.S != P2.S) internal_error("positions are in different strings");
	return P2.index - P1.index;
}

int Str__in_range(string_position P) {
	if (P.index < Str__len(P.S)) return TRUE;
	return FALSE;
}

int Str__index(string_position P) {
	return P.index;
}

#line 210 "inlib/Chapter 2/String Manipulation.w"
wchar_t Str__get(string_position P) {
	if ((P.S == NULL) || (P.index < 0) || (P.index > Str__len(P.S))) return 0;
	return Streams__get_char_at_index(P.S, P.index);
}

wchar_t Str__get_at(text_stream *S, int index) {
	return Str__get(Str__at(S, index));
}

wchar_t Str__get_first_char(text_stream *S) {
	return Str__get(Str__at(S, 0));
}

wchar_t Str__get_last_char(text_stream *S) {
	int L = Str__len(S);
	if (L == 0) return 0;
	return Str__get(Str__at(S, L-1));
}

void Str__put(string_position P, wchar_t C) {
	if (P.index < 0) internal_error("wrote before start of string");
	if (P.S == NULL) internal_error("wrote to null stream");
	int ext = Str__len(P.S);
	if (P.index > ext) internal_error("wrote beyond end of string");
	if (P.index == ext) {
		if (C) PUT_TO(P.S, (int) C);
		return;
	}
	Streams__put_char_at_index(P.S, P.index, C);
}

void Str__put_at(text_stream *S, int index, wchar_t C) {
	Str__put(Str__at(S, index), C);
}

#line 248 "inlib/Chapter 2/String Manipulation.w"
void Str__clear(text_stream *S) {
	Str__truncate(S, 0);
}

void Str__truncate(text_stream *S, int len) {
	if (len < 0) len = 0;
	if (len < Str__len(S)) Str__put(Str__at(S, len), 0);
}

void Str__concatenate(text_stream *S1, text_stream *S2) {
	Streams__copy(S1, S2);
}

void Str__copy(text_stream *S1, text_stream *S2) {
	Str__clear(S1);
	Streams__copy(S1, S2);
}

void Str__copy_tail(text_stream *S1, text_stream *S2, int from) {
	Str__clear(S1);
	int L = Str__len(S2);
	if (from < L)
		for (string_position P = Str__at(S2, from); P.index < L; P = Str__forward(P))
			PUT_TO(S1, Str__get(P));
}

#line 277 "inlib/Chapter 2/String Manipulation.w"
void Str__set_to_wide_string(text_stream *S, wchar_t *text) {
	Str__clear(S); WRITE_TO(S, "%w", text);
}

void Str__set_to_ISO_string(text_stream *S, char *text) {
	Str__clear(S); WRITE_TO(S, "%s", text);
}

#line 288 "inlib/Chapter 2/String Manipulation.w"
int Str__eq(text_stream *S1, text_stream *S2) {
	if ((Str__len(S1) == Str__len(S2)) && (Str__cmp(S1, S2) == 0)) return TRUE;
	return FALSE;
}

int Str__eq_insensitive(text_stream *S1, text_stream *S2) {
	if ((Str__len(S1) == Str__len(S2)) && (Str__cmp_insensitive(S1, S2) == 0)) return TRUE;
	return FALSE;
}

int Str__ne(text_stream *S1, text_stream *S2) {
	if ((Str__len(S1) != Str__len(S2)) || (Str__cmp(S1, S2) != 0)) return TRUE;
	return FALSE;
}

int Str__ne_insensitive(text_stream *S1, text_stream *S2) {
	if ((Str__len(S1) != Str__len(S2)) || (Str__cmp_insensitive(S1, S2) != 0)) return TRUE;
	return FALSE;
}

int Str__cmp(text_stream *S1, text_stream *S2) {
	for (string_position P = Str__start(S1), Q = Str__start(S2);
		(P.index < Str__len(S1)) && (Q.index < Str__len(S2));
		P = Str__forward(P), Q = Str__forward(Q)) {
		int d = (int) Str__get(P) - (int) Str__get(Q);
		if (d != 0) return d;
	}
	return Str__len(S1) - Str__len(S2);
}

int Str__cmp_insensitive(text_stream *S1, text_stream *S2) {
	for (string_position P = Str__start(S1), Q = Str__start(S2);
		(P.index < Str__len(S1)) && (Q.index < Str__len(S2));
		P = Str__forward(P), Q = Str__forward(Q)) {
		int d = tolower((int) Str__get(P)) - tolower((int) Str__get(Q));
		if (d != 0) return d;
	}
	return Str__len(S1) - Str__len(S2);
}

#line 331 "inlib/Chapter 2/String Manipulation.w"
void Str__copy_ISO_string(text_stream *S, char *C_string) {
	Str__clear(S);
	Streams__write_ISO_string(S, C_string);
}

void Str__copy_UTF8_string(text_stream *S, char *C_string) {
	Str__clear(S);
	Streams__write_UTF8_string(S, C_string);
}

void Str__copy_wide_string(text_stream *S, wchar_t *C_string) {
	Str__clear(S);
	Streams__write_wide_string(S, C_string);
}

int Str__eq_C_string(text_stream *S1, wchar_t *S2) {
	if (Str__len(S1) == (int) wcslen(S2)) {
		int i=0;
		LOOP_THROUGH_TEXT(P, S1)
			if (Str__get(P) != S2[i++])
				return FALSE;
		return TRUE;
	}
	return FALSE;
}

#line 360 "inlib/Chapter 2/String Manipulation.w"
void Str__trim_white_space(text_stream *S) {
	int len = Str__len(S), i = 0, j = 0;
	string_position F = Str__start(S);
	LOOP_THROUGH_TEXT(P, S) {
		if (!(Characters__is_space_or_tab(Str__get(P)))) { F = P; break; }
		i++;
	}
	LOOP_BACKWARDS_THROUGH_TEXT(Q, S) {
		if (!(Characters__is_space_or_tab(Str__get(Q)))) break;
		j++;
	}
	if (i+j > Str__len(S)) Str__truncate(S, 0);
	else {
		len = len - j;
		Str__truncate(S, len);
		if (i > 0) {
			string_position P = Str__start(S);
			wchar_t c = 0;
			do {
				c = Str__get(F);
				Str__put(P, c);
				P = Str__forward(P); F = Str__forward(F);
			} while (c != 0);
			len = len - i;
			Str__truncate(S, len);
		}
	}
}

#line 392 "inlib/Chapter 2/String Manipulation.w"
void Str__delete_first_character(text_stream *S) {
	LOOP_THROUGH_TEXT(P, S)
		Str__put(P, Str__get(Str__forward(P)));
}

#line 400 "inlib/Chapter 2/String Manipulation.w"
void Str__substr(OUTPUT_STREAM, string_position from, string_position to) {
	if (from.S != to.S) internal_error("substr on two different strings");
	for (int i = from.index; i < to.index; i++)
		PUT(Str__get_at(from.S, i));
}

int Str__begins_with_C_string(text_stream *S, wchar_t *prefix) {
	if ((prefix == NULL) || (*prefix == 0)) return TRUE;
	if (S == NULL) return FALSE;
	for (int i = 0; prefix[i]; i++)
		if (Str__get_at(S, i) != prefix[i])
			return FALSE;
	return TRUE;
}

#line 11 "inlib/Chapter 2/Error Messages.w"
int (*errors_handler)(text_stream *, int) = NULL;

void Errors__set_handler(int (*f)(text_stream *, int)) {
	errors_handler = f;
}

int problem_count = 0;
int Errors__have_occurred(void) {
	if (problem_count > 0) return TRUE;
	return FALSE;
}

void Errors__issue(text_stream *message, int fatality) {
	int rv = TRUE;
	if (errors_handler) rv = (*errors_handler)(message, fatality);
	if (rv) WRITE_TO(STDERR, "%S", message);
	if (fatality) Errors__die(); else problem_count++;
}

#line 38 "inlib/Chapter 2/Error Messages.w"
void Errors__fatal(char *message) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: fatal error: %s\n", INTOOL_NAME, message);
	Errors__issue(ERM, TRUE);
	DISCARD_TEXT(ERM)
}

void Errors__fatal_with_C_string(char *message, char *parameter) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: fatal error: ", INTOOL_NAME);
	WRITE_TO(ERM, message, parameter);
	WRITE_TO(ERM, "\n");
	Errors__issue(ERM, TRUE);
	DISCARD_TEXT(ERM)
}

void Errors__fatal_with_text(char *message, text_stream *parameter) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: fatal error: ", INTOOL_NAME);
	WRITE_TO(ERM, message, parameter);
	WRITE_TO(ERM, "\n");
	Errors__issue(ERM, TRUE);
	DISCARD_TEXT(ERM)
}

void Errors__fatal_with_file(char *message, filename *F) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: fatal error: %s: %f\n", INTOOL_NAME, message, F);
	Errors__issue(ERM, TRUE);
	DISCARD_TEXT(ERM)
}

void Errors__fatal_with_path(char *message, pathname *P) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: fatal error: %s: %f\n", INTOOL_NAME, message, P);
	Errors__issue(ERM, TRUE);
	DISCARD_TEXT(ERM)
}

#line 87 "inlib/Chapter 2/Error Messages.w"
int debugger_mode = FALSE;
void Errors__enter_debugger_mode(void) {
	debugger_mode = TRUE;
	printf("(Debugger mode enabled: will crash on fatal errors)\n");
}

void Errors__die(void) { /* as void as it gets */
	if (DL) STREAM_FLUSH(DL);
	if (debugger_mode) {
		WRITE_TO(STDERR, "(crashing intentionally to allow backtrace)\n");
		int to_deliberately_crash = 0;
		printf("%d", 1/to_deliberately_crash);
	}
	/* on a fatal exit, memory isn't freed, because that causes threading problems */
	exit(2);
}

#line 109 "inlib/Chapter 2/Error Messages.w"
void Errors__nowhere(char *message) {
	Errors__in_text_file(message, NULL);
}

void Errors__in_text_file(char *message, text_file_position *here) {
	if (here)
		Errors__at_position(message, here->text_file_filename, here->line_count);
	else
		Errors__at_position(message, NULL, 0);
}

#line 123 "inlib/Chapter 2/Error Messages.w"
void Errors__with_file(char *message, filename *F) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: %f: %s\n", INTOOL_NAME, F, message);
	Errors__issue(ERM, FALSE);
	DISCARD_TEXT(ERM)
}

void Errors__at_position(char *message, filename *file, int line) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: ", INTOOL_NAME);
	if (file) WRITE_TO(ERM, "%f, line %d: ", file, line);
	WRITE_TO(ERM, "%s\n", message);
	Errors__issue(ERM, FALSE);
	DISCARD_TEXT(ERM)
}

#line 21 "inlib/Chapter 2/Command Line Arguments.w"

#line 25 "inlib/Chapter 2/Command Line Arguments.w"
void CommandLine__declare_switch(int id, wchar_t *name_literal, int val) {
	command_line_switch *cls = CREATE(command_line_switch);
	cls->switch_name = Str__new_from_wide_string(name_literal);
	cls->switch_id = id;
	cls->valency = val;
}

#line 35 "inlib/Chapter 2/Command Line Arguments.w"
void CommandLine__read(int argc, char **argv, void *state, void (*f)(int, text_stream *, void *)) {
	for (int i=1; i<argc; i++) {
		int switched = FALSE;
		char *p = argv[i];
		while (p[0] == '-') { p++; switched = TRUE; } /* allow a doubled-dash as a single */
		STRING(opt);
		Streams__write_locale_string(opt, p);
		if (switched) 
{
#line 50 "inlib/Chapter 2/Command Line Arguments.w"
	int found = FALSE;
	command_line_switch *cls;
	LOOP_OVER(cls, command_line_switch)
		if (Str__eq(opt, cls->switch_name)) {
			STRING(arg);
			if (cls->valency > 1) {
				if (i+1 == argc) Errors__fatal_with_text("no argument for: -%S", opt);
				Streams__write_locale_string(arg, argv[++i]);
			}
			switch (cls->switch_id) {
				case CRASH_CLSW: Errors__enter_debugger_mode(); break;
				case LOG_CLSW: 
{
#line 78 "inlib/Chapter 2/Command Line Arguments.w"
	if (Log__get_debug_log_filename() == NULL) {
		filename *F = Filenames__in_folder(Pathnames__from_string(INTOOL_NAME),
			"debug-log.txt");
		Log__set_debug_log_filename(F);
	}
	Log__open();
	Log__set_aspect_from_command_line(arg);

}
#line 61 "inlib/Chapter 2/Command Line Arguments.w"
; break;
				case PLATFORM_CLSW: 
{
#line 89 "inlib/Chapter 2/Command Line Arguments.w"
	/* ignore for now */

}
#line 62 "inlib/Chapter 2/Command Line Arguments.w"
; break;
				default:
					if (f) {
						if (cls->valency == 1) (*f)(cls->switch_id, NULL, state);
						else (*f)(cls->switch_id, arg, state);
					}
					break;
			}
			found = TRUE;
		}
	if (found == FALSE)
		Errors__fatal_with_text("unknown command line switch: -%S", opt);

}
#line 42 "inlib/Chapter 2/Command Line Arguments.w"

		else Errors__fatal_with_text("unknown command line argument: %S", opt);
	}
}

#line 18 "inlib/Chapter 3/Filenames.w"

#line 23 "inlib/Chapter 3/Filenames.w"
filename *Filenames__in_folder(pathname *P, char *file_name) {
	return Filenames__primitive(file_name, NULL, 0, CStrings__strlen_unbounded(file_name), P);
}

filename *Filenames__in_folder_S(pathname *P, text_stream *file_name) {
	return Filenames__primitive(NULL, file_name, 0, Str__len(file_name), P);
}

filename *Filenames__primitive(char *c_string, text_stream *S, int from, int to, pathname *P) {
	filename *F = CREATE(filename);
	F->pathname_of_location = P;
	if (to-from > MAX_FILENAME_LENGTH-1)
		Errors__fatal_with_C_string("a filename grew too long: %s", c_string);
	if (to-from <= 0)
		internal_error("empty intermediate pathname");
	F->leafname = Str__new_with_capacity(to-from+1);
	if (c_string) {
		for (int i = from; i < to; i++) PUT_TO(F->leafname, c_string[i]);
	} else {
		string_position pos = Str__at(S, from);
		for (int i = from; i < to; i++, pos = Str__forward(pos))
			PUT_TO(F->leafname, Str__get(pos));
	}
	return F;
}

#line 53 "inlib/Chapter 3/Filenames.w"
filename *Filenames__from_string(char *path) {
	int i = 0, pos = -1;
	for (; path[i]; i++)
		if (path[i] == FOLDER_SEPARATOR)
			pos = i;
	pathname *at = NULL;
	if (pos > 0) at = Pathnames__primitive(path, NULL, 0, pos, NULL);
	if (pos+1 < i) return Filenames__in_folder(at, path+pos+1);
	internal_error("empty leafname");
	return NULL;
}

filename *Filenames__from_stream(text_stream *path) {
	int i = 0, pos = -1;
	LOOP_THROUGH_TEXT(at, path) {
		if (Str__get(at) == FOLDER_SEPARATOR) pos = i;
		i++;
	}
	pathname *P = NULL;
	if (pos > 0) P = Pathnames__primitive(NULL, path, 0, pos, NULL);
	return Filenames__primitive(NULL, path, pos+1, Str__len(path), P);
}

#line 91 "inlib/Chapter 3/Filenames.w"
filename *Filenames__from_command_line_argument(char *arg) {
	TEMPORARY_TEXT(ARG);
	Streams__open_from_locale_string(ARG, arg);
	LOOP_THROUGH_TEXT(at, ARG)
		if (Str__get(at) == '/')
			Str__put(at, FOLDER_SEPARATOR);
	filename *F = Filenames__from_stream(ARG);
	DISCARD_TEXT(ARG);
	return F;
}

#line 106 "inlib/Chapter 3/Filenames.w"
void Filenames__to_string(char *to, filename *F) {
	to[0] = 0;
	Pathnames__to_string(to, F->pathname_of_location);
	int pos = CStrings__strlen_unbounded(to);
	if (pos + 1 + Str__len(F->leafname) + 1 > MAX_FILENAME_LENGTH)
		Errors__fatal_with_C_string("a filename grew too long: %s", to);
	to[pos] = FOLDER_SEPARATOR;
	Str__copy_to_ISO_string(to+pos+1, F->leafname, MAX_FILENAME_LENGTH);
}

void Filenames__to_string_Unixised(char *to, filename *F) {
	to[0] = 0;
	Pathnames__to_string(to, F->pathname_of_location);
	int pos = CStrings__strlen_unbounded(to);
	if (pos + 1 + Str__len(F->leafname) + 1 > MAX_FILENAME_LENGTH)
		Errors__fatal_with_C_string("a filename grew too long: %s", to);
	to[pos] = '/';
	Str__copy_to_ISO_string(to+pos+1, F->leafname, MAX_FILENAME_LENGTH);
}

void Filenames__print_string(char *label, filename *F) {
	char written_out[MAX_FILENAME_LENGTH];
	Filenames__to_string(written_out, F);
	printf("%s: %s\n", label, written_out);
}

#line 135 "inlib/Chapter 3/Filenames.w"
void Filenames__to_string_relative(char *to, filename *F, pathname *P) {
	char ft[MAX_FILENAME_LENGTH], pt[MAX_FILENAME_LENGTH];
	Filenames__to_string(ft, F);
	Pathnames__to_string(pt, P);
	int n = CStrings__strlen_unbounded(pt);
	if ((strncmp(ft, pt, (size_t) n)==0) && (ft[n]==FOLDER_SEPARATOR))
		strcpy(to, ft+n+1);
	else internal_error("filename not relative to pathname");
}

#line 148 "inlib/Chapter 3/Filenames.w"
void Filenames__write(OUTPUT_STREAM, char *format_string, void *vF) {
	filename *F = (filename *) vF;
	if (F == NULL) WRITE("<no file>");
	else {
		char fn[MAX_FILENAME_LENGTH];
		if (format_string[1] == '/') Filenames__to_string_Unixised(fn, F);
		else Filenames__to_string(fn, F);
		for (int j = 0; fn[j]; j++) PUT(fn[j]);
	}
}

#line 162 "inlib/Chapter 3/Filenames.w"
pathname *Filenames__get_path_to(filename *F) {
	if (F == NULL) return NULL;
	return F->pathname_of_location;
}

#line 170 "inlib/Chapter 3/Filenames.w"
filename *Filenames__without_path(filename *F) {
	return Filenames__in_folder_S(NULL, F->leafname);
}

text_stream *Filenames__get_leafname(filename *F) {
	if (F == NULL) return NULL;
	return F->leafname;
}

void Filenames__write_unextended_leafname(OUTPUT_STREAM, filename *F) {
	LOOP_THROUGH_TEXT(pos, F->leafname) {
		wchar_t c = Str__get(pos);
		if (c == '.') return;
		PUT(c);
	}
}

#line 195 "inlib/Chapter 3/Filenames.w"
void Filenames__write_extension(OUTPUT_STREAM, filename *F) {
	int on = FALSE;
	LOOP_THROUGH_TEXT(pos, F->leafname) {
		wchar_t c = Str__get(pos);
		if (c == '.') on = TRUE;
		if (on) PUT(c);
	}
}

filename *Filenames__set_extension(filename *F, char *extension) {
	TEMPORARY_TEXT(NEWLEAF);
	LOOP_THROUGH_TEXT(pos, F->leafname) {
		wchar_t c = Str__get(pos);
		if (c == '.') break;
		PUT_TO(NEWLEAF, c);
	}
	if ((extension) && (extension[0])) WRITE_TO(NEWLEAF, ".%s", extension);
	filename *N = Filenames__in_folder_S(F->pathname_of_location, NEWLEAF);
	DISCARD_TEXT(NEWLEAF);
	return N;
}

#line 234 "inlib/Chapter 3/Filenames.w"
int Filenames__guess_format(filename *F) {
	TEMPORARY_TEXT(EXT);
	Filenames__write_extension(EXT, F);

	TEMPORARY_TEXT(NORMALISED);
	LOOP_THROUGH_TEXT(pos, EXT) {
		wchar_t c = Str__get(pos);
		if (c != ' ') PUT_TO(NORMALISED, Characters__w_tolower(c));
	}
	DISCARD_TEXT(EXT);

	int verdict = FORMAT_UNRECOGNISED;
	if (Str__eq_C_string(NORMALISED, L".html")) verdict = FORMAT_PERHAPS_HTML;
	else if (Str__eq_C_string(NORMALISED, L".htm")) verdict = FORMAT_PERHAPS_HTML;
	else if (Str__eq_C_string(NORMALISED, L".jpg")) verdict = FORMAT_PERHAPS_JPEG;
	else if (Str__eq_C_string(NORMALISED, L".jpeg")) verdict = FORMAT_PERHAPS_JPEG;
	else if (Str__eq_C_string(NORMALISED, L".png")) verdict = FORMAT_PERHAPS_PNG;
	else if (Str__eq_C_string(NORMALISED, L".ogg")) verdict = FORMAT_PERHAPS_OGG;
	else if (Str__eq_C_string(NORMALISED, L".aiff")) verdict = FORMAT_PERHAPS_AIFF;
	else if (Str__eq_C_string(NORMALISED, L".aif")) verdict = FORMAT_PERHAPS_AIFF;
	else if (Str__eq_C_string(NORMALISED, L".midi")) verdict = FORMAT_PERHAPS_MIDI;
	else if (Str__eq_C_string(NORMALISED, L".mid")) verdict = FORMAT_PERHAPS_MIDI;
	else if (Str__eq_C_string(NORMALISED, L".mod")) verdict = FORMAT_PERHAPS_MOD;
	else if (Str__eq_C_string(NORMALISED, L".svg")) verdict = FORMAT_PERHAPS_SVG;
	else if (Str__eq_C_string(NORMALISED, L".gif")) verdict = FORMAT_PERHAPS_GIF;
	else if (Str__len(NORMALISED) > 0) {
		if ((Str__get(Str__at(NORMALISED, 0)) == 'z') &&
			(Characters__w_isdigit(Str__get(Str__at(NORMALISED, 1)))) &&
			(Str__len(NORMALISED) == 2))
			verdict = FORMAT_PERHAPS_ZCODE;
		else if (Str__get(Str__back(Str__end(NORMALISED))) == 'x')
			verdict = FORMAT_PERHAPS_GLULX;
	}
	DISCARD_TEXT(NORMALISED);
	return verdict;
}

#line 44 "inlib/Chapter 3/Pathnames.w"

#line 49 "inlib/Chapter 3/Pathnames.w"
pathname *home_path = NULL;

#line 55 "inlib/Chapter 3/Pathnames.w"
pathname *Pathnames__subfolder(pathname *P, char *folder_name) {
	return Pathnames__primitive(folder_name, NULL, 0, CStrings__strlen_unbounded(folder_name), P);
}

pathname *Pathnames__primitive(char *c_string, text_stream *str, int from, int to, pathname *par) {
	pathname *P = CREATE(pathname);
	P->pathname_of_parent = par;
	P->known_to_exist = FALSE;
	if (to-from <= 0) internal_error("empty intermediate pathname");
	P->intermediate = Str__new_with_capacity(to-from+1);
	if (c_string) {
		if (to-from > MAX_FILENAME_LENGTH-1)
			Errors__fatal_with_C_string("a filename grew too long: %s", c_string);
		for (int i = from; i < to; i++) PUT_TO(P->intermediate, c_string[i]);
	} else if (str) {
		for (int i = from; i < to; i++) PUT_TO(P->intermediate, Str__get(Str__at(str, i)));
	}
	return P;
}

#line 83 "inlib/Chapter 3/Pathnames.w"
pathname *Pathnames__from_string(char *path) {
	return Pathnames__from_string_relative(NULL, path);
}

pathname *Pathnames__from_string_relative(pathname *P, char *path) {
	pathname *at = P;
	int i = 0, pos = 0;
	if ((path[0]) && (P == NULL)) i++;
	for (; path[i]; i++)
		if (path[i] == FOLDER_SEPARATOR) {
			if (i > pos) at = Pathnames__primitive(path, NULL, pos, i, at);
			pos = i+1;
		}
	if (i > pos) at = Pathnames__primitive(path, NULL, pos, i, at);
	return at;
}

pathname *Pathnames__from_stream(text_stream *path) {
	return Pathnames__from_stream_relative(NULL, path);
}

pathname *Pathnames__from_stream_relative(pathname *P, text_stream *path) {
	pathname *at = P;
	int i = 0, pos = 0;
	if ((Str__get(Str__start(path))) && (P == NULL)) i++;
	for (; i < Str__len(path); i++)
		if (Str__get(Str__at(path, i)) == FOLDER_SEPARATOR) {
			if (i > pos) at = Pathnames__primitive(NULL, path, pos, i, at);
			pos = i+1;
		}
	if (i > pos) at = Pathnames__primitive(NULL, path, pos, i, at);
	return at;
}

#line 123 "inlib/Chapter 3/Pathnames.w"
pathname *Pathnames__from_command_line_argument(char *arg) {
	TEMPORARY_TEXT(ARG);
	Streams__open_from_locale_string(ARG, arg);
	LOOP_THROUGH_TEXT(at, ARG)
		if (Str__get(at) == '/')
			Str__put(at, FOLDER_SEPARATOR);
	pathname *P = Pathnames__from_stream(ARG);
	DISCARD_TEXT(ARG);
	return P;
}

#line 138 "inlib/Chapter 3/Pathnames.w"
void Pathnames__to_string(char *to, pathname *P) {
	Pathnames__to_string_inner(to, P, FOLDER_SEPARATOR);
}

void Pathnames__to_string_Unixised(char *to, pathname *P) {
	Pathnames__to_string_inner(to, P, '/');
}

void Pathnames__to_string_inner(char *to, pathname *P, char divider) {
	to[0] = 0;
	if (P) Pathnames__to_string_r(to, P, MAX_FILENAME_LENGTH-1, divider);
	else { to[0] = '.'; to[1] = divider; to[2] = 0; }
}

int Pathnames__to_string_r(char *to, pathname *P, int room_left, char divider) {
	if (P->pathname_of_parent)
		room_left = Pathnames__to_string_r(to, P->pathname_of_parent, room_left, divider);
	room_left = room_left - 1 - Str__len(P->intermediate);
	if (room_left < 0)
		Errors__fatal_with_C_string("a filename grew too long: %s", to);
	int pos = CStrings__strlen_unbounded(to);
	if (pos > 0) to[pos++] = divider;
	Str__copy_to_locale_string(to+pos, P->intermediate, room_left);
	return room_left;
}

#line 167 "inlib/Chapter 3/Pathnames.w"
void Pathnames__write(OUTPUT_STREAM, char *format_string, void *vP) {
	pathname *P = (pathname *) vP;
	char pn[MAX_FILENAME_LENGTH];
	if (format_string[1] == '/') Pathnames__to_string_Unixised(pn, P);
	else Pathnames__to_string(pn, P);
	for (int j = 0; pn[j]; j++) PUT(pn[j]);
}

#line 190 "inlib/Chapter 3/Pathnames.w"
void Pathnames__to_string_relative(char *to, pathname *P, pathname *R) {
	char rt[MAX_FILENAME_LENGTH], pt[MAX_FILENAME_LENGTH];
	Pathnames__to_string(rt, R);
	Pathnames__to_string(pt, P);
	int n = CStrings__strlen_unbounded(rt);
	if ((strncmp(pt, rt, (size_t) n)==0) && (pt[n]==FOLDER_SEPARATOR))
		strcpy(to, pt+n+1);
	else internal_error("pathname not relative to pathname");
}

#line 203 "inlib/Chapter 3/Pathnames.w"
pathname *Pathnames__modify_with_number(pathname *P, char *template, int val) {
	char modified[MAX_FILENAME_LENGTH];
	Str__copy_to_ISO_string(modified, P->intermediate, MAX_FILENAME_LENGTH - 32);
	CSTRING_WRITE(modified + CStrings__len(modified), template, val);
	return Pathnames__subfolder(P->pathname_of_parent, modified);
}

#line 215 "inlib/Chapter 3/Pathnames.w"
void Pathnames__start(void) {
	char *home = (char *) (getenv("HOME"));
	if (home) {
		home_path = Pathnames__from_string(home);
		home_path->known_to_exist = TRUE;
	}
}

#line 228 "inlib/Chapter 3/Pathnames.w"
int Pathnames__create_in_file_system(pathname *P) {
	if (P == NULL) return TRUE; /* the root of the file system always exists */
	if (P->known_to_exist) return TRUE;
	char path[MAX_FILENAME_LENGTH];
	Pathnames__to_string(path, P);
	P->known_to_exist = Platform__mkdir(path);
	return P->known_to_exist;
}

#line 252 "inlib/Chapter 3/Pathnames.w"
int Pathnames__write_contents_to_file(filename *writeto, pathname *P) {
	char path[MAX_FILENAME_LENGTH];
	Pathnames__to_string(path, P);
	char transcoded_pathname[2*MAX_FILENAME_LENGTH];
	Platform__transcode_ISO_string_to_locale(path, transcoded_pathname);

	text_stream CONTS_struct; text_stream *CONTS = &CONTS_struct;
	void *FOLDER = Platform__opendir(transcoded_pathname);
	char leaf[MAX_FILENAME_LENGTH+1];
	if (FOLDER == NULL) return FALSE;
	if (STREAM_OPEN_TO_FILE(CONTS, writeto, ISO_ENC) == FALSE) return FALSE;
	while (Platform__readdir(FOLDER, transcoded_pathname, leaf)) {
		if (leaf[0] == '.') continue;
		WRITE_TO(CONTS, "%s\n", leaf);
	}
	STREAM_CLOSE(CONTS);
	Platform__closedir(FOLDER);
	return TRUE;
}

#line 275 "inlib/Chapter 3/Pathnames.w"
int Pathnames__write_contents_to_stream(OUTPUT_STREAM, pathname *P) {
	char path[MAX_FILENAME_LENGTH];
	Pathnames__to_string(path, P);
	void *FOLDER = Platform__opendir(path);
	if (FOLDER == NULL) return FALSE;
	char leaf[MAX_FILENAME_LENGTH+1];
	while (Platform__readdir(FOLDER, path, leaf)) {
		if (leaf[0] == '.') continue;
		WRITE("%s\n", leaf);
	}
	Platform__closedir(FOLDER);
	return TRUE;
}

#line 45 "inlib/Chapter 3/Case-Insensitive Filenames.w"
#ifdef POSIX_DIRECTORY_HANDLING

#line 54 "inlib/Chapter 3/Case-Insensitive Filenames.w"
FILE *CIFilingSystem__fopen(const char *path, const char *mode) {
	char *topdirpath = NULL, *ciextdirpath = NULL, *cistring = NULL, *ciextname = NULL;
	char *workstring = NULL, *workstring2 = NULL;
	DIR *topdir = NULL, *extdir = NULL; FILE *handle;
	size_t length;

	/* for efficiency's sake, though it's logically equivalent, we try... */
	handle = fopen(path, mode); if (handle) 
{
#line 141 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 141 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return handle;

}
#line 61 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;

	
{
#line 165 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	length = 0;
	if (path) length = (size_t) CStrings__strlen_unbounded(path);
	if (length < 1) { errno = ENOENT; return NULL; }

}
#line 63 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	
{
#line 125 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	workstring = calloc(length+1, sizeof(char));
	if (workstring == NULL) { errno = ENOMEM; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 126 "inlib/Chapter 3/Case-Insensitive Filenames.w"
; }
	workstring2 = calloc(length+1, sizeof(char));
	if (workstring2 == NULL) { errno = ENOMEM; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 128 "inlib/Chapter 3/Case-Insensitive Filenames.w"
; }
	topdirpath = calloc(length+1, sizeof(char));
	if (topdirpath == NULL) { errno = ENOMEM; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 130 "inlib/Chapter 3/Case-Insensitive Filenames.w"
; }
	ciextdirpath = calloc(length+1, sizeof(char));
	if (ciextdirpath == NULL) { errno = ENOMEM; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 132 "inlib/Chapter 3/Case-Insensitive Filenames.w"
; }
	cistring = calloc(length+1, sizeof(char));
	if (cistring == NULL) { errno = ENOMEM; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 134 "inlib/Chapter 3/Case-Insensitive Filenames.w"
; }
	ciextname = calloc(length+1, sizeof(char));
	if (ciextname == NULL) { errno = ENOMEM; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 136 "inlib/Chapter 3/Case-Insensitive Filenames.w"
; }

}
#line 64 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	
{
#line 182 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	char *p;
	size_t extdirindex, extindex, namelen, dirlen;

	p = strrchr(path, FOLDER_SEPARATOR);
	extindex = (size_t) (p - path);
	namelen = length - extindex - 1;
	strncpy(ciextname, path + extindex + 1, namelen);
	ciextname[namelen] = 0;

	strncpy(workstring, path, (extindex-1));
	workstring[extindex-1] = 0;
	p = strrchr(workstring, FOLDER_SEPARATOR);
	extdirindex = (size_t) (p - workstring);
	strncpy(topdirpath, path, extdirindex);
	topdirpath[extdirindex] = 0;

	dirlen = extindex - extdirindex - 1;
	strncpy(ciextdirpath, path + extdirindex + 1, dirlen);
	ciextdirpath[dirlen] = 0;

}
#line 65 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;

	topdir = opendir(topdirpath); /* whose pathname is assumed case-correct... */
	if (topdir == NULL) 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 68 "inlib/Chapter 3/Case-Insensitive Filenames.w"
; /* ...so that failure is fatal; |errno| is set by |opendir| */

	sprintf(workstring, "%s%c%s", topdirpath, FOLDER_SEPARATOR, ciextdirpath);
	extdir = opendir(workstring); /* try with supplied extension directory name */
	if (extdir == NULL) 
{
#line 87 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	int rc = CIFilingSystem__match_in_directory(topdir, ciextdirpath, workstring);
	switch (rc) {
		case 0:
			errno = ENOENT; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 90 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
		case 1:
			sprintf(cistring, "%s%c%s", topdirpath, FOLDER_SEPARATOR, workstring);
			extdir = opendir(cistring);
			if (extdir == NULL) {
				errno = ENOENT; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 95 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
			}
			break;
		default:
			errno = EBADF; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 99 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	}

}
#line 72 "inlib/Chapter 3/Case-Insensitive Filenames.w"

	else strcpy(cistring, workstring);

	sprintf(workstring, "%s%c%s", cistring, FOLDER_SEPARATOR, ciextname);
	handle = fopen(workstring, mode); /* try with supplied name */
	if (handle) 
{
#line 141 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 141 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return handle;

}
#line 77 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;

	
{
#line 106 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	int rc = CIFilingSystem__match_in_directory(extdir, ciextname, workstring);

	switch (rc) {
		case 0:
			errno = ENOENT; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 110 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
		case 1:
			sprintf(workstring2, "%s%c%s", cistring, FOLDER_SEPARATOR, workstring);
			workstring2[length] = 0;
			handle = fopen(workstring2, mode);
			if (handle) 
{
#line 141 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 141 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return handle;

}
#line 115 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
			errno = ENOENT; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 116 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
		default:
			errno = EBADF; 
{
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 153 "inlib/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 147 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 118 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
	}

}
#line 79 "inlib/Chapter 3/Case-Insensitive Filenames.w"
;
}

#line 213 "inlib/Chapter 3/Case-Insensitive Filenames.w"
int CIFilingSystem__match_in_directory(void *vd,
	char *name, char *last_match) {
	DIR *d = (DIR *) vd;
	struct dirent *dirp;
	int rc = 0;

	last_match[0] = 0;
	while ((dirp = readdir(d)) != NULL) {
		if (strcasecmp(name, dirp->d_name) == 0) {
			rc++;
			strcpy(last_match, dirp->d_name);
		}
	}
	return rc;
}

#line 233 "inlib/Chapter 3/Case-Insensitive Filenames.w"
#else
FILE *CIFilingSystem__fopen(const char *path, const char *mode) {
	return fopen(path, mode);
}
#endif

#line 14 "inlib/Chapter 3/Shell.w"
void Shell__quote_path(OUTPUT_STREAM, pathname *P) {
	TEMPORARY_TEXT(FN);
	WRITE_TO(FN, "%p", P);
	Shell__quote_text(OUT, FN);
	DISCARD_TEXT(FN);
}

void Shell__quote_file(OUTPUT_STREAM, filename *F) {
	TEMPORARY_TEXT(FN);
	WRITE_TO(FN, "%f", F);
	Shell__quote_text(OUT, FN);
	DISCARD_TEXT(FN);
}

void Shell__plain(OUTPUT_STREAM, char *raw) {
	WRITE("%s", raw);
}

void Shell__plain_text(OUTPUT_STREAM, text_stream *raw) {
	WRITE("%S", raw);
}

void Shell__quote_text(OUTPUT_STREAM, text_stream *raw) {
	PUT(SHELL_QUOTE_CHARACTER);
	LOOP_THROUGH_TEXT(pos, raw) {
		wchar_t c = Str__get(pos);
		if (c == SHELL_QUOTE_CHARACTER) PUT('\\');
		PUT(c);
	}
	PUT(SHELL_QUOTE_CHARACTER);
	PUT(' ');
}

#line 50 "inlib/Chapter 3/Shell.w"
void Shell__apply(char *command, filename *F) {
	TEMPORARY_TEXT(COMMAND)
	Shell__plain(COMMAND, command);
	Shell__plain(COMMAND, " ");
	Shell__quote_file(COMMAND, F);
	Shell__run(COMMAND);
	DISCARD_TEXT(COMMAND)
}

#line 62 "inlib/Chapter 3/Shell.w"
void Shell__rm(filename *F) {
	Shell__apply("rm", F);
}

void Shell__copy(filename *F, pathname *T, char *options) {
	TEMPORARY_TEXT(COMMAND)
	Shell__plain(COMMAND, "cp ");
	Shell__plain(COMMAND, options);
	Shell__quote_file(COMMAND, F);
	Shell__quote_path(COMMAND, T);
	Shell__run(COMMAND);
	DISCARD_TEXT(COMMAND)
}

#line 80 "inlib/Chapter 3/Shell.w"
void Shell__redirect(OUTPUT_STREAM, filename *F) {
	Shell__plain(OUT, ">");
	Shell__quote_file(OUT, F);
	Shell__plain(OUT, "2>&1");
}

#line 91 "inlib/Chapter 3/Shell.w"
int shell_verbosity = FALSE;
void Shell__verbose(void) {
	shell_verbosity = TRUE;
}

int Shell__run(OUTPUT_STREAM) {
	if (shell_verbosity) PRINT("shell: %S\n", OUT);
	LOGIF(SHELL_USAGE, "shell: %S\n", OUT);
	char spool[MAX_STRING_LENGTH];
	Streams__write_as_locale_string(spool, OUT, MAX_STRING_LENGTH);
	int rv = system(spool);
	if (rv == -1) {
		WRITE_TO(STDERR, "shell: %S\n", OUT);
		internal_error("OS shell error");
	}
	return rv;
}

#line 14 "inlib/Chapter 3/Directories.w"

#line 18 "inlib/Chapter 3/Directories.w"
scan_directory *Directories__open(pathname *P) {
	scan_directory *D = CREATE(scan_directory);
	Pathnames__to_string(D->directory_name_written_out, P);
	D->directory_handle = Platform__opendir(D->directory_name_written_out);
	return D;
}

int Directories__next(scan_directory *D, char *leafname) {
	return Platform__readdir(D->directory_handle, D->directory_name_written_out, leafname);
}

void Directories__close(scan_directory *D) {
	Platform__closedir(D->directory_handle);
}

#line 10 "inlib/Chapter 4/Characters.w"
char Characters__tolower(char c) {
	return (char) tolower((int) c);
}
char Characters__toupper(char c) {
	return (char) toupper((int) c);
}
int Characters__isalpha(char c) {
	return isalpha((int) c);
}
int Characters__isdigit(char c) {
	return isdigit((int) c);
}
int Characters__is_space_or_tab(int c) {
	if ((c == ' ') || (c == '\t')) return TRUE;
	return FALSE;
}

#line 30 "inlib/Chapter 4/Characters.w"
wchar_t Characters__w_tolower(wchar_t c) {
	return (wchar_t) tolower((int) c);
}
wchar_t Characters__w_toupper(wchar_t c) {
	return (wchar_t) toupper((int) c);
}
int Characters__w_isalpha(wchar_t c) {
	return isalpha((int) c);
}
int Characters__w_isdigit(wchar_t c) {
	return isdigit((int) c);
}

#line 48 "inlib/Chapter 4/Characters.w"
int Characters__combine_accent(int accent, int letter) {
	switch(accent) {
		case 0x0300: /* Unicode combining grave */
			switch(letter) {
				case 'a': return 0xE0; case 'e': return 0xE8; case 'i': return 0xEC;
				case 'o': return 0xF2; case 'u': return 0xF9;
				case 'A': return 0xC0; case 'E': return 0xC8; case 'I': return 0xCC;
				case 'O': return 0xD2; case 'U': return 0xD9;
			}
			break;
		case 0x0301: /* Unicode combining acute */
			switch(letter) {
				case 'a': return 0xE1; case 'e': return 0xE9; case 'i': return 0xED;
				case 'o': return 0xF3; case 'u': return 0xFA; case 'y': return 0xFF;
				case 'A': return 0xC1; case 'E': return 0xC9; case 'I': return 0xCD;
				case 'O': return 0xD3; case 'U': return 0xDA;
			}
			break;
		case 0x0302: /* Unicode combining circumflex */
			switch(letter) {
				case 'a': return 0xE2; case 'e': return 0xEA; case 'i': return 0xEE;
				case 'o': return 0xF4; case 'u': return 0xFB;
				case 'A': return 0xC2; case 'E': return 0xCA; case 'I': return 0xCE;
				case 'O': return 0xD4; case 'U': return 0xDB;
			}
			break;
		case 0x0303: /* Unicode combining tilde */
			switch(letter) {
				case 'a': return 0xE3; case 'n': return 0xF1; case 'o': return 0xF5;
				case 'A': return 0xC3; case 'N': return 0xD1; case 'O': return 0xD5;
			}
			break;
		case 0x0308: /* Unicode combining diaeresis */
			switch(letter) {
				case 'a': return 0xE4; case 'e': return 0xEB; case 'u': return 0xFC;
				case 'o': return 0xF6; case 'i': return 0xEF;
				case 'A': return 0xC4; case 'E': return 0xCB; case 'U': return 0xDC;
				case 'O': return 0xD6; case 'I': return 0xCF;
			}
			break;
		case 0x0327: /* Unicode combining cedilla */
			switch(letter) {
				case 'c': return 0xE7; case 'C': return 0xC7;
			}
			break;
	}
	return '?';
}

#line 16 "inlib/Chapter 4/Text Files.w"

#line 20 "inlib/Chapter 4/Text Files.w"
int TextFiles__get_line_count(text_file_position *tfp) {
	if (tfp == NULL) return 0;
	return tfp->line_count;
}

#line 28 "inlib/Chapter 4/Text Files.w"
text_file_position TextFiles__nowhere(void) {
	text_file_position tfp;
	tfp.text_file_filename = NULL;
	tfp.line_count = 0;
	tfp.line_position = 0;
	tfp.skip_terminator = FALSE;
	tfp.actively_scanning = FALSE;
	return tfp;
}

#line 41 "inlib/Chapter 4/Text Files.w"
int TextFiles__exists(filename *F) {
	FILE *HANDLE = Platform__iso_fopen(F, "rb");
	if (HANDLE == NULL) return FALSE;
	fclose(HANDLE);
	return TRUE;
}

#line 58 "inlib/Chapter 4/Text Files.w"
int TextFiles__read(filename *F, char *message, int serious,
	void (iterator)(text_stream *, text_file_position *, void *),
	text_file_position *start_at, void *state) {
	FILE *HANDLE;
	text_file_position tfp;
	unicode_file_buffer ufb = TextFiles__create_ufb();
	
{
#line 74 "inlib/Chapter 4/Text Files.w"
	HANDLE = Platform__iso_fopen(F, "rb");
	if (HANDLE == NULL) {
		if (message == NULL) return 0;
		if (serious) Errors__fatal_with_file(message, F);
		else { Errors__with_file(message, F); return 0; }
	}

}
#line 64 "inlib/Chapter 4/Text Files.w"
;
	
{
#line 87 "inlib/Chapter 4/Text Files.w"
	if (start_at == NULL) {
		tfp.line_count = 1;
		tfp.line_position = 0;
		tfp.skip_terminator = 'X';
	} else {
		tfp = *start_at;
		if (fseek(HANDLE, (long int) (tfp.line_position), SEEK_SET)) {
			if (serious) Errors__fatal_with_file("unable to seek position in file", F);
			Errors__with_file("unable to seek position in file", F);
			return 0;
		}
	}
	tfp.actively_scanning = TRUE;
	tfp.text_file_filename = F;

}
#line 65 "inlib/Chapter 4/Text Files.w"
;
	
{
#line 106 "inlib/Chapter 4/Text Files.w"
	TEMPORARY_TEXT(line);
	int i = 0, c = ' ';
	int warned = FALSE;
	while ((c != EOF) && (tfp.actively_scanning)) {
		c = TextFiles__utf8_fgetc(HANDLE, NULL, TRUE, &ufb);
		if ((c == EOF) || (c == '\x0a') || (c == '\x0d')) {
			Str__put_at(line, i, 0);
			if ((i > 0) || (c != tfp.skip_terminator)) {
				
{
#line 138 "inlib/Chapter 4/Text Files.w"
	iterator(line, &tfp, state);
	tfp.line_count++;

}
#line 114 "inlib/Chapter 4/Text Files.w"
;
				if (c == '\x0a') tfp.skip_terminator = '\x0d';
				if (c == '\x0d') tfp.skip_terminator = '\x0a';
			} else tfp.skip_terminator = 'X';
			
{
#line 152 "inlib/Chapter 4/Text Files.w"
	tfp.line_position = (int) (ftell(HANDLE));
	if (tfp.line_position == -1) {
		if (serious)
			Errors__fatal_with_file("unable to determine position in file", F);
		else
			Errors__with_file("unable to determine position in file", F);
	}

}
#line 118 "inlib/Chapter 4/Text Files.w"
;
			i = 0;
		} else {
			if (i < MAX_STRING_LENGTH) Str__put_at(line, i++, (char) c);
			else {
				if (serious) Errors__fatal_with_file("line too long", F);
				if (warned == FALSE) {
					Errors__in_text_file("line too long (truncating it)", &tfp);
					warned = TRUE;
				}
			}
		}
	}
	if ((i > 0) && (tfp.actively_scanning))
		
{
#line 138 "inlib/Chapter 4/Text Files.w"
	iterator(line, &tfp, state);
	tfp.line_count++;

}
#line 132 "inlib/Chapter 4/Text Files.w"
;
	DISCARD_TEXT(line);

}
#line 66 "inlib/Chapter 4/Text Files.w"
;
	fclose(HANDLE);
	return tfp.line_count;
}

#line 163 "inlib/Chapter 4/Text Files.w"
int TextFiles__read_with_lines_to_ISO(filename *F, char *message, int serious,
	void (iterator)(char *, text_file_position *, void *), text_file_position *start_at,
	void *state) {
	FILE *HANDLE;
	text_file_position tfp;
	unicode_file_buffer ufb = TextFiles__create_ufb();
	
{
#line 179 "inlib/Chapter 4/Text Files.w"
	HANDLE = Platform__iso_fopen(F, "rb");
	if (HANDLE == NULL) {
		if (message == NULL) return 0;
		if (serious) Errors__fatal_with_file(message, F);
		else { Errors__with_file(message, F); return 0; }
	}

}
#line 169 "inlib/Chapter 4/Text Files.w"
;
	
{
#line 189 "inlib/Chapter 4/Text Files.w"
	if (start_at == NULL) {
		tfp.line_count = 1;
		tfp.line_position = 0;
		tfp.skip_terminator = 'X';
	} else {
		tfp = *start_at;
		if (fseek(HANDLE, (long int) (tfp.line_position), SEEK_SET)) {
			if (serious) Errors__fatal_with_file("unable to seek position in file", F);
			Errors__with_file("unable to seek position in file", F);
			return 0;
		}
	}
	tfp.actively_scanning = TRUE;
	tfp.text_file_filename = F;

}
#line 170 "inlib/Chapter 4/Text Files.w"
;
	
{
#line 207 "inlib/Chapter 4/Text Files.w"
	char line[MAX_STRING_LENGTH]; CStrings__copy(line, "");
	int i = 0, c = ' ';
	int warned = FALSE;
	while ((c != EOF) && (tfp.actively_scanning)) {
		c = TextFiles__utf8_fgetc(HANDLE, NULL, TRUE, &ufb);
		if ((c == EOF) || (c == '\x0a') || (c == '\x0d')) {
			CStrings__set_char(line, i, 0);
			if ((i > 0) || (c != tfp.skip_terminator)) {
				
{
#line 239 "inlib/Chapter 4/Text Files.w"
	iterator(line, &tfp, state);
	tfp.line_count++;

}
#line 215 "inlib/Chapter 4/Text Files.w"
;
				if (c == '\x0a') tfp.skip_terminator = '\x0d';
				if (c == '\x0d') tfp.skip_terminator = '\x0a';
			} else tfp.skip_terminator = 'X';
			
{
#line 245 "inlib/Chapter 4/Text Files.w"
	tfp.line_position = (int) (ftell(HANDLE));
	if (tfp.line_position == -1) {
		if (serious)
			Errors__fatal_with_file("unable to determine position in file", F);
		else
			Errors__with_file("unable to determine position in file", F);
	}

}
#line 219 "inlib/Chapter 4/Text Files.w"
;
			i = 0;
		} else {
			if (i < MAX_STRING_LENGTH) CStrings__set_char(line, i++, (char) c);
			else {
				if (serious) Errors__fatal_with_file("line too long", F);
				if (warned == FALSE) {
					Errors__in_text_file("line too long (truncating it)", &tfp);
					warned = TRUE;
				}
			}
		}
	}
	if ((i > 0) && (tfp.actively_scanning))
		
{
#line 239 "inlib/Chapter 4/Text Files.w"
	iterator(line, &tfp, state);
	tfp.line_count++;

}
#line 233 "inlib/Chapter 4/Text Files.w"
;


}
#line 171 "inlib/Chapter 4/Text Files.w"
;
	fclose(HANDLE);
	return tfp.line_count;
}

#line 257 "inlib/Chapter 4/Text Files.w"
void TextFiles__lose_interest(text_file_position *tfp) {
	tfp->actively_scanning = FALSE;
}

#line 289 "inlib/Chapter 4/Text Files.w"

unicode_file_buffer TextFiles__create_ufb(void) {
	unicode_file_buffer ufb;
	ufb.ufb_counter = -1;
	return ufb;
}

int TextFiles__utf8_fgetc(FILE *from, char **or_from, int escape_oddities,
	unicode_file_buffer *ufb) {
	int c = EOF, conts;
	if (ufb->ufb_counter >= 0) {
		if (ufb->unicode_feed_buffer[ufb->ufb_counter] == 0) ufb->ufb_counter = -1;
		else return ufb->unicode_feed_buffer[ufb->ufb_counter++];
	}
	if (from) c = fgetc(from); else if (or_from) c = ((unsigned char) *((*or_from)++));
	if (c == EOF) return c; /* ruling out EOF leaves a genuine byte from the file */
	if (c<0x80) return c; /* in all other cases, a UTF-8 continuation sequence begins */

	
{
#line 327 "inlib/Chapter 4/Text Files.w"
    if (c<0xC0) return '?'; /* malformed UTF-8 */
	if (c<0xE0) { c = c & 0x1f; conts = 1; }
	else if (c<0xF0) { c = c & 0xf; conts = 2; }
	else if (c<0xF8) { c = c & 0x7; conts = 3; }
	else if (c<0xFC) { c = c & 0x3; conts = 4; }
	else { c = c & 0x1; conts = 5; }
	while (conts > 0) {
		int d = EOF;
		if (from) d = fgetc(from); else if (or_from) d = ((unsigned char) *((*or_from)++));
		if (d == EOF) return '?'; /* malformed UTF-8 */
		c = c << 6;
		c = c + (d & 0x3F);
		conts--;
	}

}
#line 307 "inlib/Chapter 4/Text Files.w"
;
    
{
#line 355 "inlib/Chapter 4/Text Files.w"
	if ((c == 0xa1) || (c == 0xa3) || (c == 0xbf)) return c; /* pound sign, inverted ! and ? */
	if (c == 0xd7) return 'x'; /* convert multiplication sign to lower case "x" */
	if ((c >= 0xc0) && (c <= 0xff)) { /* accented West European letters, but... */
		if ((c != 0xd0) && (c != 0xf0) && /* not Icelandic eths */
		    (c != 0xde) && (c != 0xfe) && /* nor Icelandic thorns */
			(c != 0xf7)) /* nor division signs */
			return c;
	}

}
#line 308 "inlib/Chapter 4/Text Files.w"
;
    
{
#line 370 "inlib/Chapter 4/Text Files.w"
	if (c == 0x85) return '\x0d'; /* NEL, or "next line" */
	if (c == 0xa0) return ' '; /* non-breaking space */
	if ((c >= 0x2000) && (c <= 0x200a)) return ' '; /* space variants */
	if ((c >= 0x2010) && (c <= 0x2014)) return '-'; /* rules and dashes */
	if ((c >= 0x2018) && (c <= 0x2019)) return '\''; /* smart single quotes */
	if ((c >= 0x201c) && (c <= 0x201d)) return '"'; /* smart double quotes */
	if ((c >= 0x2028) && (c <= 0x2029)) return '\x0d'; /* fancy newlines */

}
#line 309 "inlib/Chapter 4/Text Files.w"
;

	if (c == 0xFEFF) return c; /* the Unicode BOM non-character */

	if (escape_oddities == FALSE) return c;

	sprintf(ufb->unicode_feed_buffer, "[unicode %d]", c);
	ufb->ufb_counter = 1;
	return '[';
}

#line 10 "inlib/Chapter 4/Pattern Matching.w"
int Regexp__white_space(int c) {
	if ((c == ' ') || (c == '\t')) return TRUE;
	return FALSE;
}

#line 20 "inlib/Chapter 4/Pattern Matching.w"
int Regexp__identifier_char(int c) {
	if ((c == '_') || (c == ':') ||
		((c >= 'A') && (c <= 'Z')) ||
		((c >= 'a') && (c <= 'z')) ||
		((c >= '0') && (c <= '9'))) return TRUE;
	return FALSE;
}

#line 35 "inlib/Chapter 4/Pattern Matching.w"
int Regexp__find_expansion(text_stream *text, wchar_t on1, wchar_t on2,
	wchar_t off1, wchar_t off2, int *len) {
	for (int i = 0; i < Str__len(text); i++)
		if ((Str__get_at(text, i) == on1) && (Str__get_at(text, i+1) == on2)) {
			for (int j=i+2; j < Str__len(text); j++)
				if ((Str__get_at(text, j) == off1) && (Str__get_at(text, j+1) == off2)) {
					*len = j+2-i;
					return i;
				}
		}
	return -1;
}

#line 51 "inlib/Chapter 4/Pattern Matching.w"
int Regexp__find_open_brace(text_stream *text) {
	for (int i=0; i < Str__len(text); i++)
		if (Str__get_at(text, i) == '{')
			return i;
	return -1;
}

#line 62 "inlib/Chapter 4/Pattern Matching.w"
int Regexp__string_is_white_space(text_stream *text) {
	LOOP_THROUGH_TEXT(P, text)
		if (Regexp__white_space(Str__get(P)) == FALSE)
			return FALSE;
	return TRUE;
}

#line 98 "inlib/Chapter 4/Pattern Matching.w"

#line 111 "inlib/Chapter 4/Pattern Matching.w"

#line 115 "inlib/Chapter 4/Pattern Matching.w"
match_results Regexp__create_mr(void) {
	match_results mr;
	mr.no_matched_texts = 0;
	for (int i=0; i<MAX_BRACKETED_SUBEXPRESSIONS; i++) mr.exp[i] = NULL;
	return mr;
}

int Regexp__match(match_results *mr, text_stream *text, wchar_t *pattern) {
	mr->no_matched_texts = 0;
	for (int i=0; i<MAX_BRACKETED_SUBEXPRESSIONS; i++) {
		mr->exp_storage[i].match_text_struct =
			Streams__new_buffer(64, mr->exp_storage[i].match_text_storage);
		mr->exp[i] = &(mr->exp_storage[i].match_text_struct);
	}
	int rv = Regexp__match_r(mr, text, pattern, NULL);
	if (rv == FALSE) Regexp__dispose_of(mr);
	return rv;
}

void Regexp__dispose_of(match_results *mr) {
	for (int i=0; i<MAX_BRACKETED_SUBEXPRESSIONS; i++)
		if (mr->exp[i]) {
			STREAM_CLOSE(mr->exp[i]);
			mr->exp[i] = NULL;
		}
	mr->no_matched_texts = 0;
}

#line 146 "inlib/Chapter 4/Pattern Matching.w"
int Regexp__match_r(match_results *mr, text_stream *text, wchar_t *pattern, match_position *scan_from) {
	match_position at;
	if (scan_from) at = *scan_from;
	else { at.tpos = 0; at.ppos = 0; at.bc = 0; at.bl = 0; }

	while ((Str__get_at(text, at.tpos)) || (pattern[at.ppos])) {
		
{
#line 181 "inlib/Chapter 4/Pattern Matching.w"
	if (pattern[at.ppos] == '(') {
		if (at.bl < MAX_BRACKETED_SUBEXPRESSIONS) at.bracket_nesting[at.bl] = -1;
		if (at.bc < MAX_BRACKETED_SUBEXPRESSIONS) {
			at.bracket_nesting[at.bl] = at.bc;
			at.brackets_start[at.bc] = at.tpos; at.brackets_end[at.bc] = -1;
		}
		at.bl++; at.bc++; at.ppos++;
		continue;
	}
	if (pattern[at.ppos] == ')') {
		at.bl--;
		if ((at.bl >= 0) && (at.bl < MAX_BRACKETED_SUBEXPRESSIONS) && (at.bracket_nesting[at.bl] >= 0))
			at.brackets_end[at.bracket_nesting[at.bl]] = at.tpos-1;
		at.ppos++;
		continue;
	}

}
#line 152 "inlib/Chapter 4/Pattern Matching.w"
;

		int chcl, /* what class of characters to match: a |*_CLASS| value */
			range_from, range_to, /* for |LITERAL_CLASS| only */
			reverse = FALSE; /* require a non-match rather than a match */
		
{
#line 201 "inlib/Chapter 4/Pattern Matching.w"
	int len;
	chcl = Regexp__get_cclass(pattern, at.ppos, &len, &range_from, &range_to, &reverse);
	at.ppos += len;

}
#line 157 "inlib/Chapter 4/Pattern Matching.w"
;

		int rep_from = 1, rep_to = 1; /* minimum and maximum number of repetitions */
		int greedy = TRUE; /* go for a maximal-length match if possible */
		
{
#line 209 "inlib/Chapter 4/Pattern Matching.w"
	if (chcl == WHITESPACE_CLASS) {
		rep_from = 1; rep_to = Str__len(text)-at.tpos;
	}
	if (pattern[at.ppos] == '+') {
		rep_from = 1; rep_to = Str__len(text)-at.tpos; at.ppos++;
	} else if (pattern[at.ppos] == '*') {
		rep_from = 0; rep_to = Str__len(text)-at.tpos; at.ppos++;
	}
	if (pattern[at.ppos] == '?') { greedy = FALSE; at.ppos++; }

}
#line 161 "inlib/Chapter 4/Pattern Matching.w"
;

		int reps = 0;
		
{
#line 222 "inlib/Chapter 4/Pattern Matching.w"
	for (reps = 0; ((Str__get_at(text, at.tpos+reps)) && (reps <= rep_to)); reps++)
		if (Regexp__test_cclass(Str__get_at(text, at.tpos+reps), chcl,
			range_from, range_to, pattern, reverse) == FALSE)
			break;

}
#line 164 "inlib/Chapter 4/Pattern Matching.w"
;
		if (reps < rep_from) return FALSE;

		/* we can now accept anything from |rep_from| to |reps| repetitions */
		if (rep_from == reps) { at.tpos += reps; continue; }
		
{
#line 230 "inlib/Chapter 4/Pattern Matching.w"
	int from = rep_from, to = reps, dj = 1, from_tpos = at.tpos;
	if (greedy) { from = reps; to = rep_from; dj = -1; }
	for (int j = from; j != to+dj; j += dj) {
		at.tpos = from_tpos + j;
		if (Regexp__match_r(mr, text, pattern, &at))
			return TRUE;
	}

}
#line 169 "inlib/Chapter 4/Pattern Matching.w"
;

		/* no match length worked, so no match */
		return FALSE;
	}
	
{
#line 241 "inlib/Chapter 4/Pattern Matching.w"
	for (int i=0; i<at.bc; i++) {
		Str__clear(mr->exp[i]);
		for (int j = at.brackets_start[i]; j <= at.brackets_end[i]; j++)
			PUT_TO(mr->exp[i], Str__get_at(text, j));
	}
	mr->no_matched_texts = at.bc;

}
#line 174 "inlib/Chapter 4/Pattern Matching.w"
;
	return TRUE;
}

#line 279 "inlib/Chapter 4/Pattern Matching.w"
int Regexp__get_cclass(wchar_t *pattern, int ppos, int *len, int *from, int *to, int *reverse) {
	if (pattern[ppos] == '^') { ppos++; *reverse = TRUE; } else { *reverse = FALSE; }
	switch (pattern[ppos]) {
		case '%':
			ppos++;
			*len = 2;
			switch (pattern[ppos]) {
				case 'd': return DIGIT_CLASS;
				case 'c': return ANY_CLASS;
				case 'C': return NONWHITESPACE_CLASS;
				case 'i': return IDENTIFIER_CLASS;
				case 'p': return PREFORM_CLASS;
				case 'P': return PREFORMC_CLASS;
				case 't': return TAB_CLASS;
			}
			*from = ppos; *to = ppos; return LITERAL_CLASS;
		case '[':
			*from = ppos+2;
			while ((pattern[ppos]) && (pattern[ppos] != ']')) ppos++;
			*to = ppos - 1; *len = ppos - *from + 1;
			return LITERAL_CLASS;
		case ' ':
			*len = 1; return WHITESPACE_CLASS;
	}
	*len = 1; *from = ppos; *to = ppos; return LITERAL_CLASS;
}

#line 309 "inlib/Chapter 4/Pattern Matching.w"
int Regexp__test_cclass(int c, int chcl, int range_from, int range_to, wchar_t *drawn_from, int reverse) {
	int match = FALSE;
	switch (chcl) {
		case ANY_CLASS: if (c) match = TRUE; break;
		case DIGIT_CLASS: if (isdigit(c)) match = TRUE; break;
		case WHITESPACE_CLASS: if (ISORegexp__white_space(c)) match = TRUE; break;
		case TAB_CLASS: if (c == '\t') match = TRUE; break;
		case NONWHITESPACE_CLASS: if (!(ISORegexp__white_space(c))) match = TRUE; break;
		case IDENTIFIER_CLASS: if (Regexp__identifier_char(c)) match = TRUE; break;
		case PREFORM_CLASS: if ((c == '-') || (c == '_') ||
			((c >= 'a') && (c <= 'z')) ||
			((c >= '0') && (c <= '9'))) match = TRUE; break;
		case PREFORMC_CLASS: if ((c == '-') || (c == '_') || (c == ':') ||
			((c >= 'a') && (c <= 'z')) ||
			((c >= '0') && (c <= '9'))) match = TRUE; break;
		case LITERAL_CLASS:
			for (int j = range_from; j <= range_to; j++) {
				int c1 = drawn_from[j], c2 = c1;
				if ((j+1 < range_to) && (drawn_from[j+1] == '-')) { c2 = drawn_from[j+2]; j += 2; }
				if ((c >= c1) && (c <= c2)) {
					match = TRUE; break;
				}
			}
			break;
	}
	if (reverse) match = (match)?FALSE:TRUE;
	return match;
}

#line 11 "inlib/Chapter 4/ISO Pattern Matching.w"
int ISORegexp__white_space(int c) {
	if ((c == ' ') || (c == '\t')) return TRUE;
	return FALSE;
}

#line 21 "inlib/Chapter 4/ISO Pattern Matching.w"
int ISORegexp__identifier_char(int c) {
	if ((c == '_') || (c == ':') ||
		((c >= 'A') && (c <= 'Z')) ||
		((c >= 'a') && (c <= 'z')) ||
		((c >= '0') && (c <= '9'))) return TRUE;
	return FALSE;
}

#line 36 "inlib/Chapter 4/ISO Pattern Matching.w"
int ISORegexp__find_expansion(char *original, char on1, char on2, char off1, char off2, int *len) {
	for (int i = 0; original[i]; i++)
		if ((original[i] == on1) && (original[i+1] == on2)) {
			for (int j=i+2; original[j]; j++)
				if ((original[j] == off1) && (original[j+1] == off2)) {
					*len = j+2-i;
					return i;
				}
		}
	return -1;
}

#line 51 "inlib/Chapter 4/ISO Pattern Matching.w"
int ISORegexp__find_open_brace(char *p) {
	for (int i=0; p[i]; i++)
		if (p[i] == '{')
			return i;
	return -1;
}

#line 62 "inlib/Chapter 4/ISO Pattern Matching.w"
int ISORegexp__string_is_white_space(char *p) {
	for (int i=0; p[i]; i++)
		if (ISORegexp__white_space(p[i]) == FALSE)
			return FALSE;
	return TRUE;
}

#line 100 "inlib/Chapter 4/ISO Pattern Matching.w"

#line 104 "inlib/Chapter 4/ISO Pattern Matching.w"
int ISORegexp__match_0(char *text, char *pattern) {
	return ISORegexp__match_r(text, pattern, NULL, NULL, NULL, NULL, NULL);
}

int ISORegexp__match_1(char *text, char *pattern, char *ft1) {
	return ISORegexp__match_r(text, pattern, NULL, ft1, NULL, NULL, NULL);
}

int ISORegexp__match_2(char *text, char *pattern, char *ft1, char *ft2) {
	return ISORegexp__match_r(text, pattern, NULL, ft1, ft2, NULL, NULL);
}

int ISORegexp__match_3(char *text, char *pattern, char *ft1, char *ft2, char *ft3) {
	return ISORegexp__match_r(text, pattern, NULL, ft1, ft2, ft3, NULL);
}

int ISORegexp__match_4(char *text, char *pattern, char *ft1, char *ft2, char *ft3, char *ft4) {
	return ISORegexp__match_r(text, pattern, NULL, ft1, ft2, ft3, ft4);
}

#line 127 "inlib/Chapter 4/ISO Pattern Matching.w"
int ISORegexp__match_r(char *text, char *pattern, match_position *scan_from, char *ft1, char *ft2, char *ft3, char *ft4) {
	match_position at;
	if (scan_from) at = *scan_from;
	else { at.tpos = 0; at.ppos = 0; at.bc = 0; at.bl = 0; }

	while ((text[at.tpos]) || (pattern[at.ppos])) {
		
{
#line 162 "inlib/Chapter 4/ISO Pattern Matching.w"
	if (pattern[at.ppos] == '(') {
		if (at.bl < 4) at.bracket_nesting[at.bl] = -1;
		if (at.bc < 4) {
			at.bracket_nesting[at.bl] = at.bc;
			at.brackets_start[at.bc] = at.tpos; at.brackets_end[at.bc] = -1;
		}
		at.bl++; at.bc++; at.ppos++;
		continue;
	}
	if (pattern[at.ppos] == ')') {
		at.bl--;
		if ((at.bl >= 0) && (at.bl < 4) && (at.bracket_nesting[at.bl] >= 0))
			at.brackets_end[at.bracket_nesting[at.bl]] = at.tpos-1;
		at.ppos++;
		continue;
	}

}
#line 133 "inlib/Chapter 4/ISO Pattern Matching.w"
;

		int chcl, /* what class of characters to match: a |*_CLASS| value */
			range_from, range_to, /* for |LITERAL_CLASS| only */
			reverse = FALSE; /* require a non-match rather than a match */
		
{
#line 182 "inlib/Chapter 4/ISO Pattern Matching.w"
	int len;
	chcl = ISORegexp__get_cclass(pattern, at.ppos, &len, &range_from, &range_to, &reverse);
	at.ppos += len;

}
#line 138 "inlib/Chapter 4/ISO Pattern Matching.w"
;

		int rep_from = 1, rep_to = 1; /* minimum and maximum number of repetitions */
		int greedy = TRUE; /* go for a maximal-length match if possible */
		
{
#line 190 "inlib/Chapter 4/ISO Pattern Matching.w"
	if (chcl == WHITESPACE_CLASS) {
		rep_from = 1; rep_to = CStrings__len(text)-at.tpos;
	}
	if (pattern[at.ppos] == '+') {
		rep_from = 1; rep_to = CStrings__len(text)-at.tpos; at.ppos++;
	} else if (pattern[at.ppos] == '*') {
		rep_from = 0; rep_to = CStrings__len(text)-at.tpos; at.ppos++;
	}
	if (pattern[at.ppos] == '?') { greedy = FALSE; at.ppos++; }

}
#line 142 "inlib/Chapter 4/ISO Pattern Matching.w"
;

		int reps = 0;
		
{
#line 203 "inlib/Chapter 4/ISO Pattern Matching.w"
	for (reps = 0; ((text[at.tpos+reps]) && (reps <= rep_to)); reps++)
		if (ISORegexp__test_cclass(text+at.tpos+reps, chcl,
			range_from, range_to, pattern, reverse) == FALSE)
			break;

}
#line 145 "inlib/Chapter 4/ISO Pattern Matching.w"
;
		if (reps < rep_from) return FALSE;

		/* we can now accept anything from |rep_from| to |reps| repetitions */
		if (rep_from == reps) { at.tpos += reps; continue; }
		
{
#line 211 "inlib/Chapter 4/ISO Pattern Matching.w"
	int from = rep_from, to = reps, dj = 1, from_tpos = at.tpos;
	if (greedy) { from = reps; to = rep_from; dj = -1; }
	for (int j = from; j != to+dj; j += dj) {
		at.tpos = from_tpos + j;
		if (ISORegexp__match_r(text, pattern, &at, ft1, ft2, ft3, ft4))
			return TRUE;
	}

}
#line 150 "inlib/Chapter 4/ISO Pattern Matching.w"
;

		/* no match length worked, so no match */
		return FALSE;
	}
	
{
#line 222 "inlib/Chapter 4/ISO Pattern Matching.w"
	if ((at.bc > 0) && (ft1)) {
		CStrings__copy(ft1, text + at.brackets_start[0]);
		ft1[at.brackets_end[0]-at.brackets_start[0]+1] = 0;
	}
	if ((at.bc > 1) && (ft2)) {
		CStrings__copy(ft2, text + at.brackets_start[1]);
		ft2[at.brackets_end[1]-at.brackets_start[1]+1] = 0;
	}
	if ((at.bc > 2) && (ft3)) {
		CStrings__copy(ft3, text + at.brackets_start[2]);
		ft3[at.brackets_end[2]-at.brackets_start[2]+1] = 0;
	}
	if ((at.bc > 3) && (ft4)) {
		CStrings__copy(ft4, text + at.brackets_start[3]);
		ft4[at.brackets_end[3]-at.brackets_start[3]+1] = 0;
	}

}
#line 155 "inlib/Chapter 4/ISO Pattern Matching.w"
;
	return TRUE;
}

#line 270 "inlib/Chapter 4/ISO Pattern Matching.w"
int ISORegexp__get_cclass(char *pattern, int ppos, int *len, int *from, int *to, int *reverse) {
	if (pattern[ppos] == '^') { ppos++; *reverse = TRUE; } else { *reverse = FALSE; }
	switch (pattern[ppos]) {
		case '%':
			ppos++;
			*len = 2;
			switch (pattern[ppos]) {
				case 'd': return DIGIT_CLASS;
				case 'c': return ANY_CLASS;
				case 'C': return NONWHITESPACE_CLASS;
				case 'i': return IDENTIFIER_CLASS;
				case 'p': return PREFORM_CLASS;
				case 'P': return PREFORMC_CLASS;
				case 't': return TAB_CLASS;
			}
			*from = ppos; *to = ppos; return LITERAL_CLASS;
		case '[':
			*from = ppos+2;
			while ((pattern[ppos]) && (pattern[ppos] != ']')) ppos++;
			*to = ppos - 1; *len = ppos - *from + 1;
			return LITERAL_CLASS;
		case ' ':
			*len = 1; return WHITESPACE_CLASS;
	}
	*len = 1; *from = ppos; *to = ppos; return LITERAL_CLASS;
}

#line 300 "inlib/Chapter 4/ISO Pattern Matching.w"
int ISORegexp__test_cclass(char *text, int chcl, int range_from, int range_to, char *drawn_from, int reverse) {
	int match = FALSE;
	switch (chcl) {
		case ANY_CLASS: if (text[0]) match = TRUE; break;
		case DIGIT_CLASS: if (isdigit(text[0])) match = TRUE; break;
		case WHITESPACE_CLASS: if (ISORegexp__white_space(text[0])) match = TRUE; break;
		case TAB_CLASS: if (text[0] == '\t') match = TRUE; break;
		case NONWHITESPACE_CLASS: if (!(ISORegexp__white_space(text[0]))) match = TRUE; break;
		case IDENTIFIER_CLASS: if (ISORegexp__identifier_char(text[0])) match = TRUE; break;
		case PREFORM_CLASS: if ((text[0] == '-') || (text[0] == '_') ||
			((text[0] >= 'a') && (text[0] <= 'z')) ||
			((text[0] >= '0') && (text[0] <= '9'))) match = TRUE; break;
		case PREFORMC_CLASS: if ((text[0] == '-') || (text[0] == '_') || (text[0] == ':') ||
			((text[0] >= 'a') && (text[0] <= 'z')) ||
			((text[0] >= '0') && (text[0] <= '9'))) match = TRUE; break;
		case LITERAL_CLASS:
			for (int j = range_from; j <= range_to; j++) {
				int c1 = drawn_from[j], c2 = c1;
				if ((j+1 < range_to) && (drawn_from[j+1] == '-')) { c2 = drawn_from[j+2]; j += 2; }
				int c = *text;
				if ((c >= c1) && (c <= c2)) {
					match = TRUE; break;
				}
			}
			break;
	}
	if (reverse) match = (match)?FALSE:TRUE;
	return match;
}

#line 18 "inlib/Chapter 5/HTML.w"

void HTML__declare_as_HTML(OUTPUT_STREAM, int XHTML) {
	HTML_file_state *hs = CREATE(HTML_file_state);
	hs->XHTML_flag = XHTML;
	hs->tag_sp = 0;
	Streams__declare_as_HTML(OUT, hs);
}

void HTML__completed(OUTPUT_STREAM) {
	HTML_file_state *hs = CREATE(HTML_file_state);
	if (hs->tag_sp > 0) {
		for (int i=0; i < hs->tag_sp; i++)
			WRITE_TO(STDERR, "%d: %s\n", i, hs->tag_stack[i]);
		internal_error("HTML tags still open");
	}
}

#line 38 "inlib/Chapter 5/HTML.w"
void HTML__open(OUTPUT_STREAM, char *tag) {
	HTML__open_with_id_and_class(OUT, tag, NULL, NULL);
}
void HTML__open_with_id(OUTPUT_STREAM, char *tag, char *id) {
	HTML__open_with_id_and_class(OUT, tag, NULL, id);
}
void HTML__open_with_class(OUTPUT_STREAM, char *tag, char *class) {
	HTML__open_with_id_and_class(OUT, tag, class, NULL);
}

void HTML__open_with_id_and_class(OUTPUT_STREAM, char *tag, char *class, char *id) {
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if (hs) {
		if (hs->tag_sp < MAX_TAG_STACK_SIZE) hs->tag_stack[hs->tag_sp] = tag;
		hs->tag_sp++;
	}
	WRITE("<%s", tag);
	if (class) WRITE(" class=\"%s\"", class);
	if (id) WRITE(" id=\"%s\"", id);
	WRITE(">");
}

#line 64 "inlib/Chapter 5/HTML.w"
void HTML__close(OUTPUT_STREAM, char *tag) {
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if (hs) {
		hs->tag_sp--;
		if (hs->tag_sp < 0) {
			WRITE_TO(STDERR, "tag: %s\n", tag);
			internal_error("closed HTML tag which wasn't open");
		} else if (hs->tag_sp < MAX_TAG_STACK_SIZE) {
			if (CStrings__ne(tag, hs->tag_stack[hs->tag_sp])) {
				WRITE_TO(STDERR, "expected to close tag %s, but actually closed %s\n",
					hs->tag_stack[hs->tag_sp], tag);
				internal_error("closed HTML tag which wasn't open");
			}
		}
	}
	WRITE("</%s>", tag);
}

#line 85 "inlib/Chapter 5/HTML.w"
void HTML__self_closing(OUTPUT_STREAM) {
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if (hs->XHTML_flag) WRITE(" /");
	WRITE(">");
}

#line 94 "inlib/Chapter 5/HTML.w"
void HTML__begin_head(OUTPUT_STREAM, filename *CSS_file) {
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if (hs->XHTML_flag) {
		WRITE("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" ");
		WRITE("\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n");
		WRITE("<html xmlns=\"http://www.w3.org/1999/xhtml\">\n");
	} else {
		WRITE("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" ");
		WRITE("\"http://www.w3.org/TR/html4/loose.dtd\">\n");
		WRITE("<html>\n");
	}
	HTML__open(OUT, "head"); WRITE("\n"); INDENT;
	WRITE("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"");
	HTML__self_closing(OUT);
	WRITE("\n");
	if (CSS_file) {
		WRITE("<link href=\"%/p\" rel=\"stylesheet\" type=\"text/css\"", CSS_file);
		HTML__self_closing(OUT);
		WRITE("\n");
	}
}

void HTML__end_head(OUTPUT_STREAM) {
	OUTDENT; HTML__close(OUT, "head"); WRITE("\n");
}

#line 123 "inlib/Chapter 5/HTML.w"
void HTML__begin_body(OUTPUT_STREAM, char *class) {
	HTML__open_with_class(OUT, "body", class); WRITE("\n"); INDENT;
}

void HTML__end_body(OUTPUT_STREAM) {
	OUTDENT; HTML__close(OUT, "body"); WRITE("\n");
	HTML__close(OUT, "html"); WRITE("\n");
}

#line 135 "inlib/Chapter 5/HTML.w"
void HTML__begin_div_with_id(OUTPUT_STREAM, char *id) {
	HTML__open_with_id(OUT, "div", id); WRITE("\n", id); INDENT;
}

void HTML__begin_div_with_class(OUTPUT_STREAM, char *cl) {
	HTML__open_with_class(OUT, "div", cl); WRITE("\n"); INDENT;
}

void HTML__begin_div_with_class_and_id(OUTPUT_STREAM, char *cl, char *id, int hide) {
	WRITE("<div class=\"%s\" id=\"%s\"", cl, id);
	if (hide) { WRITE(" style=\"display: none;\""); }
	WRITE(">\n"); INDENT;
}

void HTML__end_div(OUTPUT_STREAM) {
	OUTDENT; WRITE("</div>\n");
}

#line 156 "inlib/Chapter 5/HTML.w"
void HTML__image(OUTPUT_STREAM, filename *F) {
	WRITE("<img src=\"%/f\"", F);
	HTML__self_closing(OUT);
}

#line 164 "inlib/Chapter 5/HTML.w"
void HTML__anchor(OUTPUT_STREAM, text_stream *id) {
	WRITE("<a id=\"%S\"", id);
	HTML__self_closing(OUT);
}

void HTML__begin_link(OUTPUT_STREAM, text_stream *href) {
	WRITE("<a href=\"%S\">", href);
}

void HTML__end_link(OUTPUT_STREAM) {
	WRITE("</a>");
}

#line 180 "inlib/Chapter 5/HTML.w"
void HTML__comment(OUTPUT_STREAM, char *text) {
	WRITE("<!--%s-->\n", text);
}

void HTML__heading(OUTPUT_STREAM, char *tag, char *text) {
	WRITE("<%s>%s</%s>\n", tag, text, tag);
}

void HTML__hr(OUTPUT_STREAM, char *class) {
	WRITE("<hr");
	if (class) WRITE(" class=\"%s\"", class);
	HTML__self_closing(OUT);
	WRITE("\n");
}

#line 41 "inlib/Chapter 5/Epub Ebooks.w"

#line 53 "inlib/Chapter 5/Epub Ebooks.w"

#line 63 "inlib/Chapter 5/Epub Ebooks.w"

#line 71 "inlib/Chapter 5/Epub Ebooks.w"

#line 91 "inlib/Chapter 5/Epub Ebooks.w"

#line 98 "inlib/Chapter 5/Epub Ebooks.w"

#line 116 "inlib/Chapter 5/Epub Ebooks.w"
ebook *Epub__new(text_stream *title) {
	ebook *B = CREATE(ebook);
	B->metadata_list = NULL;
	B->OEBPS_path = NULL;
	B->CSS_file = NULL;
	B->ebook_page_list = NULL;
	B->ebook_image_list = NULL;
	B->ebook_volume_list = NULL; B->current_volume = NULL;
	B->ebook_chapter_list = NULL; B->current_chapter = NULL;
	B->eventual_epub = NULL;
	Epub__attach_metadata(B, L"title", title);
	return B;
}

void Epub__use_CSS(ebook *B, filename *F) {
	B->CSS_file = F;
}

text_stream *Epub__attach_metadata(ebook *B, wchar_t *K, text_stream *V) {
	ebook_datum *L = NULL;
	for (ebook_datum *D = B->metadata_list; D; L = D, D = D->next_metadatum)
		if (Str__eq_C_string(D->key, K)) {
			WRITE_TO(D->value, "%s", V);
			return D->value;
		}
	ebook_datum *D = CREATE(ebook_datum);
	D->key = Str__new_from_wide_string(K);
	D->value = Str__duplicate(V);
	D->next_metadatum = NULL;
	if (L) L->next_metadatum = D; else B->metadata_list = D;
	return D->value;
}

text_stream *Epub__get_metadata(ebook *B, wchar_t *K) {
	for (ebook_datum *D = B->metadata_list; D; D = D->next_metadatum)
		if (Str__eq_C_string(D->key, K))
			return D->value;
	return NULL;
}

text_stream *Epub__ensure_metadata(ebook *B, wchar_t *K) {
	text_stream *S = Epub__get_metadata(B, K);
	if (S == NULL) S = Epub__attach_metadata(B, K, NULL);
	return S;
}

ebook_page *Epub__note_page(ebook *B, filename *F, char *title, char *type) {
	ebook_page *P = CREATE(ebook_page);
	P->relative_URL = F;
	P->nav_entry_written = FALSE;
	P->in_volume = B->current_volume;
	P->in_chapter = B->current_chapter;
	P->page_title = Str__new_from_ISO_string(title);
	P->page_type = Str__new_from_ISO_string(type);

	P->page_ID = Str__new();
	WRITE_TO(P->page_ID, "P");
	Filenames__write_unextended_leafname(P->page_ID, F);
	LOOP_THROUGH_TEXT(pos, P->page_ID) {
		wchar_t c = Str__get(pos);
		if ((c == '-') || (c == ' ')) Str__put(pos, '_');
	}

	ADD_TO_LL(B, P, ebook_page);
	return P;
}

void Epub__note_image(ebook *B, filename *F) {
	ebook_image *I = CREATE(ebook_image);
	I->relative_URL = F;
	I->image_ID = Str__new();
	Filenames__write_unextended_leafname(I->image_ID, F);
	ADD_TO_LL(B, I, ebook_image);
}

ebook_volume *Epub__starts_volume(ebook *B, ebook_page *P, char *title) {
	ebook_volume *V = CREATE(ebook_volume);
	V->volume_starts = P;
	P->in_volume = V;
	V->volume_title = Str__new_from_ISO_string(title);
	B->current_volume = V;
	ADD_TO_LL(B, V, ebook_volume);
	return V;
}

ebook_chapter *Epub__starts_chapter(ebook *B, ebook_page *P, char *title) {
	ebook_chapter *C = CREATE(ebook_chapter);
	C->chapter_starts = P;
	C->in_volume = B->current_volume;
	P->in_chapter = C;
	C->chapter_title = Str__new_from_ISO_string(title);
	B->current_chapter = C;
	ADD_TO_LL(B, C, ebook_chapter);
	return C;
}

#line 215 "inlib/Chapter 5/Epub Ebooks.w"
pathname *Epub__begin_construction(ebook *B, pathname *P, filename *cover_image) {
	if (Pathnames__create_in_file_system(P) == FALSE) return NULL;

	TEMPORARY_TEXT(TEMP)
	WRITE_TO(TEMP, "%S.epub", Epub__get_metadata(B, L"title"));
	B->eventual_epub = Filenames__in_folder_S(P, TEMP);
	DISCARD_TEXT(TEMP)

	pathname *Holder = Pathnames__subfolder(P, "ePub");
	if (Pathnames__create_in_file_system(Holder) == FALSE) return NULL;
	B->holder = Holder;

	
{
#line 239 "inlib/Chapter 5/Epub Ebooks.w"
	filename *Mimetype = Filenames__in_folder(Holder, "mimetype");
	text_stream EM_struct; text_stream *OUT = &EM_struct;
	if (STREAM_OPEN_TO_FILE(OUT, Mimetype, ISO_ENC) == FALSE)
		Errors__fatal_with_file("unable to open mimetype file for output: %f",
			Mimetype);
	WRITE("application/epub+zip"); /* EPUB requires there be no newline here */
	STREAM_CLOSE(OUT);

}
#line 227 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 250 "inlib/Chapter 5/Epub Ebooks.w"
	pathname *META_INF = Pathnames__subfolder(Holder, "META-INF");
	if (Pathnames__create_in_file_system(META_INF) == FALSE) return NULL;
	filename *container = Filenames__in_folder(META_INF, "container.xml");
	text_stream C_struct; text_stream *OUT = &C_struct;
	if (STREAM_OPEN_TO_FILE(OUT, container, ISO_ENC) == FALSE)
		Errors__fatal_with_file("unable to open container file for output: %f",
			container);
	WRITE("<?xml version=\"1.0\"?>\n");
	WRITE("<container version=\"1.0\" xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\">\n");
	INDENT;
	WRITE("<rootfiles>\n");
	INDENT;
	WRITE("<rootfile full-path=\"OEBPS/content.opf\" media-type=\"application/oebps-package+xml\" />\n");
	OUTDENT;
	WRITE("</rootfiles>\n");
	OUTDENT;
	WRITE("</container>\n");
	STREAM_CLOSE(OUT);

}
#line 228 "inlib/Chapter 5/Epub Ebooks.w"
;
	pathname *OEBPS = Pathnames__subfolder(Holder, "OEBPS");
	if (Pathnames__create_in_file_system(OEBPS) == FALSE) return NULL;
	if (cover_image) 
{
#line 276 "inlib/Chapter 5/Epub Ebooks.w"
	filename *cover = Filenames__in_folder(OEBPS, "cover.html");
	text_stream C_struct; text_stream *OUT = &C_struct;
	if (STREAM_OPEN_TO_FILE(OUT, cover, ISO_ENC) == FALSE)
		Errors__fatal_with_file("unable to open cover file for output: %f",
			cover);

	Epub__note_page(B, cover_image, "Cover", "cover");

	HTML__declare_as_HTML(OUT, TRUE);
	HTML__begin_head(OUT, NULL);
	HTML__open(OUT, "title");
	WRITE("Cover");
	HTML__close(OUT, "title");
	WRITE("<style type=\"text/css\"> img { max-width: 100%%; } </style>\n");
	HTML__end_head(OUT);
	HTML__begin_body(OUT, NULL);
	HTML__begin_div_with_id(OUT, "cover-image");
	WRITE("<img src=\"%/f\" alt=\"%S\"/>\n", cover_image, Epub__get_metadata(B, L"title"));
	HTML__end_div(OUT);
	HTML__end_body(OUT);
	HTML__completed(OUT);
	STREAM_CLOSE(OUT);

}
#line 231 "inlib/Chapter 5/Epub Ebooks.w"
;
	B->OEBPS_path = OEBPS;
	return OEBPS;
}

#line 302 "inlib/Chapter 5/Epub Ebooks.w"
void Epub__end_construction(ebook *B) {
	
{
#line 312 "inlib/Chapter 5/Epub Ebooks.w"
	text_stream *datestamp = Epub__ensure_metadata(B, L"date");
	if (Str__len(datestamp) == 0) {
		struct tm *the_present = NULL;
		time_t now = time(NULL);
		the_present = localtime(&now);
		WRITE_TO(datestamp, "%04d-%02d-%02d", the_present->tm_year + 1900,
			(the_present->tm_mon)+1, the_present->tm_mday);
	}

	TEMPORARY_TEXT(TEMP)
	WRITE_TO(TEMP, "urn:www.inform7.com:");
	text_stream *identifier = Epub__ensure_metadata(B, L"identifier");
	if (Str__len(identifier) == 0)
		WRITE_TO(TEMP, "%S", Epub__get_metadata(B, L"title"));
	else
		WRITE_TO(TEMP, "%S", identifier);
	Str__copy(identifier, TEMP);
	DISCARD_TEXT(TEMP)

	text_stream *lang = Epub__ensure_metadata(B, L"language");
	if (Str__len(lang) == 0) WRITE_TO(lang, "en-UK");

}
#line 303 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 337 "inlib/Chapter 5/Epub Ebooks.w"
	filename *content = Filenames__in_folder(B->OEBPS_path, "content.opf");
	text_stream C_struct; text_stream *OUT = &C_struct;
	if (STREAM_OPEN_TO_FILE(OUT, content, UTF8_ENC) == FALSE)
		Errors__fatal_with_file("unable to open content file for output: %f",
			content);

	WRITE("<?xml version='1.0' encoding='utf-8'?>\n");
	WRITE("<package xmlns=\"http://www.idpf.org/2007/opf\"\n");
	WRITE("xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n");
	WRITE("unique-identifier=\"bookid\" version=\"2.0\">\n"); INDENT;
	
{
#line 359 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<metadata>\n"); INDENT;
	for (ebook_datum *D = B->metadata_list; D; D = D->next_metadatum) {
		WRITE("<dc:%S", D->key);
		if (Str__eq_C_string(D->key, L"identifier")) WRITE(" id=\"bookid\"");
		WRITE(">");
		WRITE("%S</dc:%S>\n", D->value, D->key);
	}
	WRITE("<meta name=\"cover\" content=\"cover-image\" />\n");
	OUTDENT; WRITE("</metadata>\n");

}
#line 347 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 372 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<manifest>\n"); INDENT;
	WRITE("<item id=\"ncx\" href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\"/>\n");
	
{
#line 382 "inlib/Chapter 5/Epub Ebooks.w"
	if (B->CSS_file)
		WRITE("<item id=\"css\" href=\"%S\" media-type=\"text/css\"/>\n",
			Filenames__get_leafname(B->CSS_file));

}
#line 374 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 389 "inlib/Chapter 5/Epub Ebooks.w"
	for (ebook_page *P = B->ebook_page_list; P; P = P->next_ebook_page)
		WRITE("<item id=\"%S\" href=\"%S\" media-type=\"application/xhtml+xml\"/>\n",
			P->page_ID, Filenames__get_leafname(P->relative_URL));

}
#line 375 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 396 "inlib/Chapter 5/Epub Ebooks.w"
	for (ebook_image *I = B->ebook_image_list; I; I = I->next_ebook_image) {
		char *image_type = "";
		switch (Filenames__guess_format(I->relative_URL)) {
			case FORMAT_PERHAPS_PNG: image_type = "png"; break;
			case FORMAT_PERHAPS_JPEG: image_type = "jpeg"; break;
			case FORMAT_PERHAPS_SVG: image_type = "svg"; break;
			case FORMAT_PERHAPS_GIF: image_type = "gif"; break;
			default: Errors__nowhere("image not .gif, .png, .jpg or .svg"); break;
		}
		WRITE("<item id=\"%S\" href=\"%S\" media-type=\"image/%s\"/>\n",
			I->image_ID, Filenames__get_leafname(I->relative_URL), image_type);
	}

}
#line 376 "inlib/Chapter 5/Epub Ebooks.w"
;
	OUTDENT; WRITE("</manifest>\n");

}
#line 348 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 412 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<spine toc=\"ncx\">\n"); INDENT;
	for (ebook_page *P = B->ebook_page_list; P; P = P->next_ebook_page) {
		WRITE("<itemref idref=\"%S\"", P->page_ID);
		if (Str__len(P->page_type) > 0) WRITE(" linear=\"no\"");
		WRITE("/>\n");
	}
	OUTDENT; WRITE("</spine>\n");

}
#line 349 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 423 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<guide>\n"); INDENT;
	for (ebook_page *P = B->ebook_page_list; P; P = P->next_ebook_page) {
		if (Str__len(P->page_type) > 0) {
			WRITE("<reference href=\"%S\" type=\"%S\" title=\"%S\"/>\n",
				Filenames__get_leafname(P->relative_URL), P->page_type, P->page_title);
		}
	}
	OUTDENT; WRITE("</guide>\n");

}
#line 350 "inlib/Chapter 5/Epub Ebooks.w"
;
	OUTDENT; WRITE("</package>\n");

	STREAM_CLOSE(OUT);

}
#line 304 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 437 "inlib/Chapter 5/Epub Ebooks.w"
	filename *toc = Filenames__in_folder(B->OEBPS_path, "toc.ncx");
	text_stream C_struct; text_stream *OUT = &C_struct;
	if (STREAM_OPEN_TO_FILE(OUT, toc, UTF8_ENC) == FALSE)
		Errors__fatal_with_file("unable to open ncx file for output: %f",
			toc);

	WRITE("<?xml version='1.0' encoding='utf-8'?>\n");
	WRITE("<!DOCTYPE ncx PUBLIC \"-//NISO//DTD ncx 2005-1//EN\"\n");
	WRITE("	\"http://www.daisy.org/z3986/2005/ncx-2005-1.dtd\">\n");
	WRITE("<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n");

	int depth = 1; /* there are surely at least sections */
	if (B->ebook_chapter_list) depth = 2;
	if (B->ebook_volume_list) depth = 3;

	
{
#line 461 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<head>\n"); INDENT;
	WRITE("<meta name=\"dtb:uid\" content=\"%S\"/>\n", Epub__get_metadata(B, L"identifier"));
	WRITE("<meta name=\"dtb:depth\" content=\"%d\"/>\n", depth);
	WRITE("<meta name=\"dtb:totalPageCount\" content=\"0\"/>\n");
	WRITE("<meta name=\"dtb:maxPageNumber\" content=\"0\"/>\n");
	OUTDENT; WRITE("</head>\n");
	WRITE("<docTitle>\n"); INDENT;
	WRITE("<text>%S</text>\n", Epub__get_metadata(B, L"title"));
	OUTDENT; WRITE("</docTitle>\n");

}
#line 452 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 474 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<navMap>\n"); INDENT;
	int navpoint_count = 1;
	int navmap_depth = 1;
	int phase = 0;
	
{
#line 496 "inlib/Chapter 5/Epub Ebooks.w"
	for (ebook_page *P = B->ebook_page_list; P; P = P->next_ebook_page) {
		int in_phase = 1;
		if ((Str__eq_C_string(P->page_ID, L"cover")) ||
			(Str__eq_C_string(P->page_ID, L"index")))
			in_phase = 0;
		if ((in_phase == phase) && (P->nav_entry_written == FALSE)) {
			
{
#line 539 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n", navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 502 "inlib/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel> <content src=\"%S\"/>\n",
				P->page_title, Filenames__get_leafname(P->relative_URL));
			
{
#line 546 "inlib/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 505 "inlib/Chapter 5/Epub Ebooks.w"
;
		}
	}

}
#line 478 "inlib/Chapter 5/Epub Ebooks.w"
;
	ebook_volume *V = NULL;
	for (V = B->ebook_volume_list; V; V = V->next_ebook_volume) {
		
{
#line 539 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n", navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 481 "inlib/Chapter 5/Epub Ebooks.w"
;
		WRITE("<navLabel><text>%S</text></navLabel>", V->volume_title);
		WRITE("<content src=\"%S\"/>\n", Filenames__get_leafname(V->volume_starts->relative_URL));
		
{
#line 512 "inlib/Chapter 5/Epub Ebooks.w"
	ebook_chapter *C = NULL;
	for (C = B->ebook_chapter_list; C; C = C->next_ebook_chapter)
		if (C->in_volume == V) {
			
{
#line 539 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n", navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 515 "inlib/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel>", C->chapter_title);
			WRITE("<content src=\"%S\"/>\n", Filenames__get_leafname(C->chapter_starts->relative_URL));
			
{
#line 526 "inlib/Chapter 5/Epub Ebooks.w"
	for (ebook_page *P = B->ebook_page_list; P; P = P->next_ebook_page) {
		if ((P->in_chapter == C) && (P->nav_entry_written == FALSE)) {
			
{
#line 539 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n", navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 528 "inlib/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel>", P->page_title);
			WRITE("<content src=\"%S\"/>\n", Filenames__get_leafname(P->relative_URL));
			
{
#line 546 "inlib/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 531 "inlib/Chapter 5/Epub Ebooks.w"
;
			P->nav_entry_written = TRUE;
		}
	}

}
#line 518 "inlib/Chapter 5/Epub Ebooks.w"
;
			
{
#line 546 "inlib/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 519 "inlib/Chapter 5/Epub Ebooks.w"
;
		}
	
{
#line 526 "inlib/Chapter 5/Epub Ebooks.w"
	for (ebook_page *P = B->ebook_page_list; P; P = P->next_ebook_page) {
		if ((P->in_chapter == C) && (P->nav_entry_written == FALSE)) {
			
{
#line 539 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n", navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 528 "inlib/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel>", P->page_title);
			WRITE("<content src=\"%S\"/>\n", Filenames__get_leafname(P->relative_URL));
			
{
#line 546 "inlib/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 531 "inlib/Chapter 5/Epub Ebooks.w"
;
			P->nav_entry_written = TRUE;
		}
	}

}
#line 521 "inlib/Chapter 5/Epub Ebooks.w"
;

}
#line 484 "inlib/Chapter 5/Epub Ebooks.w"
;
		
{
#line 546 "inlib/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 485 "inlib/Chapter 5/Epub Ebooks.w"
;
	}
	
{
#line 512 "inlib/Chapter 5/Epub Ebooks.w"
	ebook_chapter *C = NULL;
	for (C = B->ebook_chapter_list; C; C = C->next_ebook_chapter)
		if (C->in_volume == V) {
			
{
#line 539 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n", navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 515 "inlib/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel>", C->chapter_title);
			WRITE("<content src=\"%S\"/>\n", Filenames__get_leafname(C->chapter_starts->relative_URL));
			
{
#line 526 "inlib/Chapter 5/Epub Ebooks.w"
	for (ebook_page *P = B->ebook_page_list; P; P = P->next_ebook_page) {
		if ((P->in_chapter == C) && (P->nav_entry_written == FALSE)) {
			
{
#line 539 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n", navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 528 "inlib/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel>", P->page_title);
			WRITE("<content src=\"%S\"/>\n", Filenames__get_leafname(P->relative_URL));
			
{
#line 546 "inlib/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 531 "inlib/Chapter 5/Epub Ebooks.w"
;
			P->nav_entry_written = TRUE;
		}
	}

}
#line 518 "inlib/Chapter 5/Epub Ebooks.w"
;
			
{
#line 546 "inlib/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 519 "inlib/Chapter 5/Epub Ebooks.w"
;
		}
	
{
#line 526 "inlib/Chapter 5/Epub Ebooks.w"
	for (ebook_page *P = B->ebook_page_list; P; P = P->next_ebook_page) {
		if ((P->in_chapter == C) && (P->nav_entry_written == FALSE)) {
			
{
#line 539 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n", navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 528 "inlib/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel>", P->page_title);
			WRITE("<content src=\"%S\"/>\n", Filenames__get_leafname(P->relative_URL));
			
{
#line 546 "inlib/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 531 "inlib/Chapter 5/Epub Ebooks.w"
;
			P->nav_entry_written = TRUE;
		}
	}

}
#line 521 "inlib/Chapter 5/Epub Ebooks.w"
;

}
#line 487 "inlib/Chapter 5/Epub Ebooks.w"
;
	phase = 1;
	
{
#line 496 "inlib/Chapter 5/Epub Ebooks.w"
	for (ebook_page *P = B->ebook_page_list; P; P = P->next_ebook_page) {
		int in_phase = 1;
		if ((Str__eq_C_string(P->page_ID, L"cover")) ||
			(Str__eq_C_string(P->page_ID, L"index")))
			in_phase = 0;
		if ((in_phase == phase) && (P->nav_entry_written == FALSE)) {
			
{
#line 539 "inlib/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n", navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 502 "inlib/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel> <content src=\"%S\"/>\n",
				P->page_title, Filenames__get_leafname(P->relative_URL));
			
{
#line 546 "inlib/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 505 "inlib/Chapter 5/Epub Ebooks.w"
;
		}
	}

}
#line 489 "inlib/Chapter 5/Epub Ebooks.w"
;
	OUTDENT; WRITE("</navMap>\n");
	if (navmap_depth != 1) internal_error("navMap numbering unbalanced");

}
#line 453 "inlib/Chapter 5/Epub Ebooks.w"
;
	WRITE("</ncx>\n");

	STREAM_CLOSE(OUT);

}
#line 305 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 553 "inlib/Chapter 5/Epub Ebooks.w"
	pathname *up = Pathnames__from_string("..");
	filename *ePub_relative =
		Filenames__in_folder_S(up, Filenames__get_leafname(B->eventual_epub));
	
{
#line 562 "inlib/Chapter 5/Epub Ebooks.w"
	TEMPORARY_TEXT(COMMAND)
	Shell__plain(COMMAND, "cd ");
	Shell__quote_path(COMMAND, B->holder);
	Shell__plain(COMMAND, "; zip -0Xq ");
	Shell__quote_file(COMMAND, ePub_relative);
	Shell__plain(COMMAND, " mimetype");
	Shell__run(COMMAND);
	DISCARD_TEXT(COMMAND)

}
#line 556 "inlib/Chapter 5/Epub Ebooks.w"
;
	
{
#line 574 "inlib/Chapter 5/Epub Ebooks.w"
	TEMPORARY_TEXT(COMMAND)
	Shell__plain(COMMAND, "cd ");
	Shell__quote_path(COMMAND, B->holder);
	Shell__plain(COMMAND, "; zip -Xr9Dq ");
	Shell__quote_file(COMMAND, ePub_relative);
	Shell__plain(COMMAND, " *");
	Shell__run(COMMAND);
	DISCARD_TEXT(COMMAND)

}
#line 557 "inlib/Chapter 5/Epub Ebooks.w"
;

}
#line 306 "inlib/Chapter 5/Epub Ebooks.w"
;
}

#line 10 "inlib/Chapter 6/Binary Files.w"
int BinaryFiles__read_int8(FILE *binary_file, unsigned int *result) {
    int c1 = getc(binary_file);
    if (c1 == EOF) return FALSE;

    *result = (unsigned int) c1;
    return TRUE;
}

int BinaryFiles__read_int16(FILE *binary_file, unsigned int *result) {
    int c1, c2;

    c1 = getc(binary_file);
    c2 = getc(binary_file);
    if (c1 == EOF || c2 == EOF) return FALSE;

    *result = (((unsigned int) c1) << 8) + ((unsigned int) c2);
    return TRUE;
}

int BinaryFiles__read_int32(FILE *binary_file, unsigned int *result) {
    int c1, c2, c3, c4;

    c1 = getc(binary_file);
    c2 = getc(binary_file);
    c3 = getc(binary_file);
    c4 = getc(binary_file);
    if (c1 == EOF || c2 == EOF || c3 == EOF || c4 == EOF) return FALSE;

    *result = (((unsigned int) c1) << 24) +
    			(((unsigned int) c2) << 16) +
    			(((unsigned int) c3) << 8) + ((unsigned int) c4);
    return TRUE;
}

int BinaryFiles__read_int64(FILE *binary_file, unsigned long long *result) {
    int c1, c2, c3, c4, c5, c6, c7, c8;

    c1 = getc(binary_file);
    c2 = getc(binary_file);
    c3 = getc(binary_file);
    c4 = getc(binary_file);
    c5 = getc(binary_file);
    c6 = getc(binary_file);
    c7 = getc(binary_file);
    c8 = getc(binary_file);
    if (c1 == EOF || c2 == EOF || c3 == EOF || c4 == EOF || c5 == EOF
    	|| c6 == EOF || c7 == EOF || c8 == EOF) return FALSE;

    *result = (((unsigned long long) c1) << 56) +
               (((unsigned long long) c2) << 48) +
               (((unsigned long long) c3) << 40) +
               (((unsigned long long) c4) << 32) +
               (((unsigned long long) c5) << 24) +
               (((unsigned long long) c6) << 16) +
               (((unsigned long long) c7) << 8) +
                ((unsigned long long) c8);
    return TRUE;
}

#line 73 "inlib/Chapter 6/Binary Files.w"
void BinaryFiles__swap_bytes32(unsigned int *value) {
    unsigned int result = (((*value & 0xff) << 24) +
                            ((*value & 0xff00) << 8) +
                            ((*value & 0xff0000) >> 8) +
                            ((*value & 0xff000000) >> 24 ) );
    *value = result;
}

void BinaryFiles__swap_bytes64(unsigned long long *value) {
    unsigned long long result = (((*value & 0xff) << 56) +
                                  ((*value & 0xff00) << 40) +
                                  ((*value & 0xff0000) << 24) +
                                  ((*value & 0xff000000) << 8) +
                                  ((*value >> 8)  & 0xff000000) +
                                  ((*value >> 24) & 0xff0000) +
                                  ((*value >> 40) & 0xff00) +
                                  ((*value >> 56) & 0xff) );
    *value = result;
}

#line 99 "inlib/Chapter 6/Binary Files.w"
int BinaryFiles__read_variable_length_integer(FILE *binary_file, unsigned int *result) {
    int c;

    *result = 0;
    do {
        c = getc(binary_file);
        if (c == EOF) return FALSE;
        *result = (*result << 7) + (((unsigned char) c) & 0x7F);
    } while  (((unsigned char) c) & 0x80);

    return TRUE;
}

#line 116 "inlib/Chapter 6/Binary Files.w"
int BinaryFiles__read_float80(FILE *binary_file, unsigned int *result) {
    int c1, c2, exp;
    unsigned int prev = 0, mantissa;

    c1 = getc(binary_file);
    c2 = getc(binary_file);
    if (c1 == EOF || c2 == EOF) return FALSE;
    if (!BinaryFiles__read_int32(binary_file, &mantissa)) return FALSE;

    exp = 30 - c2;
    while  (exp--) {
        prev = mantissa;
        mantissa >>= 1;
    }
    if (prev & 1) mantissa++;

    *result = (unsigned int) mantissa;
    return TRUE;
}

#line 141 "inlib/Chapter 6/Binary Files.w"
int BinaryFiles__read_string(FILE *binary_file, char *string, unsigned int length) {
    if (length > 0) {
        if (fread(string, 1, length, binary_file) != length) return FALSE;
    }
    string[length] = 0;

    return TRUE;
}

#line 153 "inlib/Chapter 6/Binary Files.w"
long int BinaryFiles__size(filename *F) {
	FILE *TEST_FILE = BinaryFiles__try_to_open_for_reading(F);
	if (TEST_FILE) {
		if (fseek(TEST_FILE, 0, SEEK_END) == 0) {
			long int file_size = ftell(TEST_FILE);
			if (file_size == -1L) Errors__fatal_with_file("ftell failed on linked file", F);
			BinaryFiles__close(TEST_FILE);
			return file_size;
		} else Errors__fatal_with_file("fseek failed on linked file", F);
		BinaryFiles__close(TEST_FILE);
	}
	return -1L;
}

#line 170 "inlib/Chapter 6/Binary Files.w"
FILE *BinaryFiles__open_for_reading(filename *F) {
	FILE *handle = Platform__iso_fopen(F, "rb");
	if (handle == NULL) Errors__fatal_with_file("unable to read file", F);
	return handle;
}

FILE *BinaryFiles__try_to_open_for_reading(filename *F) {
	return Platform__iso_fopen(F, "rb");
}

FILE *BinaryFiles__open_for_writing(filename *F) {
	FILE *handle = Platform__iso_fopen(F, "wb");
	if (handle == NULL) Errors__fatal_with_file("unable to write file", F);
	return handle;
}

FILE *BinaryFiles__try_to_open_for_writing(filename *F) {
	return Platform__iso_fopen(F, "wb");
}

void BinaryFiles__close(FILE *handle) {
	fclose(handle);
}

#line 199 "inlib/Chapter 6/Binary Files.w"
int BinaryFiles__copy(filename *from, filename *to, int suppress_error) {
	if ((from == NULL) || (to == NULL))
		Errors__fatal("files confused in copier");

	FILE *FROM = BinaryFiles__try_to_open_for_reading(from);
	if (FROM == NULL) {
		if (suppress_error == FALSE) Errors__fatal_with_file("unable to read file", from);
		return -1;
	}
	FILE *TO = BinaryFiles__try_to_open_for_writing(to);
	if (TO == NULL) {
		if (suppress_error == FALSE) Errors__fatal_with_file("unable to write to file", to);
		return -1;
	}

	int size = 0;
	while (TRUE) {
		int c = fgetc(FROM);
		if (c == EOF) break;
		size++;
		putc(c, TO);
	}

	BinaryFiles__close(FROM); BinaryFiles__close(TO);
	return size;
}

#line 27 "inlib/Chapter 6/Image Dimensions.w"
int ImageFiles__get_JPEG_dimensions(FILE *JPEG_file, unsigned int *width, unsigned int *height) {
    unsigned int sig, length;
    int marker;

    if (!BinaryFiles__read_int16(JPEG_file, &sig)) return FALSE;
    if (sig != 0xFFD8) return FALSE; /* |0xFF| (marker) then |0xD8| (SOI) */

    do {
        do {
            marker = getc(JPEG_file);
            if (marker == EOF) return FALSE;
        } while (marker != 0xff); /* skip to next |0xFF| byte */

        do {
            marker = getc(JPEG_file);
        } while (marker == 0xff); /* skip to next non |FF| byte */

        if (!BinaryFiles__read_int16(JPEG_file, &length)) return FALSE; /* length of marker */

        switch(marker) {
        	/* all variant forms of "start of frame": e.g., |0xC0| is a baseline DCT image */
            case 0xc0:
            case 0xc1: case 0xc2: case 0xc3:
            case 0xc5: case 0xc6: case 0xc7:
            case 0xc9: case 0xca: case 0xcb:
            case 0xcd: case 0xce: case 0xcf: {

 				/* fortunately these markers all then open with the same format */
                if (getc(JPEG_file) == EOF) return FALSE; /* skip 1 byte of data precision  */

                if (!BinaryFiles__read_int16(JPEG_file, height)) return FALSE;
                if (!BinaryFiles__read_int16(JPEG_file, width)) return FALSE;

                return TRUE;
            }
            default:
                if (fseek(JPEG_file, (long) (length - 2), SEEK_CUR) != 0) return FALSE; /* skip rest of marker */
        }
    }
    while (marker != EOF);

    return FALSE;
}

#line 80 "inlib/Chapter 6/Image Dimensions.w"
int ImageFiles__get_PNG_dimensions(FILE *PNG_file, unsigned int *width, unsigned int *height) {
    unsigned int sig1, sig2, length, type;

    /* Check PNG signature */
    if (!BinaryFiles__read_int32(PNG_file, &sig1)) return FALSE;
    if (!BinaryFiles__read_int32(PNG_file, &sig2)) return FALSE;
    if ((sig1 != 0x89504e47) || (sig2 != 0x0d0a1a0a)) return FALSE;

    /* Read first chunk */
    if (!BinaryFiles__read_int32(PNG_file, &length)) return FALSE;
    if (!BinaryFiles__read_int32(PNG_file, &type)) return FALSE;

    /* First chunk must be IHDR */
    if (type != 0x49484452) return FALSE;

    /* Width and height follow */
    if (!BinaryFiles__read_int32(PNG_file, width)) return FALSE;
    if (!BinaryFiles__read_int32(PNG_file, height)) return FALSE;
    return TRUE;
}

#line 15 "inlib/Chapter 6/Sound Durations.w"
int SoundFiles__get_AIFF_duration(FILE *pFile, unsigned int *pDuration,
	unsigned int *pBitsPerSecond, unsigned int *pChannels, unsigned int *pSampleRate) {
    unsigned int sig;
    unsigned int chunkID;
    unsigned int chunkLength;
    unsigned int numSampleFrames;
    unsigned int sampleSize;

    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;
    if (sig != 0x464F524D) return FALSE; /* |"FORM"| indicating an IFF file */

    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;

    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;
    if (sig != 0x41494646) return FALSE; /* |"AIFF"| indicating an AIFF file */

    /* Read chunks, skipping over those we are not interested in */
    while (TRUE) {
        if (!BinaryFiles__read_int32(pFile, &chunkID)) return FALSE;
        if (!BinaryFiles__read_int32(pFile, &chunkLength)) return FALSE;

        if (chunkID == 0x434F4D4D) { /* |"COMM"| indicates common AIFF data */
            if (chunkLength < 18) return FALSE; /* Check we have enough data to read */

            if (!BinaryFiles__read_int16(pFile, pChannels))          return FALSE;
            if (!BinaryFiles__read_int32(pFile, &numSampleFrames))  return FALSE;
            if (!BinaryFiles__read_int16(pFile, &sampleSize))       return FALSE;
            if (!BinaryFiles__read_float80(pFile, pSampleRate))      return FALSE;

            if (*pSampleRate == 0) return FALSE; /* Sanity check to avoid a divide by zero */

            /* Result is in centiseconds */
            *pDuration = (unsigned int) (((unsigned long long) numSampleFrames * 100) / *pSampleRate);
            *pBitsPerSecond = *pSampleRate * *pChannels * sampleSize;
            break;
        } else {
            /* Skip unwanted chunk */
            if (fseek(pFile, (long) chunkLength, SEEK_CUR) != 0) return FALSE;
        }
    }

	return TRUE;
}

#line 62 "inlib/Chapter 6/Sound Durations.w"
int SoundFiles__get_OggVorbis_duration(FILE *pFile, unsigned int *pDuration,
	unsigned int *pBitsPerSecond, unsigned int *pChannels, unsigned int *pSampleRate) {
    unsigned int sig;
    unsigned int version;
    unsigned int numSegments;
    unsigned int packetType;
    unsigned int vorbisSig1;
    unsigned int vorbisSig2;
    unsigned int seekPos;
    unsigned int fileLength, bytesToRead, lastSig, index;
    unsigned long long granulePosition;
    unsigned char buffer[256];

    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;
    if (sig != 0x4F676753) return FALSE; /* |"OggS"| indicating an OGG file */

    /* Check OGG version is zero */
    if (!BinaryFiles__read_int8(pFile, &version)) return FALSE;
    if (version != 0) return FALSE;

    /* Skip header type, granule position, serial number, page sequence and CRC */
    if (fseek(pFile, 21, SEEK_CUR) != 0) return FALSE;

    /* Read number of page segments */
    if (!BinaryFiles__read_int8(pFile, &numSegments)) return FALSE;

    /* Skip segment table */
    if (fseek(pFile, (long) numSegments, SEEK_CUR) != 0) return FALSE;

    /* Vorbis Identification header */
    if (!BinaryFiles__read_int8(pFile, &packetType)) return FALSE;
    if (packetType != 1) return FALSE;

    if (!BinaryFiles__read_int32(pFile, &vorbisSig1)) return FALSE;
    if (vorbisSig1 != 0x766F7262) return FALSE;   /* |"VORB"| */

    if (!BinaryFiles__read_int16(pFile, &vorbisSig2)) return FALSE;
    if (vorbisSig2 != 0x6973) return FALSE;   /* |"IS"| */

    /* Check Vorbis version is zero */
    if (!BinaryFiles__read_int32(pFile, &version)) return FALSE;
    if (version != 0) return FALSE;

    /* Read number of channels */
    if (!BinaryFiles__read_int8(pFile, pChannels)) return FALSE;

    /* Read sample rate */
    if (!BinaryFiles__read_int32(pFile, pSampleRate)) return FALSE;
    BinaryFiles__swap_bytes32(pSampleRate);  /* Ogg Vorbis uses LSB first */

    /* Skip bitrate maximum */
    if (fseek(pFile, 4, SEEK_CUR) != 0) return FALSE;

    /* Read Nominal Bitrate */
    if (!BinaryFiles__read_int32(pFile, pBitsPerSecond)) return FALSE;
    BinaryFiles__swap_bytes32(pBitsPerSecond);  /* Ogg Vorbis uses LSB first */

    /* Encoders can be unhelpful and give no bitrate in the header */
    if (pBitsPerSecond == 0) return FALSE;

    /* Search for the final Ogg page (near the end of the file) to read duration, */
    /* i.e., read the last 4K of the file and look for the final |"OggS"| sig */
    if (fseek(pFile, 0, SEEK_END) != 0) return FALSE;
    fileLength = (unsigned int) ftell(pFile);
    if (fileLength < 4096) seekPos = 0;
    else seekPos = fileLength - 4096;

    lastSig = 0xFFFFFFFF;
    while (seekPos < fileLength) {
        if (fseek(pFile, (long) seekPos, SEEK_SET) != 0) return FALSE;
        bytesToRead = fileLength - seekPos;
        if (bytesToRead > 256) bytesToRead = 256;
        if (fread(buffer, 1, bytesToRead, pFile) != bytesToRead) return FALSE;

        for(index = 0; index < bytesToRead; index++) {
            if ((buffer[index] == 0x4F) &&
                (buffer[index + 1] == 0x67) &&
                (buffer[index + 2] == 0x67) &&
                (buffer[index + 3] == 0x53)) {
                lastSig = seekPos + index;
            }
        }

        /* Next place to read from is 256 bytes further on, but to catch */
        /* sigs that span between these blocks, read the last four bytes again */
        seekPos += 256 - 4;
    }

    if (lastSig == 0xFFFFFFFF) return FALSE;

    if (fseek(pFile, (long) lastSig, SEEK_SET) != 0) return FALSE;
    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;
    if (sig != 0x4F676753) return FALSE; /* |"OggS"| indicating an OGG file */

    /* Check OGG version is zero */
    if (!BinaryFiles__read_int8(pFile, &version)) return FALSE;
    if (version != 0) return FALSE;

    /* Skip header Type */
    if (fseek(pFile, 1, SEEK_CUR) != 0) return FALSE;

    if (!BinaryFiles__read_int64(pFile, &granulePosition)) return FALSE;
    BinaryFiles__swap_bytes64(&granulePosition);

    *pDuration = (unsigned int) ((granulePosition * 100) /
			    	(unsigned long long) *pSampleRate);

    return TRUE;
}

#line 184 "inlib/Chapter 6/Sound Durations.w"
int SoundFiles__get_MIDI_information(FILE *pFile, unsigned int *pType,
	unsigned int *pNumTracks) {
    unsigned int sig;
    unsigned int length;
    unsigned int pulses;
    unsigned int frames_per_second;
    unsigned int subframes_per_frame;
    unsigned int clocks_per_second;
    unsigned int start_of_chunk_data;
    unsigned int status;
    unsigned int clocks;
    unsigned int sysex_length;
    unsigned int non_midi_event_length;
    unsigned int start_of_non_midi_data;
    unsigned int non_midi_event;

    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;

    /* |"RIFF"| indicating a RIFF file */
    if (sig == 0x52494646) {
        /* Skip the filesize and typeID */
        if (fseek(pFile, 8, SEEK_CUR) != 0) return FALSE;

        /* now read the real MIDI sig */
        if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;
    }

    /* |"MThd"| indicating a MIDI file */
    if (sig != 0x4D546864) return FALSE;

    /* Read length of chunk */
    if (!BinaryFiles__read_int32(pFile, &length)) return FALSE;

    /* Make sure we have enough data to read */
    if (length < 6) return FALSE;

    /* Read the MIDI type: 0,1 or 2 */
    /*   0 means one track containing up to 16 channels to make a single tune */
    /*   1 means one or more tracks, commonly each with a single channel, making up a single tune */
    /*   2 means one or more tracks, where each is a separate tune in it's own right */
    if (!BinaryFiles__read_int16(pFile, pType)) return FALSE;

    /* Read the number of tracks */
    if (!BinaryFiles__read_int16(pFile, pNumTracks)) return FALSE;

    /* Read "Pulses Per Quarter Note" (PPQN) */
    if (!BinaryFiles__read_int16(pFile, &pulses)) return FALSE;

    /* if top bit set, then number of subframes per second can be deduced */
    if (pulses >= 0x8000) {
        /* First byte is a negative number for the frames per second */
        /* Second byte is the number of subframes in each frame */
        frames_per_second    = (256 - (pulses & 0xff));
        subframes_per_frame  = (pulses >> 8);
        clocks_per_second    = frames_per_second * subframes_per_frame;
        LOG("frames_per_second   = %d\n",   frames_per_second);
        LOG("subframes_per_frame = %d\n", subframes_per_frame);
        LOG("clocks_per_second   = %d\n",   clocks_per_second);

        /* Number of pulses per quarter note unknown */
        pulses = 0;
    } else {
        /* unknown values */
        frames_per_second    = 0;
        subframes_per_frame  = 0;
        clocks_per_second    = 0;
        LOG("pulses per quarter note = %d\n",   pulses);
    }

    /* Skip any remaining bytes in the MThd chunk */
    if (fseek(pFile, (long) (length - 6), SEEK_CUR) != 0) return FALSE;

    /* Keep reading chunks, looking for |"MTrk"| */
    do {
        /* Read chunk signature and length */
        if (!BinaryFiles__read_int32(pFile, &sig)) {
            if (feof(pFile)) return TRUE;
            return FALSE;
        }
        if (!BinaryFiles__read_int32(pFile, &length)) return FALSE;

        start_of_chunk_data = (unsigned int) ftell(pFile);

        if (sig == 0x4D54726B) { /* |"MTrk"| */
            LOG("track starts\n");
            /* Read each event, looking for information before the real tune starts, e.g., tempo */
            do {
                /* Read the number of clocks since the previous event */
                if (!BinaryFiles__read_variable_length_integer(pFile, &clocks))
                	return FALSE;

                /* We bail out when the track starts */
                if (clocks > 0) break;

                /* Read the MIDI Status byte */
                if (!BinaryFiles__read_int8(pFile, &status)) return FALSE;

                /* Start or continuation of system exclusive data */
                if ((status == 0xF0) || (status == 0xF7)) {
                    /* Read length of system exclusive event data */
                    if (!BinaryFiles__read_variable_length_integer(pFile, &sysex_length)) return FALSE;

                    /* Skip sysex event */
                    if (fseek(pFile, (long) sysex_length, SEEK_CUR) != 0) return FALSE;
                } else if (status == 0xFF) { /* Non-MIDI event */
                    /* Read the Non-MIDI event type and length */
                    if (!BinaryFiles__read_int8(pFile, &non_midi_event)) return FALSE;
                    if (!BinaryFiles__read_variable_length_integer(pFile, &non_midi_event_length))
                    	return FALSE;

                    start_of_non_midi_data = (unsigned int) ftell(pFile);

                    switch(non_midi_event) {
                        case 0x01: /* Comment text */
                        case 0x02: /* Copyright text */
                        case 0x03: /* Track name */
                        case 0x04: { /* Instrument name */
                            char text[257];
                            if (!BinaryFiles__read_string(pFile, text, non_midi_event_length))
                            	return FALSE;
                            LOG("%d: %s\n", non_midi_event, text);
                            break;
                        }

                        case 0x51: /* Tempo change */
                        case 0x58: /* Time signature */
                        case 0x59: /* Key signature */
							break;
                    }

                    /* Skip non-midi event */
                    if (fseek(pFile,
                    	(long) (start_of_non_midi_data + non_midi_event_length), SEEK_SET) != 0)
                    	return FALSE;
                } else {
                    /* Real MIDI data found: we've read all we can so bail out at this point */
                    break;
                }
            }
            while (TRUE);
        }

        /* Seek to start of next chunk */
        if (fseek(pFile, (long) (start_of_chunk_data + length), SEEK_SET) != 0) return FALSE;

        /* Reached end of file */
        if (feof(pFile)) return TRUE;

        /* Did we try to seek beyond the end of the file? */
        unsigned int position_in_file = (unsigned int) ftell(pFile);
        if (position_in_file < (start_of_chunk_data + length)) return TRUE;
    }
    while (TRUE);

    return TRUE;
}

#line 56 "inweb/Chapter 1/Basics.w"
ALLOCATE_IN_ARRAYS(source_line, 1000)
ALLOCATE_INDIVIDUALLY(bibliographic_datum)
ALLOCATE_INDIVIDUALLY(c_structure)
ALLOCATE_INDIVIDUALLY(chapter)
ALLOCATE_INDIVIDUALLY(cweb_macro)
ALLOCATE_INDIVIDUALLY(function)
ALLOCATE_INDIVIDUALLY(hash_table_entry_usage)
ALLOCATE_INDIVIDUALLY(hash_table_entry)
ALLOCATE_INDIVIDUALLY(imported_header)
ALLOCATE_INDIVIDUALLY(macro_usage)
ALLOCATE_INDIVIDUALLY(nonterminal_variable)
ALLOCATE_INDIVIDUALLY(paragraph_tag)
ALLOCATE_INDIVIDUALLY(paragraph)
ALLOCATE_INDIVIDUALLY(preform_nonterminal)
ALLOCATE_INDIVIDUALLY(programming_language)
ALLOCATE_INDIVIDUALLY(tex_results)
ALLOCATE_INDIVIDUALLY(section)
ALLOCATE_INDIVIDUALLY(structure_dependence)
ALLOCATE_INDIVIDUALLY(structure_element)
ALLOCATE_INDIVIDUALLY(structure_permission)
ALLOCATE_INDIVIDUALLY(tangle_target)
ALLOCATE_INDIVIDUALLY(theme_tag)
ALLOCATE_INDIVIDUALLY(weave_format)
ALLOCATE_INDIVIDUALLY(weave_target)
ALLOCATE_INDIVIDUALLY(web)

#line 89 "inweb/Chapter 1/Basics.w"
char *extra_memory_needs[1] = {
	"none"
};

#line 43 "inweb/Chapter 1/Program Control.w"
pathname *path_to_inweb_materials = NULL; /* the materials pathname, including final separator */

string tex_configuration; /* read from configuration file, not command line */
string pdftex_configuration;
string open_configuration;

#line 52 "inweb/Chapter 1/Program Control.w"
int no_inweb_errors = 0;

#line 60 "inweb/Chapter 1/Program Control.w"
int main(int argc, char **argv) {
	printf("%s\n", INWEB_BUILD);

	
{
#line 81 "inweb/Chapter 1/Program Control.w"
	Inlib__start();
	Languages__create_programming_languages();
	Formats__create_weave_formats();

}
#line 63 "inweb/Chapter 1/Program Control.w"
;

	inweb_instructions args = Configuration__read(argc, argv);

	pathname *P = args.location_setting;
	P = Pathnames__subfolder(P, "inweb");
	P = Pathnames__subfolder(P, "Materials");
	path_to_inweb_materials = P;

	Configuration__read_configuration_file();
	Main__follow_instructions(&args);

	
{
#line 88 "inweb/Chapter 1/Program Control.w"
	Inlib__end();
	return (no_inweb_errors == 0)?0:1;

}
#line 75 "inweb/Chapter 1/Program Control.w"
;
}

#line 96 "inweb/Chapter 1/Program Control.w"
void Main__follow_instructions(inweb_instructions *ins) {
	if (ins->inweb_mode == NO_MODE) 
{
#line 106 "inweb/Chapter 1/Program Control.w"
	printf("A simple literate programming tool intended for medium-sized and large programs.\n");
	printf("Usage: inweb webname -action [-options] [target]\n");
	printf("  where 'webname' is a folder containing a web (an inweb project),\n");
	printf("  The most useful -action commands are:\n");
	printf("    -create: make a new web, creating its folder and contents\n");
	printf("    -tangle: make the program described in the web\n");
	printf("    -weave: make a human-readable booklet of the web\n");
	printf("  For options and less commonly used actions, see the inweb manual.\n");
	exit(0);

}
#line 97 "inweb/Chapter 1/Program Control.w"
;
	if (ins->inweb_mode == CREATE_MODE) 
{
#line 120 "inweb/Chapter 1/Program Control.w"
	pathname *Sections = Pathnames__subfolder(ins->chosen_web, "Sections");
	filename *Contents = Filenames__in_folder(path_to_inweb_materials, "Contents.w");
	filename *Main = Filenames__in_folder(path_to_inweb_materials, "Main.w");

	Pathnames__create_in_file_system(ins->chosen_web);
	Pathnames__create_in_file_system(Pathnames__subfolder(ins->chosen_web, "Figures"));
	Pathnames__create_in_file_system(Pathnames__subfolder(ins->chosen_web, "Materials"));
	Pathnames__create_in_file_system(Sections);
	Pathnames__create_in_file_system(Pathnames__subfolder(ins->chosen_web, "Tangled"));
	Pathnames__create_in_file_system(Pathnames__subfolder(ins->chosen_web, "Woven"));

	Shell__copy(Contents, path_to_inweb_materials, "-nv");
	Shell__copy(Main, Sections, "-nv");

}
#line 98 "inweb/Chapter 1/Program Control.w"

	else 
{
#line 137 "inweb/Chapter 1/Program Control.w"
	web *W = Reader__load_web(ins->chosen_web, ins->import_setting, ins->verbose_switch);
	Reader__print_web_statistics(W);
	if (ins->inweb_mode == ANALYSE_MODE) 
{
#line 146 "inweb/Chapter 1/Program Control.w"
	if (ins->swarm_mode != SWARM_OFF)
		Errors__fatal("only specific parts of the web can be analysed");
	if (ins->catalogue_switch) Analyser__catalogue_the_sections(W, ins->chosen_subweb, FALSE);
	if (ins->functions_switch) Analyser__catalogue_the_sections(W, ins->chosen_subweb, TRUE);
	if (ins->scan_switch) Reader__scan_line_categories(W, ins->chosen_subweb);

}
#line 139 "inweb/Chapter 1/Program Control.w"
;
	if (ins->inweb_mode == TANGLE_MODE) 
{
#line 167 "inweb/Chapter 1/Program Control.w"
	string tangle_leaf; CStrings__copy(tangle_leaf, "");

	tangle_target *tn = NULL;
	if (CStrings__eq(ins->chosen_subweb, "0")) {
		
{
#line 191 "inweb/Chapter 1/Program Control.w"
	tn = NULL;
	if (Bibliographic__data_exists(W, "Short Title"))
		CStrings__copy(tangle_leaf, Bibliographic__get_data(W, "Short Title"));
	else
		CStrings__copy(tangle_leaf, Bibliographic__get_data(W, "Title"));
	CStrings__concatenate(tangle_leaf, W->main_language->file_extension);

}
#line 171 "inweb/Chapter 1/Program Control.w"
;
	} else if (Reader__get_section_for_sigil(W, ins->chosen_subweb)) {
		
{
#line 201 "inweb/Chapter 1/Program Control.w"
	section *S = Reader__get_section_for_sigil(W, ins->chosen_subweb);
	tn = S->sect_target;
	if (tn == NULL) Errors__fatal("section cannot be independently tangled");
	Str__copy_to_ISO_string(tangle_leaf, Filenames__get_leafname(S->source_file_for_section),
		MAX_FILENAME_LENGTH);

}
#line 173 "inweb/Chapter 1/Program Control.w"
;
	} else {
		
{
#line 211 "inweb/Chapter 1/Program Control.w"
	chapter *C;
	LOOP_OVER(C, chapter)
		if (CStrings__eq(ins->chosen_subweb, C->ch_sigil)) {
			string found_text1;
			if (C->ch_target) {
				if (ISORegexp__match_1(C->ch_title, "%c+?: (%c+)", found_text1))
					CStrings__copy(tangle_leaf, found_text1);
				else
					CStrings__copy(tangle_leaf, C->ch_title);
				tn = C->ch_target;
				break;
			}
		}
	if (tn == NULL)
		Errors__fatal("only the entire web, or specific sections, can be tangled");

}
#line 175 "inweb/Chapter 1/Program Control.w"
;
	}
	if (tangle_leaf[0] == 0) { Errors__fatal("no tangle destination known"); }

	filename *tangle_to = ins->tangle_setting;
	if (tangle_to == NULL) {
		pathname *P = Pathnames__subfolder(W->path_to_web, "Tangled");
		tangle_to = Filenames__in_folder(P, tangle_leaf);
	}
	if (tn == NULL) tn = W->first_target;
	Tangler__go(W, tn, tangle_to);

}
#line 140 "inweb/Chapter 1/Program Control.w"
;
	if (ins->inweb_mode == WEAVE_MODE) 
{
#line 230 "inweb/Chapter 1/Program Control.w"
	Numbering__number_web(W);
	theme_tag *tag = Parser__tag_by_name(ins->theme_setting);
	if ((ins->theme_setting[0]) && (tag == NULL))
		Errors__fatal_with_C_string("no such theme as '%s'", ins->theme_setting);
	int r = Formats__begin_weaving(W, ins->weave_format);
	if (r != SWARM_OFF) ins->swarm_mode = r;
	if (ins->swarm_mode == SWARM_OFF) {
		int shall_we_open = ins->open_pdf_switch;
		if (shall_we_open == NOT_APPLICABLE) { /* i.e., if it wasn't set at the command line */
			if (CStrings__ne(open_configuration, "")) shall_we_open = TRUE;
			else shall_we_open = FALSE;
		}
		Swarm__weave_subset(W, ins->chosen_subweb, shall_we_open, tag, ins->weave_format);
	} else {
		Swarm__weave(W, ins->chosen_subweb, ins->swarm_mode, tag, ins->weave_format);
	}
	Formats__end_weaving(W, ins->weave_format);

}
#line 141 "inweb/Chapter 1/Program Control.w"
;

}
#line 99 "inweb/Chapter 1/Program Control.w"
;
}

#line 251 "inweb/Chapter 1/Program Control.w"
void Main__error_in_web(char *message, source_line *sl) {
	if (sl) {
		Errors__in_text_file(message, &(sl->source));
		fprintf(stderr, "%07d  %s\n", sl->source.line_count, sl->text);
	} else {
		Errors__in_text_file(message, NULL);
	}
}

#line 30 "inweb/Chapter 1/Configuration.w"

#line 34 "inweb/Chapter 1/Configuration.w"
inweb_instructions Configuration__read(int argc, char **argv) {
	inweb_instructions args;
	args.inweb_mode = NO_MODE;
	args.swarm_mode = SWARM_OFF;
	args.catalogue_switch = FALSE;
	args.functions_switch = FALSE;
	args.open_pdf_switch = NOT_APPLICABLE;
	args.scan_switch = FALSE;
	args.verbose_switch = FALSE;
	args.chosen_web = NULL;
	CStrings__copy(args.chosen_subweb, "0"); /* by default, the entire web is the target */
	args.tangle_setting = NULL;
	CStrings__copy(args.theme_setting, "");
	CStrings__copy(args.weave_format, "HTML");
	args.location_setting = NULL;
	args.import_setting = NULL;

	int i;
	int targets = 0;
	for (i=1; i<argc; i++) {
		char *opt = argv[i];
		int non_switch_follows = FALSE;
		if (i+1 < argc) {
			char *next_opt = argv[i+1];
			if (next_opt[0] != '-') non_switch_follows = TRUE;
		}
		if (opt[0] == '-') 
{
#line 74 "inweb/Chapter 1/Configuration.w"
	if (opt[1] == '-') opt++; /* allow a doubled-dash as equivalent to a single */
	if (CStrings__eq(opt, "-verbose")) {
		args.verbose_switch = TRUE; continue;
	}
	if (CStrings__eq(opt, "-at")) {
		if (non_switch_follows) {
			args.location_setting = Pathnames__from_command_line_argument(argv[i+1]);
			i++; continue;
		}
		Errors__fatal("-at must be followed by the pathname where inweb lives");
	}
	if (CStrings__eq(opt, "-import-from")) {
		if (non_switch_follows) {
			args.import_setting = Pathnames__from_command_line_argument(argv[i+1]);
			i++; continue;
		}
		Errors__fatal("-import must be followed by the pathname where imported webs live");
	}
	
{
#line 101 "inweb/Chapter 1/Configuration.w"
	if (CStrings__eq(opt, "-catalogue")) {
		args.catalogue_switch = TRUE; Configuration__enter_main_mode(&args, ANALYSE_MODE); continue;
	}
	if (CStrings__eq(opt, "-functions")) {
		args.functions_switch = TRUE; Configuration__enter_main_mode(&args, ANALYSE_MODE); continue;
	}
	if (CStrings__eq(opt, "-scan")) {
		args.scan_switch = TRUE; Configuration__enter_main_mode(&args, ANALYSE_MODE); continue;
	}

}
#line 92 "inweb/Chapter 1/Configuration.w"
;
	
{
#line 114 "inweb/Chapter 1/Configuration.w"
	if (CStrings__eq(opt, "-weave")) {
		Configuration__enter_main_mode(&args, WEAVE_MODE); continue;
	}
	if (CStrings__eq(opt, "-open")) {
		args.open_pdf_switch = TRUE; Configuration__enter_main_mode(&args, WEAVE_MODE); continue;
	}
	if (CStrings__eq(opt, "-closed")) {
		args.open_pdf_switch = FALSE; Configuration__enter_main_mode(&args, WEAVE_MODE); continue;
	}
	if (CStrings__eq(opt, "-format")) {
		if (non_switch_follows) {
			CStrings__copy(args.weave_format, argv[i+1]); i++;
			Configuration__enter_main_mode(&args, WEAVE_MODE);
			continue;
		}
		Errors__fatal("-format must be followed by a format name");
	}
	if (CStrings__eq(opt, "-theme")) {
		if (non_switch_follows) {
			CStrings__copy(args.theme_setting, argv[i+1]); i++;
			Configuration__enter_main_mode(&args, WEAVE_MODE);
			continue;
		}
		Errors__fatal("-theme must be followed by a chapter number or appendix letter");
	}

}
#line 93 "inweb/Chapter 1/Configuration.w"
;
	
{
#line 143 "inweb/Chapter 1/Configuration.w"
	if (CStrings__eq(opt, "-tangle")) {
		Configuration__enter_main_mode(&args, TANGLE_MODE); continue;
	}
	if (CStrings__eq(opt, "-tangle-to")) {
		if (non_switch_follows) {
			args.tangle_setting = Filenames__from_command_line_argument(argv[i+1]); i++;
			Configuration__enter_main_mode(&args, TANGLE_MODE); continue;
		}
		Errors__fatal("-tangle-to must be followed by a filename to write");
	}

}
#line 94 "inweb/Chapter 1/Configuration.w"
;
	
{
#line 158 "inweb/Chapter 1/Configuration.w"
	if (CStrings__eq(opt, "-create")) {
		Configuration__enter_main_mode(&args, CREATE_MODE); continue;
	}

}
#line 95 "inweb/Chapter 1/Configuration.w"
;
	Errors__fatal_with_C_string("unknown command line switch: %s", opt);

}
#line 60 "inweb/Chapter 1/Configuration.w"

		else {
			if (args.chosen_web == NULL)
				args.chosen_web = Pathnames__from_command_line_argument(opt);
			else 
{
#line 168 "inweb/Chapter 1/Configuration.w"
	if (CStrings__eq(opt, "index")) {
		args.swarm_mode = SWARM_INDEX;
	} else if (CStrings__eq(opt, "chapters")) {
		args.swarm_mode = SWARM_CHAPTERS;
	} else if (CStrings__eq(opt, "sections")) {
		args.swarm_mode = SWARM_SECTIONS;
	} else {
		if (++targets > 1) Errors__fatal("at most one target may be given");
		if (CStrings__eq(opt, "all")) {
			CStrings__copy(args.chosen_subweb, "0");
		} else if (((isalnum(opt[0])) && (opt[1] == 0)) || (ISORegexp__match_0(opt, "%i+/%i+"))) {
			CStrings__copy(args.chosen_subweb, opt);
			CStrings__set_char(args.chosen_subweb, 0, toupper(args.chosen_subweb[0]));
		} else {
			string message;
			CSTRING_WRITE(message, "target not recognised: %s", opt);
			Main__error_in_web(message, NULL);
			printf("The legal targets are:\n");
			printf("   all: complete web\n");
			printf("   P: all preliminaries\n");
			printf("   1: Chapter 1 (and so on)\n");
			printf("   A: Appendix A (and so on, up to Appendix O)\n");
			printf("   3/eg: section with abbreviated name \"3/eg\" (and so on)\n");
			printf("You can also, or instead, specify:\n");
			printf("   index: to weave an HTML page indexing the project\n");
			printf("   chapters: to weave all chapters as individual documents\n");
			printf("   sections: ditto with sections\n");
			exit(1);
		}
	}

}
#line 64 "inweb/Chapter 1/Configuration.w"
;
		}
	}
	if (args.chosen_web == NULL) args.inweb_mode = NO_MODE;
	return args;
}

#line 202 "inweb/Chapter 1/Configuration.w"
void Configuration__enter_main_mode(inweb_instructions *args, int new_mode) {
	if (args->inweb_mode == NO_MODE) args->inweb_mode = new_mode;
	if (args->inweb_mode != new_mode)
		Errors__fatal("can only do one at a time - weaving, tangling or analysing");
}

#line 214 "inweb/Chapter 1/Configuration.w"
void Configuration__read_configuration_file(void) {
	CStrings__copy(open_configuration, "");
	CStrings__copy(tex_configuration, "tex");
	CStrings__copy(pdftex_configuration, "pdftex");

	TextFiles__read_with_lines_to_ISO(
		Filenames__in_folder(path_to_inweb_materials, "inweb-configuration.txt"),
		"can't open configuration file",
		TRUE, Configuration__scan_config_line, NULL, NULL);
}

void Configuration__scan_config_line(char *line, text_file_position *tfp, void *unused_state) {
	char *p = line;
	while (ISORegexp__white_space(*p)) p++;
	if (p[0] == 0) return; /* skip blank lines */
	if (p[0] == '#') return; /* skip comment lines */
	int eq = 0, found = FALSE;
	for (eq = 0; p[eq]; eq++)
		if (p[eq] == '=') {
			found = TRUE;
			string setting; CStrings__copy(setting, p); CStrings__truncate(setting, eq);
			string value; CStrings__copy(value, "");
			int k = eq-1;
			while ((k>=0) && (ISORegexp__white_space(setting[k]))) CStrings__truncate(setting, k--);
			eq++;
			while (ISORegexp__white_space(p[eq])) eq++;
			CStrings__copy(value, p+eq);
			
{
#line 253 "inweb/Chapter 1/Configuration.w"
	if (CStrings__eq(setting, "tex")) CStrings__copy(tex_configuration, value);
	else if (CStrings__eq(setting, "pdftex")) CStrings__copy(pdftex_configuration, value);
	else if (CStrings__eq(setting, "open-command")) CStrings__copy(open_configuration, value);
	else {
		string message;
		CSTRING_WRITE(message, "inweb: bad configuration setting (%s)", setting);
		Main__error_in_web(message, NULL);
	}

}
#line 241 "inweb/Chapter 1/Configuration.w"
;
			break;
		}
	if (found == FALSE) {
		Errors__in_text_file("bad configuration line", tfp);
		fprintf(stderr, "  line: %s\n", line);
	}
}

#line 21 "inweb/Chapter 2/Bibliographic Data.w"

#line 30 "inweb/Chapter 2/Bibliographic Data.w"
int Bibliographic__datum_can_be_declared(web *W, char *key) {
	bibliographic_datum *bd = Bibliographic__look_up_datum(W, key);
	if (bd == NULL) return FALSE;
	return bd->declaration_permitted;
}

int Bibliographic__datum_on_or_off(web *W, char *key) {
	bibliographic_datum *bd = Bibliographic__look_up_datum(W, key);
	if (bd == NULL) return FALSE;
	return bd->on_or_off;
}

#line 46 "inweb/Chapter 2/Bibliographic Data.w"
void Bibliographic__initialise_data(web *W) {
	bibliographic_datum *bd;
	bd = Bibliographic__set_datum(W, "Inweb Build", INWEB_BUILD); bd->declaration_permitted = FALSE;

	bd = Bibliographic__set_datum(W, "Author", ""); bd->declaration_mandatory = TRUE;
	bd = Bibliographic__set_datum(W, "Language", ""); bd->declaration_mandatory = TRUE;
	bd = Bibliographic__set_datum(W, "Purpose", ""); bd->declaration_mandatory = TRUE;
	bd = Bibliographic__set_datum(W, "Title", ""); bd->declaration_mandatory = TRUE;

	bd = Bibliographic__set_datum(W, "License", "");
	bd->alias = Bibliographic__set_datum(W, "Licence", ""); /* alias US to UK spelling */

	Bibliographic__set_datum(W, "Short Title", "");
	Bibliographic__set_datum(W, "Capitalized Title", "");
	Bibliographic__set_datum(W, "Build Date", "");
	Bibliographic__set_datum(W, "Build Number", "");
	Bibliographic__set_datum(W, "Index Extras", "");
	Bibliographic__set_datum(W, "Index Template", "");

	bd = Bibliographic__set_datum(W, "Declare Section Usage", "On"); bd->on_or_off = TRUE;
	bd = Bibliographic__set_datum(W, "Namespaces", "Off"); bd->on_or_off = TRUE;
	bd = Bibliographic__set_datum(W, "Strict Usage Rules", "Off"); bd->on_or_off = TRUE;
}

#line 74 "inweb/Chapter 2/Bibliographic Data.w"
void Bibliographic__check_required_data(web *W) {
	bibliographic_datum *bd;
	LOOP_OVER_BIBLIOGRAPHIC_DATA(bd, W)
		if ((bd->declaration_mandatory) &&
			(bd->value[0] == 0))
				Errors__fatal_with_C_string(
					"The Contents.w section does not specify '%s: ...'", bd->key);
}

#line 87 "inweb/Chapter 2/Bibliographic Data.w"
char *Bibliographic__get_data(web *W, char *key) {
	bibliographic_datum *bd = Bibliographic__look_up_datum(W, key);
	if (bd) return bd->value;
	return "";
}

int Bibliographic__data_exists(web *W, char *key) {
	bibliographic_datum *bd = Bibliographic__look_up_datum(W, key);
	if ((bd) && (bd->value[0])) return TRUE;
	return FALSE;
}

bibliographic_datum *Bibliographic__look_up_datum(web *W, char *key) {
	bibliographic_datum *bd;
	LOOP_OVER_BIBLIOGRAPHIC_DATA(bd, W)
		if (CStrings__eq(key, bd->key)) {
			if (bd->alias) return bd->alias;
			return bd;
		}
	return NULL;
}

#line 114 "inweb/Chapter 2/Bibliographic Data.w"
bibliographic_datum *Bibliographic__set_datum(web *W, char *key, char *val) {
	bibliographic_datum *bd = Bibliographic__look_up_datum(W, key);
	if (bd == NULL) 
{
#line 126 "inweb/Chapter 2/Bibliographic Data.w"
	bd = CREATE(bibliographic_datum);
	CStrings__copy(bd->key, key);
	bd->declaration_mandatory = FALSE;
	bd->declaration_permitted = TRUE;
	bd->on_or_off = FALSE;
	bd->alias = NULL;
	bd->next_bd = W->first_bd;
	W->first_bd = bd;

}
#line 116 "inweb/Chapter 2/Bibliographic Data.w"
;
	CStrings__copy(bd->value, val);
	if (CStrings__eq(key, "Title")) 
{
#line 141 "inweb/Chapter 2/Bibliographic Data.w"
	string recapped; CStrings__copy(recapped, val);
	for (int i=0; recapped[i]; i++) CStrings__set_char(recapped, i, toupper(recapped[i]));
	Bibliographic__set_datum(W, "Capitalized Title", recapped);

}
#line 118 "inweb/Chapter 2/Bibliographic Data.w"
;
	return bd;
}

#line 35 "inweb/Chapter 2/Line Categories.w"

#line 39 "inweb/Chapter 2/Line Categories.w"
source_line *Lines__new_source_line(char *line, text_file_position *tfp) {
	source_line *sl = CREATE(source_line);
	sl->text = Memory__new_string(line);
	sl->text_operand = "";
	sl->text_operand2 = "";

	sl->category = NO_LCAT; /* that is, unknown category as yet */
	sl->command_code = NO_CMD;
	sl->is_commentary = FALSE;
	sl->function_defined = NULL;
	sl->preform_nonterminal_defined = NULL;
	sl->suppress_tangling = FALSE;
	sl->interface_line_identified = FALSE;

	if (tfp) sl->source = *tfp; else sl->source = TextFiles__nowhere();

	sl->owning_section = NULL;
	sl->next_line = NULL;
	sl->owning_paragraph = NULL;
	return sl;
}

#line 96 "inweb/Chapter 2/Line Categories.w"
char *Lines__category_name(int cat) {
	switch (cat) {
		case NO_LCAT: return "(uncategorised)";

		case BAR_LCAT: return "BAR";
		case BEGIN_DEFINITION_LCAT: return "BEGIN_DEFINITION";
		case BEGIN_VERBATIM_LCAT: return "BEGIN_CODE";
		case C_LIBRARY_INCLUDE_LCAT: return "C_LIBRARY_INCLUDE";
		case CHAPTER_HEADING_LCAT: return "CHAPTER_HEADING";
		case CODE_BODY_LCAT: return "CODE_BODY";
		case COMMAND_LCAT: return "COMMAND";
		case COMMENT_BODY_LCAT: return "COMMENT_BODY";
		case CONT_DEFINITION_LCAT: return "CONT_DEFINITION";
		case DEFINITIONS_LCAT: return "DEFINITIONS";
		case INTERFACE_BODY_LCAT: return "INTERFACE_BODY";
		case INTERFACE_LCAT: return "INTERFACE";
		case MACRO_DEFINITION_LCAT: return "MACRO_DEFINITION";
		case PARAGRAPH_START_LCAT: return "PARAGRAPH_START";
		case PB_PARAGRAPH_START_LCAT: return "PB_PARAGRAPH_START";
		case PREFORM_LCAT: return "PREFORM";
		case PREFORM_GRAMMAR_LCAT: return "PREFORM_GRAMMAR";
		case PURPOSE_LCAT: return "PURPOSE";
		case SECTION_HEADING_LCAT: return "SECTION_HEADING";
		case SOURCE_DISPLAY_LCAT: return "SOURCE_DISPLAY";
		case TEXT_EXTRACT_LCAT: return "TEXT_EXTRACT";
		case TOGGLE_WEAVING_LCAT: return "TOGGLE_WEAVING";
		case TYPEDEF_LCAT: return "TYPEDEF";
	}
	return "(?unknown)";
}

#line 53 "inweb/Chapter 2/Reading Sections.w"

#line 57 "inweb/Chapter 2/Reading Sections.w"
web *Reader__load_web(pathname *P, pathname *I, int verbosely) {
	web *W = CREATE(web);
	W->path_to_web = P;
	W->chaptered = FALSE;
	W->first_chapter = NULL; W->last_chapter = NULL;
	W->first_header = NULL; W->last_header = NULL;
	W->first_c_structure = NULL; W->last_c_structure = NULL;
	W->first_bd = NULL;
	W->first_target = NULL;
	W->no_lines = 0; W->no_sections = 0; W->no_chapters = 0; W->no_paragraphs = 0;
	W->analysed = FALSE;
	W->as_ebook = NULL;
	W->redirect_weaves_to = NULL;
	Bibliographic__initialise_data(W);
	Reader__add_tangle_target(W, Languages__default()); /* the bulk of the web is automatically a target */
	Reader__read_contents_page(W, I, verbosely);
	Parser__parse_literate_source(W);
	return W;
}

#line 80 "inweb/Chapter 2/Reading Sections.w"
void Reader__print_web_statistics(web *W) {
	printf("web \"%s\": ", Bibliographic__get_data(W, "Title"));
	if (W->chaptered) printf("%d chapter(s) : ", W->no_chapters);
	printf("%d section(s) : %d paragraph(s) : %d line(s)\n",
		W->no_sections, W->no_paragraphs, W->no_lines);
}

#line 112 "inweb/Chapter 2/Reading Sections.w"

#line 148 "inweb/Chapter 2/Reading Sections.w"

#line 175 "inweb/Chapter 2/Reading Sections.w"

#line 179 "inweb/Chapter 2/Reading Sections.w"
void Reader__read_contents_page(web *W, pathname *import_path, int verbosely) {
	Reader__read_contents_page_from(W, import_path, verbosely, NULL);
	Bibliographic__check_required_data(W);
}

void Reader__read_contents_page_from(web *W, pathname *import_path, int verbosely, pathname *path) {
	reader_state RS;
	RS.current_web = W;
	RS.in_biblio = TRUE;
	RS.in_purpose = FALSE;
	RS.chapter_being_scanned = NULL;
	CStrings__copy(RS.chapter_folder_name, "");
	CStrings__copy(RS.titling_line_to_insert, "");
	RS.scan_verbosely = verbosely;
	RS.path_to = path;
	RS.import_from = import_path;
	RS.in_original = FALSE;

	if (path == NULL) {
		path = W->path_to_web;
		RS.in_original = TRUE;
	}

	filename *Contents = Filenames__in_folder(path, "Contents.w");

	int cl = TextFiles__read_with_lines_to_ISO(Contents, "can't open contents file",
		TRUE, Reader__scan_biblio_line, NULL, &RS);
	if (verbosely) printf("Read contents section: '%s' (%d lines)\n", "Contents.w", cl);
}

#line 214 "inweb/Chapter 2/Reading Sections.w"
void Reader__scan_biblio_line(char *line, text_file_position *tfp, void *X) {
	reader_state *RS = (reader_state *) X;
	int begins_with_white_space = FALSE;
	while (ISORegexp__white_space(*line)) { begins_with_white_space = TRUE; line++; }
	int l = CStrings__len(line) - 1;
	while ((l>=0) && (ISORegexp__white_space(line[l]))) CStrings__truncate(line, l--);

	if (line[0] == 0) 
{
#line 231 "inweb/Chapter 2/Reading Sections.w"
	programming_language *pl =
		Languages__language_with_name(Bibliographic__get_data(RS->current_web, "Language"));
	RS->current_web->main_language = pl;
	RS->current_web->first_target->tangle_language = pl;
	RS->in_biblio = FALSE;

}
#line 221 "inweb/Chapter 2/Reading Sections.w"

	else if (RS->in_biblio) 
{
#line 241 "inweb/Chapter 2/Reading Sections.w"
	if (RS->in_original) {
		string found_text1;
		string found_text2;
		if (ISORegexp__match_2(line, "(%c+?): (%c+?) *", found_text1, found_text2)) {
			string key; CStrings__copy(key, found_text1);
			string value; CStrings__copy(value, found_text2);
			
{
#line 257 "inweb/Chapter 2/Reading Sections.w"
	if (CStrings__eq(key, "Weave")) {
		string found_text1;
		string found_text2;
		string found_text3;
		string found_text4;
		if (ISORegexp__match_4(value, "(%c+?): (%c+?), (%c+?), (%c+?)",
				found_text1, found_text2, found_text3, found_text4)) {
			Parser__declare_tag_from_contents(RS->current_web,
				found_text1, found_text2, found_text3, found_text4);
		} else {
			string err; CSTRING_WRITE(err,
				"expected 'Weave: Tag: title, leafname, cover' but found '%s'", line);
			Errors__in_text_file(err, tfp);
		}
	} else if (Bibliographic__datum_can_be_declared(RS->current_web, key)) {
		if (Bibliographic__datum_on_or_off(RS->current_web, key)) {
			if ((CStrings__ne(value, "On")) && (CStrings__ne(value, "Off"))) {
				string err;
				CSTRING_WRITE(err, "this setting must be 'On' or 'Off': %s", key);
				Errors__in_text_file(err, tfp);
				CStrings__copy(value, "Off");
			}
		}
		Bibliographic__set_datum(RS->current_web, key, value);
	} else {
		string err; CSTRING_WRITE(err, "no such bibliographic datum: %s", key);
		Errors__in_text_file(err, tfp);
	}

}
#line 247 "inweb/Chapter 2/Reading Sections.w"
;
		} else {
			string err; CSTRING_WRITE(err, "expected 'Setting: Value' but found '%s'", line);
			Errors__in_text_file(err, tfp);
		}
	}

}
#line 222 "inweb/Chapter 2/Reading Sections.w"

	else 
{
#line 290 "inweb/Chapter 2/Reading Sections.w"
	if (begins_with_white_space == FALSE) {
		if (*line == '"') { RS->in_purpose = TRUE; line++; }
		if (RS->in_purpose == TRUE) 
{
#line 301 "inweb/Chapter 2/Reading Sections.w"
	if ((CStrings__len(line) > 0) && (line[CStrings__len(line)-1] == '"')) {
		CStrings__truncate(line, CStrings__len(line)-1); RS->in_purpose = FALSE;
	}
	if (RS->chapter_being_scanned) {
		char *r = RS->chapter_being_scanned->rubric;
		if (r[0]) CStrings__concatenate(r, " ");
		CStrings__concatenate(r, line);
	}

}
#line 292 "inweb/Chapter 2/Reading Sections.w"

		else 
{
#line 313 "inweb/Chapter 2/Reading Sections.w"
	string new_chapter_sigil; CStrings__copy(new_chapter_sigil, ""); /* e.g., P, 1, 2, 3, A, B, ... */
	string pdf_leafname; CStrings__copy(pdf_leafname, "");
	tangle_target *ind_target = RS->current_web->first_target;
	programming_language *ind_language = RS->current_web->main_language;

	string found_text1;
	string found_text2;
	if (ISORegexp__match_2(line, "(%c*%C) %(Independent(%c*)%)", found_text1, found_text2)) {
		string title_alone; CStrings__copy(title_alone, found_text1);
		string language_name; CStrings__copy(language_name, found_text2);
		
{
#line 380 "inweb/Chapter 2/Reading Sections.w"
	char *p = language_name;
	while (ISORegexp__white_space(*p)) p++;
	if (*p == 0) p = Bibliographic__get_data(RS->current_web, "Language");
	ind_language = Languages__language_with_name(p);
	ind_target = Reader__add_tangle_target(RS->current_web, ind_language);

}
#line 323 "inweb/Chapter 2/Reading Sections.w"
;
		CStrings__copy(line, title_alone);
	}

	int this_is_a_chapter = TRUE;
	if (CStrings__eq(line, "Sections")) {
		CStrings__copy(new_chapter_sigil, "S");
		CSTRING_WRITE(RS->chapter_folder_name, "Sections");
		CStrings__copy(RS->titling_line_to_insert, "");
		CStrings__copy(pdf_leafname, "Sections.pdf");
		RS->current_web->chaptered = FALSE;
	} else if (CStrings__eq(line, "Preliminaries")) {
		CStrings__copy(new_chapter_sigil, "P");
		CSTRING_WRITE(RS->chapter_folder_name, "Preliminaries");
		CStrings__copy(RS->titling_line_to_insert, "");
		CStrings__copy(pdf_leafname, "Preliminaries.pdf");
		RS->current_web->chaptered = TRUE;
	} else if (ISORegexp__match_1(line, "Header: (%c+)", found_text1)) {
		pathname *P = RS->path_to;
		if (P == NULL) P = RS->current_web->path_to_web;
		P = Pathnames__subfolder(P, "Headers");
		filename *HF = Filenames__in_folder(P, found_text1);
		Reader__add_imported_header(RS->current_web, HF);
		this_is_a_chapter = FALSE;
	} else if (ISORegexp__match_1(line, "Import: (%c+)", found_text1)) {
		pathname *imported = Pathnames__from_string_relative(RS->import_from, found_text1);
		Reader__read_contents_page_from(RS->current_web, RS->import_from, RS->scan_verbosely, imported);
		this_is_a_chapter = FALSE;
	} else if (ISORegexp__match_1(line, "Chapter (%d+): %c+", found_text1)) {
		int n = atoi(found_text1);
		CSTRING_WRITE(new_chapter_sigil, "%d", n);
		CSTRING_WRITE(RS->chapter_folder_name, "Chapter %d", n);
		CSTRING_WRITE(RS->titling_line_to_insert, "%s.", line);
		CSTRING_WRITE(pdf_leafname, "Chapter-%d.pdf", n);
		RS->current_web->chaptered = TRUE;
	} else if (ISORegexp__match_1(line, "Appendix (%c): %c+", found_text1)) {
		string letter; CStrings__copy(letter, "");
		CStrings__copy(letter, found_text1);
		CStrings__copy(new_chapter_sigil, letter);
		CSTRING_WRITE(RS->chapter_folder_name, "Appendix %s", letter);
		CSTRING_WRITE(RS->titling_line_to_insert, "%s.", line);
		CSTRING_WRITE(pdf_leafname, "Appendix-%s.pdf", letter);
		RS->current_web->chaptered = TRUE;
	} else {
		string err; CSTRING_WRITE(err, "segment not understood: %s", line);
		Errors__in_text_file(err, tfp);
		fprintf(stderr, "(Must be 'Chapter <number>: Title', "
			"'Appendix <letter A to O>: Title',\n");
		fprintf(stderr, "'Preliminaries' or 'Sections')\n");
	}

	if (this_is_a_chapter) 
{
#line 389 "inweb/Chapter 2/Reading Sections.w"
	chapter *C = CREATE(chapter);
	CStrings__copy(C->ch_sigil, new_chapter_sigil);
	CStrings__copy(C->ch_title, line);
	CStrings__copy(C->rubric, "");
	C->ch_target = ind_target;
	C->ch_weave = NULL;
	C->ch_language = ind_language;
	C->ch_extent = 0;
	C->titling_line_inserted = FALSE;
	C->owning_web = RS->current_web;
	C->next_chapter = NULL;
	C->first_section = NULL; C->last_section = NULL;
	C->imported = TRUE;
	if (RS->in_original) C->imported = FALSE;
	CStrings__copy(C->woven_pdf_leafname, pdf_leafname);

	if (RS->current_web->first_chapter == NULL) {
		RS->current_web->first_chapter = C;
		RS->current_web->last_chapter = C;
	} else {
		RS->current_web->last_chapter->next_chapter = C;
		RS->current_web->last_chapter = C;
	}
	C->owning_web->no_chapters++;
	RS->chapter_being_scanned = C;

}
#line 374 "inweb/Chapter 2/Reading Sections.w"
;

}
#line 293 "inweb/Chapter 2/Reading Sections.w"
;
	} else 
{
#line 420 "inweb/Chapter 2/Reading Sections.w"
	section *sect = CREATE(section);
	sect->owning_chapter = RS->chapter_being_scanned;
	sect->owning_chapter->owning_web->no_sections++;
	sect->next_section = NULL;

	sect->sect_extent = 0;
	sect->first_line = NULL; sect->last_line = NULL;
	sect->sect_paragraphs = 0;
	sect->first_paragraph = NULL; sect->last_paragraph = NULL;

	sect->scratch_flag = FALSE;
	sect->erroneous_interface = FALSE;
	sect->barred = FALSE;

	if (RS->chapter_being_scanned->first_section == NULL)
		RS->chapter_being_scanned->first_section = sect;
	else
		RS->chapter_being_scanned->last_section->next_section = sect;
	RS->chapter_being_scanned->last_section = sect;

	
{
#line 477 "inweb/Chapter 2/Reading Sections.w"
	sect->sect_language = RS->chapter_being_scanned->ch_language; /* by default */
	string found_text1;
	string found_text2;
	if (ISORegexp__match_2(line, "(%c*%C) %(Independent(%c*)%)", found_text1, found_text2)) {
		string title_alone; CStrings__copy(title_alone, found_text1);
		string language_name; CStrings__copy(language_name, found_text2);
		
{
#line 492 "inweb/Chapter 2/Reading Sections.w"
	char *p = language_name;
	while (ISORegexp__white_space(*p)) p++;
	if (*p == 0) p = Bibliographic__get_data(RS->current_web, "Language");
	programming_language *pl = Languages__language_with_name(p);
	sect->sect_language = pl;
	sect->sect_target = Reader__add_tangle_target(RS->current_web, pl);

}
#line 483 "inweb/Chapter 2/Reading Sections.w"
;
		CStrings__copy(line, title_alone);
	} else {
		sect->sect_target = RS->chapter_being_scanned->ch_target;
	}

}
#line 440 "inweb/Chapter 2/Reading Sections.w"
;
	sect->sect_weave = NULL;

	string found_text1;
	string found_text2;
	if (ISORegexp__match_2(line, "(%c+) %[%[Tag: (%c+)%]%] *", found_text1, found_text2)) {
		CStrings__copy(sect->sect_title, found_text1);
		sect->tag_with = Parser__add_tag_by_name(NULL, found_text2);
	} else {
		sect->tag_with = NULL;
		CStrings__copy(sect->sect_title, line);
	}

	CStrings__copy(sect->sect_namespace, "");

	string leafname_to_use;
	CSTRING_WRITE(leafname_to_use,
		"%s%s", sect->sect_title, sect->sect_language->source_file_extension);

	char *templ = strstr(leafname_to_use, " Template.i6t");
	if (templ) CStrings__copy(templ, ".i6t");

	pathname *P = RS->path_to;
	if (P == NULL) P = RS->current_web->path_to_web;
	if (RS->chapter_folder_name[0]) P = Pathnames__subfolder(P, RS->chapter_folder_name);
	sect->source_file_for_section = Filenames__in_folder(P, leafname_to_use);

	Reader__read_file(RS->current_web, sect->source_file_for_section,
		RS->titling_line_to_insert, sect, RS->scan_verbosely);

}
#line 294 "inweb/Chapter 2/Reading Sections.w"
;

}
#line 223 "inweb/Chapter 2/Reading Sections.w"
;
}

#line 504 "inweb/Chapter 2/Reading Sections.w"
void Reader__read_file(web *W, filename *OUT, char *titling_line, section *sect,
	int verbosely) {
	section *current_section = sect;

	if ((titling_line) && (titling_line[0]) &&
		(sect->owning_chapter->titling_line_inserted == FALSE)) {
		sect->owning_chapter->titling_line_inserted = TRUE;
		string line; CStrings__copy(line, "");
		text_file_position *tfp = NULL;
		CSTRING_WRITE(line, "Chapter Heading");
		
{
#line 537 "inweb/Chapter 2/Reading Sections.w"
	source_line *sl = Lines__new_source_line(line, tfp);

	/* enter this in its section's linked list of lines: */
	sl->owning_section = current_section;
	if (current_section->first_line == NULL) current_section->first_line = sl;
	else current_section->last_line->next_line = sl;
	current_section->last_line = sl;

	/* we haven't detected paragraph boundaries yet, so: */
	sl->owning_paragraph = NULL;

	/* and keep count: */
	sl->owning_section->sect_extent++;
	sl->owning_section->owning_chapter->ch_extent++;
	sl->owning_section->owning_chapter->owning_web->no_lines++;

}
#line 514 "inweb/Chapter 2/Reading Sections.w"
;
	}

	int cl = TextFiles__read_with_lines_to_ISO(OUT, "can't open section file", TRUE,
		Reader__scan_source_line, NULL, (void *) current_section);
	if (verbosely)
		printf("Read section: '%s' (%d lines)\n", sect->sect_title, cl);
}

#line 526 "inweb/Chapter 2/Reading Sections.w"
void Reader__scan_source_line(char *line, text_file_position *tfp, void *state) {
	section *current_section = (section *) state;
	int l = CStrings__len(line) - 1;
	while ((l>=0) && (ISORegexp__white_space(line[l]))) CStrings__truncate(line, l--);

	
{
#line 537 "inweb/Chapter 2/Reading Sections.w"
	source_line *sl = Lines__new_source_line(line, tfp);

	/* enter this in its section's linked list of lines: */
	sl->owning_section = current_section;
	if (current_section->first_line == NULL) current_section->first_line = sl;
	else current_section->last_line->next_line = sl;
	current_section->last_line = sl;

	/* we haven't detected paragraph boundaries yet, so: */
	sl->owning_paragraph = NULL;

	/* and keep count: */
	sl->owning_section->sect_extent++;
	sl->owning_section->owning_chapter->ch_extent++;
	sl->owning_section->owning_chapter->owning_web->no_lines++;

}
#line 531 "inweb/Chapter 2/Reading Sections.w"
;
}

#line 558 "inweb/Chapter 2/Reading Sections.w"
void Reader__scan_line_categories(web *W, char *sigil) {
	printf("Scan of source lines for '%s'\n", sigil);
	int count = 1;
	chapter *C = Reader__get_chapter_for_sigil(W, sigil);
	if (C) {
		for (section *S = C->first_section; S; S = S->next_section)
			for (source_line *L = S->first_line; L; L = L->next_line)
				
{
#line 583 "inweb/Chapter 2/Reading Sections.w"
	printf("%07d  %16s  %s\n", count++, Lines__category_name(L->category), L->text);

}
#line 565 "inweb/Chapter 2/Reading Sections.w"
;
	} else {
		section *S = Reader__get_section_for_sigil(W, sigil);
		if (S) {
			for (source_line *L = S->first_line; L; L = L->next_line)
				
{
#line 583 "inweb/Chapter 2/Reading Sections.w"
	printf("%07d  %16s  %s\n", count++, Lines__category_name(L->category), L->text);

}
#line 570 "inweb/Chapter 2/Reading Sections.w"

		} else {
			for (chapter *C = W->first_chapter; C; C = C->next_chapter)
				for (section *S = C->first_section; S; S = S->next_section)
					for (source_line *L = S->first_line; L; L = L->next_line)
						
{
#line 583 "inweb/Chapter 2/Reading Sections.w"
	printf("%07d  %16s  %s\n", count++, Lines__category_name(L->category), L->text);

}
#line 575 "inweb/Chapter 2/Reading Sections.w"
;
		}
	}
}

#line 588 "inweb/Chapter 2/Reading Sections.w"
chapter *Reader__get_chapter_for_sigil(web *W, char *sigil) {
	if (W)
		for (chapter *C = W->first_chapter; C; C = C->next_chapter)
			if (CStrings__eq(C->ch_sigil, sigil))
				return C;
	return NULL;
}

section *Reader__get_section_for_sigil(web *W, char *sigil) {
	if (W)
		for (chapter *C = W->first_chapter; C; C = C->next_chapter)
			for (section *S = C->first_section; S; S = S->next_section)
				if (CStrings__eq(S->sigil, sigil))
					return S;
	return NULL;
}

section *Reader__section_by_filename(web *W, text_stream *filename) {
	if (W)
		for (chapter *C = W->first_chapter; C; C = C->next_chapter)
			for (section *S = C->first_section; S; S = S->next_section) {
				TEMPORARY_TEXT(SFN);
				WRITE_TO(SFN, "%f", S->source_file_for_section);
				int rv = Str__eq(SFN, filename);
				DISCARD_TEXT(SFN);
				if (rv) return S;
			}
	return NULL;
}

#line 624 "inweb/Chapter 2/Reading Sections.w"
int Reader__sigil_within(char *sig1, char *sig2) {
	if (CStrings__eq(sig2, "0")) return TRUE;
	if (CStrings__eq(sig1, sig2)) return TRUE;
	string found_text1;
	if (ISORegexp__match_0(sig2, "%c+/%c+")) return FALSE;
	if (ISORegexp__match_1(sig1, "(%c+)/%c+", found_text1)) {
		if (CStrings__eq(found_text1, sig2)) return TRUE;
	}
	return FALSE;
}

#line 652 "inweb/Chapter 2/Reading Sections.w"

#line 656 "inweb/Chapter 2/Reading Sections.w"
tangle_target *Reader__add_tangle_target(web *W, programming_language *language) {
	tangle_target *tt = CREATE(tangle_target);
	tt->tangle_language = language;
	tt->next_target = NULL;
	if (W->first_target == NULL) W->first_target = tt;
	else {
		tangle_target *tto = W->first_target;
		while ((tto) && (tto->next_target)) tto = tto->next_target;
		tto->next_target = tt;
	}
	return tt;
}

#line 687 "inweb/Chapter 2/Reading Sections.w"

#line 691 "inweb/Chapter 2/Reading Sections.w"
void Reader__add_imported_header(web *W, filename *HF) {
	imported_header *H = CREATE(imported_header);
	H->header_file = HF;
	if (W->first_header == NULL) {
		W->first_header = H;
		W->last_header = H;
	} else {
		W->last_header->next_header = H;
		W->last_header = H;
	}
	H->next_header = NULL;
}

#line 9 "inweb/Chapter 2/The Parser.w"
void Parser__parse_literate_source(web *W) {
	for (chapter *C = W->first_chapter; C; C = C->next_chapter)
		for (section *S = C->first_section; S; S = S->next_section) {
			int comment_mode = TRUE;
			int code_lcat_for_body = NO_LCAT;
			int before_bar = TRUE;
			int next_par_number = 1;
			paragraph *current_paragraph = NULL;
			for (source_line *L = S->first_line; L; L = L->next_line)
				
{
#line 35 "inweb/Chapter 2/The Parser.w"
	L->is_commentary = comment_mode;
	L->category = COMMENT_BODY_LCAT; /* until set otherwise down below */
	L->owning_paragraph = current_paragraph;

	if (L->source.line_count == 0) 
{
#line 52 "inweb/Chapter 2/The Parser.w"
	if (CStrings__eq(L->text, "Chapter Heading")) {
		comment_mode = TRUE;
		L->is_commentary = TRUE;
		L->category = CHAPTER_HEADING_LCAT;
	}

}
#line 39 "inweb/Chapter 2/The Parser.w"
;
	if (L->source.line_count == 1) 
{
#line 62 "inweb/Chapter 2/The Parser.w"
	string rewritten; CStrings__copy(rewritten, "");
	string found_text1;
	string found_text2;
	string found_text3;
	if (ISORegexp__match_3(L->text, "%[(%C+)%] (%C+/%C+): (%c+).",
						found_text1, found_text2, found_text3)) {
		CStrings__copy(S->sect_namespace, found_text1);
		CStrings__copy(S->sigil, found_text2);
		CStrings__copy(S->sect_title, found_text3);
		L->text_operand = Memory__new_string(found_text3);
		L->category = SECTION_HEADING_LCAT;
	} else if (ISORegexp__match_2(L->text, "(%C+/%C+): (%c+).", found_text1, found_text2)) {
		CStrings__copy(S->sigil, found_text1);
		CStrings__copy(S->sect_title, found_text2);
		L->text_operand = Memory__new_string(found_text2);
		L->category = SECTION_HEADING_LCAT;
	} else if (ISORegexp__match_2(L->text, "%[(%C+::)%] (%c+).", found_text1, found_text2)) {
		CStrings__copy(S->sect_namespace, found_text1);
		CStrings__copy(S->sect_title, found_text2);
		
{
#line 94 "inweb/Chapter 2/The Parser.w"
	sprintf(S->sigil, "%s/", C->ch_sigil);

	char *from = S->sect_title;
	int w = CStrings__len(S->sigil);
	char *tail = S->sigil + w;

	int letters_from_each_word = 5;
	do {
		
{
#line 112 "inweb/Chapter 2/The Parser.w"
	int sn = 0, sw = w;
	if (from[sn] == FOLDER_SEPARATOR) sn++;
	int letters_from_current_word = 0;
	while ((from[sn]) && (from[sn] != '.')) {
		if (from[sn] == ' ') letters_from_current_word = 0;
		else {
			if (letters_from_current_word < letters_from_each_word) {
				if (from[sn] != '-') {
					int l = tolower(from[sn]);
					if ((letters_from_current_word == 0) ||
						((l != 'a') && (l != 'e') && (l != 'i') && (l != 'o') && (l != 'u'))) {
						S->sigil[sw++] = (char) l; S->sigil[sw] = 0;
						letters_from_current_word++;
					}
				}
			}
		}
		sn++;
	}

}
#line 102 "inweb/Chapter 2/The Parser.w"
;
		if (--letters_from_each_word == 0) break;
	} while (CStrings__len(tail) > 5);

	
{
#line 135 "inweb/Chapter 2/The Parser.w"
	char *distail = S->sigil + CStrings__len(S->sigil);
	int disnum = 0, collision = FALSE;
	do {
		if (disnum++ > 0) {
			int ldn = 5;
			if (disnum >= 1000) ldn = 4;
			else if (disnum >= 100) ldn = 3;
			else if (disnum >= 10) ldn = 2;
			else ldn = 1;
			sprintf(distail-ldn, "%d", disnum);
		}
		collision = FALSE;
		for (chapter *C = W->first_chapter; C; C = C->next_chapter)
			for (section *S2 = C->first_section; S2; S2 = S2->next_section)
				if ((S2 != S) && (strcmp(S2->sigil, S->sigil) == 0)) {
					collision = TRUE; break;
				}
	} while (collision);

}
#line 106 "inweb/Chapter 2/The Parser.w"
;

}
#line 81 "inweb/Chapter 2/The Parser.w"
;
		L->text_operand = Memory__new_string(found_text2);
		L->category = SECTION_HEADING_LCAT;
	} else if (ISORegexp__match_1(L->text, "(%c+).", found_text1)) {
		CStrings__copy(S->sect_title, found_text1);
		
{
#line 94 "inweb/Chapter 2/The Parser.w"
	sprintf(S->sigil, "%s/", C->ch_sigil);

	char *from = S->sect_title;
	int w = CStrings__len(S->sigil);
	char *tail = S->sigil + w;

	int letters_from_each_word = 5;
	do {
		
{
#line 112 "inweb/Chapter 2/The Parser.w"
	int sn = 0, sw = w;
	if (from[sn] == FOLDER_SEPARATOR) sn++;
	int letters_from_current_word = 0;
	while ((from[sn]) && (from[sn] != '.')) {
		if (from[sn] == ' ') letters_from_current_word = 0;
		else {
			if (letters_from_current_word < letters_from_each_word) {
				if (from[sn] != '-') {
					int l = tolower(from[sn]);
					if ((letters_from_current_word == 0) ||
						((l != 'a') && (l != 'e') && (l != 'i') && (l != 'o') && (l != 'u'))) {
						S->sigil[sw++] = (char) l; S->sigil[sw] = 0;
						letters_from_current_word++;
					}
				}
			}
		}
		sn++;
	}

}
#line 102 "inweb/Chapter 2/The Parser.w"
;
		if (--letters_from_each_word == 0) break;
	} while (CStrings__len(tail) > 5);

	
{
#line 135 "inweb/Chapter 2/The Parser.w"
	char *distail = S->sigil + CStrings__len(S->sigil);
	int disnum = 0, collision = FALSE;
	do {
		if (disnum++ > 0) {
			int ldn = 5;
			if (disnum >= 1000) ldn = 4;
			else if (disnum >= 100) ldn = 3;
			else if (disnum >= 10) ldn = 2;
			else ldn = 1;
			sprintf(distail-ldn, "%d", disnum);
		}
		collision = FALSE;
		for (chapter *C = W->first_chapter; C; C = C->next_chapter)
			for (section *S2 = C->first_section; S2; S2 = S2->next_section)
				if ((S2 != S) && (strcmp(S2->sigil, S->sigil) == 0)) {
					collision = TRUE; break;
				}
	} while (collision);

}
#line 106 "inweb/Chapter 2/The Parser.w"
;

}
#line 86 "inweb/Chapter 2/The Parser.w"
;
		L->text_operand = Memory__new_string(found_text1);
		L->category = SECTION_HEADING_LCAT;
	}

}
#line 40 "inweb/Chapter 2/The Parser.w"
;
	
{
#line 162 "inweb/Chapter 2/The Parser.w"
	string found_text1;
	string found_text2;
	if (ISORegexp__match_1(L->text, "%[%[(%c+)%]%]", found_text1)) {
		string command_text; CStrings__copy(command_text, found_text1);
		L->category = COMMAND_LCAT;
		if (ISORegexp__match_2(command_text, "(%c+?): *(%c+)", found_text1, found_text2)) {
			CStrings__copy(command_text, found_text1);
			L->text_operand = Memory__new_string(found_text2);
		}
		if (CStrings__eq(command_text, "Page Break"))
			L->command_code = PAGEBREAK_CMD;
		else if (CStrings__eq(command_text, "Grammar Index"))
			L->command_code = GRAMMAR_INDEX_CMD;
		else if (CStrings__eq(command_text, "Tag")) {
			Parser__add_tag_by_name(L, L->text_operand);
			L->command_code = TAG_CMD;
		} else if (CStrings__eq(command_text, "Figure")) {
			Parser__add_tag_by_name(L, "Figures");
			L->command_code = FIGURE_CMD;
		} else Main__error_in_web("unknown [[command]]", L);
		L->is_commentary = TRUE;
	}

}
#line 41 "inweb/Chapter 2/The Parser.w"
;
	
{
#line 190 "inweb/Chapter 2/The Parser.w"
	string found_text1;
	if ((L->text[0] == '@') && (L->text[1] == '<') &&
		(ISORegexp__match_1(L->text+2, "(%c+)@> *= *", found_text1))) {
		string cweb_macro_name; CStrings__copy(cweb_macro_name, found_text1);
		L->category = MACRO_DEFINITION_LCAT;
		if (current_paragraph == NULL)
			Main__error_in_web("<...> definition begins outside of a paragraph", L);
		else 
{
#line 220 "inweb/Chapter 2/The Parser.w"
	cweb_macro *cwm = CREATE(cweb_macro);
	CStrings__copy(cwm->macro_name, cweb_macro_name);
	cwm->defining_paragraph = current_paragraph;
	current_paragraph->defines_macro = cwm;
	cwm->defn_start = L->next_line;
	cwm->next_macro = NULL;
	cwm->macro_usages = NULL;

	if (S->first_macro == NULL) S->first_macro = cwm;
	else S->last_macro->next_macro = cwm;
	S->last_macro = cwm;

}
#line 197 "inweb/Chapter 2/The Parser.w"
;
		comment_mode = FALSE;
		L->is_commentary = FALSE;
		code_lcat_for_body = CODE_BODY_LCAT; /* code follows on subsequent lines */
		continue;
	}

}
#line 42 "inweb/Chapter 2/The Parser.w"
;
	if ((L->text[0] == '@') && (L->category != MACRO_DEFINITION_LCAT))
		
{
#line 236 "inweb/Chapter 2/The Parser.w"
	string command_text;
	CStrings__copy(command_text, L->text + 1); /* i.e., strip the at-sign from the front */
	char *remainder = "";
	for (int i = 0; command_text[i]; i++)
		if (ISORegexp__white_space(command_text[i])) {
			CStrings__truncate(command_text, i);
			remainder = command_text+i+1;
			while (ISORegexp__white_space(*remainder)) remainder++;
			break;
		}
	
{
#line 253 "inweb/Chapter 2/The Parser.w"
	if (CStrings__eq(command_text, "Purpose:")) 
{
#line 273 "inweb/Chapter 2/The Parser.w"
	if (before_bar == FALSE) Main__error_in_web("Purpose used after bar", L);
	L->category = PURPOSE_LCAT;
	L->is_commentary = TRUE;
	L->text_operand = Memory__new_string(remainder);
	CStrings__copy(S->sect_purpose, remainder);
	source_line *XL = L->next_line;
	while ((XL) && (XL->next_line) && (XL->owning_section == L->owning_section) &&
		(isalnum(XL->text[0]))) {
		CStrings__concatenate(S->sect_purpose, " ");
		CStrings__concatenate(S->sect_purpose, XL->text);
		XL->category = PURPOSE_BODY_LCAT;
		XL->is_commentary = TRUE;
		L = XL;
		XL = XL->next_line;
	}

}
#line 253 "inweb/Chapter 2/The Parser.w"

	else if (CStrings__eq(command_text, "Interface:")) 
{
#line 292 "inweb/Chapter 2/The Parser.w"
	if (before_bar == FALSE) Main__error_in_web("Interface used after bar", L);
	L->category = INTERFACE_LCAT;
	L->is_commentary = TRUE;
	source_line *XL = L->next_line;
	while ((XL) && (XL->next_line) && (XL->owning_section == L->owning_section)) {
		if (XL->text[0] == '@') break;
		XL->category = INTERFACE_BODY_LCAT;
		L = XL;
		XL = XL->next_line;
	}

}
#line 254 "inweb/Chapter 2/The Parser.w"

	else if (CStrings__eq(command_text, "Definitions:")) 
{
#line 306 "inweb/Chapter 2/The Parser.w"
	if (before_bar == FALSE) Main__error_in_web("Definitions used after bar", L);
	L->category = DEFINITIONS_LCAT;
	L->is_commentary = TRUE;
	before_bar = TRUE;
	next_par_number = 1;

}
#line 255 "inweb/Chapter 2/The Parser.w"

	else if (ISORegexp__match_0(command_text, "----+")) 
{
#line 316 "inweb/Chapter 2/The Parser.w"
	if (before_bar == FALSE) Main__error_in_web("second bar in the same section", L);
	L->category = BAR_LCAT;
	L->is_commentary = TRUE;
	comment_mode = TRUE;
	S->barred = TRUE;
	before_bar = FALSE;
	next_par_number = 1;

}
#line 256 "inweb/Chapter 2/The Parser.w"

	else if ((CStrings__eq(command_text, "c")) ||
			(CStrings__eq(command_text, "e")) ||
			(CStrings__eq(command_text, "x"))) 
{
#line 329 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_VERBATIM_LCAT;
	if ((CStrings__eq(command_text, "e")) && (current_paragraph))
		current_paragraph->placed_early = TRUE;
	if (CStrings__eq(command_text, "x")) code_lcat_for_body = TEXT_EXTRACT_LCAT;
	else code_lcat_for_body = CODE_BODY_LCAT;
	comment_mode = FALSE;

}
#line 259 "inweb/Chapter 2/The Parser.w"

	else if (CStrings__eq(command_text, "d")) 
{
#line 340 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_DEFINITION_LCAT;
	code_lcat_for_body = CONT_DEFINITION_LCAT;
	string found_text1;
	string found_text2;
	if (ISORegexp__match_2(remainder, "(%C+) (%c+)", found_text1, found_text2)) {
		L->text_operand = Memory__new_string(found_text1); /* name of term defined */
		L->text_operand2 = Memory__new_string(found_text2); /* Value */
	} else {
		L->text_operand = Memory__new_string(remainder); /* name of term defined */
		L->text_operand2 = ""; /* no value given */
	}
	Analyser__mark_reserved_word(S, L->text_operand, CONSTANT_CODE);
	comment_mode = FALSE;
	L->is_commentary = FALSE;

}
#line 260 "inweb/Chapter 2/The Parser.w"

	else {
		int weight = -1, new_page = FALSE;
		if (CStrings__eq(command_text, "")) weight = ORDINARY_WEIGHT;
		if (CStrings__eq(command_text, "p")) weight = SUBHEADING_WEIGHT;
		if (CStrings__eq(command_text, "pp")) { weight = SUBHEADING_WEIGHT; new_page = TRUE; }
		if (weight >= 0) 
{
#line 371 "inweb/Chapter 2/The Parser.w"
	comment_mode = TRUE;
	L->is_commentary = TRUE;
	L->category = PARAGRAPH_START_LCAT;
	if (weight == 1) L->category = PB_PARAGRAPH_START_LCAT;
	L->text_operand = ""; /* title */
	string found_text1;
	string found_text2;
	if ((weight == SUBHEADING_WEIGHT) && (ISORegexp__match_2(remainder, "(%c+). (%c+)", found_text1, found_text2))) {
		L->text_operand = Memory__new_string(found_text1);
		L->text_operand2 = Memory__new_string(found_text2);
	} else if ((weight == SUBHEADING_WEIGHT) && (ISORegexp__match_1(remainder, "(%c+). *", found_text1))) {
		L->text_operand = Memory__new_string(found_text1);
		L->text_operand2 = Memory__new_string("");
	} else {
		L->text_operand = Memory__new_string("");
		L->text_operand2 = Memory__new_string(remainder);
	}
	
{
#line 426 "inweb/Chapter 2/The Parser.w"
	paragraph *P = CREATE(paragraph);
	P->above_bar = before_bar;
	P->placed_early = before_bar;
	if (before_bar) P->ornament = "P"; else P->ornament = "S";
	CSTRING_WRITE(P->paragraph_number, "%d", next_par_number++);
	P->parent_paragraph = NULL;
	P->next_child_number = 1;
	P->starts_on_new_page = FALSE;
	P->weight = weight;
	P->first_line_in_paragraph = L;
	P->next_paragraph_in_section = NULL;
	P->defines_macro = NULL;
	P->first_defined_in_paragraph = NULL;
	P->first_c_structure_in_para = NULL; P->last_c_structure_in_para = NULL;
	P->tags = NULL;

	P->under_section = S;
	S->sect_paragraphs++;
	if (S->first_paragraph) S->last_paragraph->next_paragraph_in_section = P;
	else S->first_paragraph = P;
	S->last_paragraph = P;

	current_paragraph = P;

}
#line 388 "inweb/Chapter 2/The Parser.w"
;

	L->owning_paragraph = current_paragraph;
	W->no_paragraphs++;

}
#line 266 "inweb/Chapter 2/The Parser.w"

		else Main__error_in_web("don't understand @command", L);
	}

}
#line 246 "inweb/Chapter 2/The Parser.w"
;
	continue;

}
#line 44 "inweb/Chapter 2/The Parser.w"
;
	if (comment_mode) 
{
#line 456 "inweb/Chapter 2/The Parser.w"
	string found_text1;
	if (ISORegexp__match_1(L->text, ">> (%c+)", found_text1)) {
		L->category = SOURCE_DISPLAY_LCAT;
		L->text_operand = Memory__new_string(found_text1);
	}

}
#line 45 "inweb/Chapter 2/The Parser.w"
;
	if (comment_mode == FALSE) 
{
#line 467 "inweb/Chapter 2/The Parser.w"
	if ((L->category != BEGIN_DEFINITION_LCAT) && (L->category != COMMAND_LCAT))
		L->category = code_lcat_for_body;

	if ((L->category == CONT_DEFINITION_LCAT) && (ISORegexp__string_is_white_space(L->text))) {
		L->category = COMMENT_BODY_LCAT;
		L->is_commentary = TRUE;
		code_lcat_for_body = COMMENT_BODY_LCAT;
		comment_mode = TRUE;
	}

	Languages__subcategorise_code(S->sect_language, L);

}
#line 46 "inweb/Chapter 2/The Parser.w"
;

}
#line 18 "inweb/Chapter 2/The Parser.w"
;
		}
	for (chapter *C = W->first_chapter; C; C = C->next_chapter)
		for (section *S = C->first_section; S; S = S->next_section) {
			if (S->tag_with)
				for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
					Parser__add_tag_to_para(P, S->tag_with, NULL);
			if (S->barred == FALSE)
				for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
					P->ornament = "S";
		}
	Languages__further_parsing(W, W->main_language);
}

#line 215 "inweb/Chapter 2/The Parser.w"

#line 422 "inweb/Chapter 2/The Parser.w"

#line 486 "inweb/Chapter 2/The Parser.w"
cweb_macro *Parser__get_cweb_macro_by_name(char *name, section *scope) {
	cweb_macro *cwm;
	for (cwm = scope->first_macro; cwm; cwm = cwm->next_macro)
		if (CStrings__eq(name, cwm->macro_name))
			return cwm;
	return NULL;
}

#line 507 "inweb/Chapter 2/The Parser.w"

#line 511 "inweb/Chapter 2/The Parser.w"
theme_tag *Parser__tag_by_name(char *p) {
	theme_tag *tag;
	LOOP_OVER(tag, theme_tag)
		if (CStrings__eq(p, tag->tag_name))
			return tag;
	return NULL;
}

#line 530 "inweb/Chapter 2/The Parser.w"

#line 539 "inweb/Chapter 2/The Parser.w"
theme_tag *Parser__declare_tag_from_contents(web *W, char *name, char *title, char *leaf, char *cover) {
	theme_tag *tag = Parser__add_tag_by_name(NULL, name);
	CStrings__copy(tag->title_when_woven, title);
	CStrings__copy(tag->leafname_when_woven, leaf);
	CStrings__copy(tag->cover_sheet_when_woven, cover);
	Languages__new_tag_declared(tag);
	return tag;
}

#line 551 "inweb/Chapter 2/The Parser.w"
theme_tag *Parser__add_tag_by_name(source_line *L, char *p) {
	string name; CStrings__copy(name, p);
	string caption; CStrings__copy(caption, "");
	string found_text1;
	string found_text2;
	if (ISORegexp__match_2(name, "(%c+?): (%c+)", found_text1, found_text2)) {
		CStrings__copy(name, found_text1);
		CStrings__copy(caption, found_text2);
	}
	theme_tag *tag = Parser__tag_by_name(name);
	if (tag == NULL) 
{
#line 569 "inweb/Chapter 2/The Parser.w"
	tag = CREATE(theme_tag);
	CStrings__copy(tag->tag_name, name);
	CStrings__copy(tag->title_when_woven, name);
	CStrings__copy(tag->leafname_when_woven, name);
	CStrings__copy(tag->cover_sheet_when_woven, "");

}
#line 561 "inweb/Chapter 2/The Parser.w"
;
	if ((L) && (L->owning_paragraph)) Parser__add_tag_to_para(L->owning_paragraph, tag, caption);
	return tag;
}

#line 578 "inweb/Chapter 2/The Parser.w"
void Parser__add_tag_to_para(paragraph *P, theme_tag *tag, char *caption) {
	if (P) {
		paragraph_tag *pt = CREATE(paragraph_tag);
		pt->the_tag = tag;
		if (caption) CStrings__copy(pt->caption, caption);
		else CStrings__copy(pt->caption, "");
		pt->next_tag = P->tags; P->tags = pt; /* insert at front of linked list */
	}
}

#line 591 "inweb/Chapter 2/The Parser.w"
int Parser__is_tagged_with(source_line *L, theme_tag *tag) {
	if (tag == NULL) return TRUE;
	if (L)
		if (L->owning_paragraph)
			for (paragraph_tag *pt = L->owning_paragraph->tags; pt; pt = pt->next_tag)
				if (tag == pt->the_tag)
					return TRUE;
	return FALSE;
}

#line 16 "inweb/Chapter 2/Paragraph Numbering.w"
void Numbering__number_web(web *W) {
	for (chapter *C = W->first_chapter; C; C = C->next_chapter) {
		for (section *S = C->first_section; S; S = S->next_section) {
			
{
#line 28 "inweb/Chapter 2/Paragraph Numbering.w"
	for (source_line *L = S->first_line; L; L = L->next_line) {
		char *p = L->text;
		int mlen, mpos;
		while ((mpos = ISORegexp__find_expansion(p, '@', '<', '@', '>', &mlen)) != -1) {
			string found_macro;
			CStrings__copy(found_macro, p+mpos+2); CStrings__truncate(found_macro, mlen-4);
			p = p + mpos + mlen;
			cweb_macro *cwm = Parser__get_cweb_macro_by_name(found_macro, S);
			if (cwm) 
{
#line 61 "inweb/Chapter 2/Paragraph Numbering.w"
	macro_usage *mu, *last = NULL;
	for (mu = cwm->macro_usages; mu; mu = mu->next_macro_usage) {
		last = mu;
		if (mu->used_in_paragraph == L->owning_paragraph)
			break;
	}
	if (mu == NULL) {
		mu = CREATE(macro_usage);
		mu->used_in_paragraph = L->owning_paragraph;
		mu->next_macro_usage = NULL;
		mu->multiplicity = 0;
		if (last) last->next_macro_usage = mu;
		else cwm->macro_usages = mu;
	}
	mu->multiplicity++;

}
#line 36 "inweb/Chapter 2/Paragraph Numbering.w"
;
		}
	}

}
#line 19 "inweb/Chapter 2/Paragraph Numbering.w"
;
			
{
#line 83 "inweb/Chapter 2/Paragraph Numbering.w"
	
{
#line 91 "inweb/Chapter 2/Paragraph Numbering.w"
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section) {
		macro_usage *mu = (P->defines_macro)?(P->defines_macro->macro_usages):NULL;
		if (mu) P->parent_paragraph = mu->used_in_paragraph;
	}

}
#line 83 "inweb/Chapter 2/Paragraph Numbering.w"
;
	
{
#line 99 "inweb/Chapter 2/Paragraph Numbering.w"
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		if (P->parent_paragraph == NULL)
			for (paragraph *P2 = P; P2; P2 = P2->next_paragraph_in_section)
				if (P2->parent_paragraph) {
					if (P2->parent_paragraph->allocation_id < P->allocation_id)
						P->parent_paragraph = P2->parent_paragraph;
					break;
				}

}
#line 84 "inweb/Chapter 2/Paragraph Numbering.w"
;
	
{
#line 113 "inweb/Chapter 2/Paragraph Numbering.w"
	int top_level = 1;
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		if (P->parent_paragraph == NULL) {
			CSTRING_WRITE(P->paragraph_number, "%d", top_level++);
			P->next_child_number = 1;
		} else
			CStrings__copy(P->paragraph_number, "");

}
#line 85 "inweb/Chapter 2/Paragraph Numbering.w"
;
	
{
#line 124 "inweb/Chapter 2/Paragraph Numbering.w"
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		Numbering__settle_paragraph_number(P);

}
#line 86 "inweb/Chapter 2/Paragraph Numbering.w"
;

}
#line 20 "inweb/Chapter 2/Paragraph Numbering.w"
;
		}
	}
}

#line 57 "inweb/Chapter 2/Paragraph Numbering.w"

#line 134 "inweb/Chapter 2/Paragraph Numbering.w"
void Numbering__settle_paragraph_number(paragraph *P) {
	if (P->paragraph_number[0]) return;
	CStrings__copy(P->paragraph_number, "X"); /* to prevent malformed sections hanging this */
	if (P->parent_paragraph) Numbering__settle_paragraph_number(P->parent_paragraph);
	CSTRING_WRITE(P->paragraph_number, "%s.%d", P->parent_paragraph->paragraph_number,
			P->parent_paragraph->next_child_number++);
	P->next_child_number = 1;
}

#line 13 "inweb/Chapter 3/The Analyser.w"
void Analyser__catalogue_the_sections(web *W, char *sigil, int functions_too) {
	for (chapter *C = W->first_chapter; C; C = C->next_chapter)
		if ((CStrings__eq(sigil, "0")) || (CStrings__eq(sigil, C->ch_sigil))) {
			printf("      %-9s  %-50s  \n", "--------", "--------");
			for (section *S = C->first_section; S; S = S->next_section) {
				string main_title;
				CSTRING_WRITE(main_title, "Chapter %s/%s", C->ch_sigil, S->sect_title);
				printf("%4d  %-9s  %-50s  ", S->sect_extent, S->sigil, main_title);
				Languages__analysis(S->sect_language, S, functions_too);
				printf("\n");
			}
		}
}

#line 51 "inweb/Chapter 3/The Analyser.w"
void Analyser__analyse_code(web *W) {
	if (W->analysed) return;

	
{
#line 81 "inweb/Chapter 3/The Analyser.w"
	Languages__analyse_code(W->main_language, W);

	LOOP_WITHIN_TANGLE(W->first_target)
		if ((L->category == INTERFACE_BODY_LCAT) &&
			(L->interface_line_identified == FALSE) &&
			(ISORegexp__string_is_white_space(L->text) == FALSE))
			Main__error_in_web("unrecognised interface line", L);

}
#line 54 "inweb/Chapter 3/The Analyser.w"
;

	LOOP_WITHIN_TANGLE(W->first_target)
		switch (L->category) {
			case BEGIN_DEFINITION_LCAT:
				
{
#line 97 "inweb/Chapter 3/The Analyser.w"
	Analyser__analyse_as_code(W, L, L->text_operand2, ANY_USAGE, 0);
	while ((L->next_line) && (L->next_line->category == CONT_DEFINITION_LCAT)) {
		L = L->next_line;
		Analyser__analyse_as_code(W, L, L->text, ANY_USAGE, 0);
	}

}
#line 59 "inweb/Chapter 3/The Analyser.w"
;
				break;
			case CODE_BODY_LCAT:
				
{
#line 92 "inweb/Chapter 3/The Analyser.w"
	Analyser__analyse_as_code(W, L, L->text, ANY_USAGE, 0);

}
#line 62 "inweb/Chapter 3/The Analyser.w"
;
				break;
			case PREFORM_GRAMMAR_LCAT:
				
{
#line 110 "inweb/Chapter 3/The Analyser.w"
	Analyser__analyse_as_code(W, L, L->text_operand2, ANY_USAGE, 0);
	Analyser__analyse_as_code(W, L, L->text_operand, PREFORM_IN_CODE_USAGE, PREFORM_IN_GRAMMAR_USAGE);

}
#line 65 "inweb/Chapter 3/The Analyser.w"
;
				break;
		}

	Languages__post_analysis(W->main_language, W);
	W->analysed = TRUE;
}

#line 126 "inweb/Chapter 3/The Analyser.w"
void Analyser__analyse_as_code(web *W, source_line *L, char *text, int mask, int transf) {
	int start_at = -1, element_follows = FALSE;
	for (int i = 0; text[i]; i++) {
		if ((ISORegexp__identifier_char(text[i])) || ((text[i] == '-') && (text[i+1] != '>'))) {
			if (start_at == -1) start_at = i;
		} else {
			if (start_at != -1) {
				int u = MISC_USAGE;
				if (element_follows) u = ELEMENT_ACCESS_USAGE;
				else if (text[i] == '(') u = FCALL_USAGE;
				else if ((text[i] == '>') && (start_at > 0) && (text[start_at-1] == '<'))
					u = PREFORM_IN_CODE_USAGE;
				if (u & mask) {
					if (transf) u = transf;
					string identifier_found; CStrings__copy(identifier_found, "");
					int j;
					for (j = 0; start_at + j < i; j++)
						CStrings__set_char(identifier_found, j, text[start_at + j]);
					CStrings__truncate(identifier_found, j);
					Analyser__analyse_find(W, L, identifier_found, u);
				}
				start_at = -1; element_follows = FALSE;
			}
			if (text[i] == '.') element_follows = TRUE;
			else if ((text[i] == '-') && (text[i+1] == '>')) {
				element_follows = TRUE; i++;
			} else element_follows = FALSE;
		}
	}
}

#line 168 "inweb/Chapter 3/The Analyser.w"
int Analyser__hash_code_from_word(char *text) {
    unsigned int hash_code = 0;
    char *p = text;
    switch(*p) {
    	case '-': if (p[1] == 0) break; /* an isolated minus sign is an ordinary word */
    		/* and otherwise fall into... */
    	case '0': case '1': case '2': case '3': case '4':
    	case '5': case '6': case '7': case '8': case '9':
    		/* the first character may prove to be the start of a number: is this true? */
			for (p++; *p; p++) if (isdigit(*p) == FALSE) break;
			return NUMBER_HASH;
    }
    for (p=text; *p; p++) hash_code = (unsigned int) ((int) (hash_code*30011) + (*p));
    return (int) (1+(hash_code % (HASH_TAB_SIZE-1))); /* result of X 30011, plus 1 */
}

#line 191 "inweb/Chapter 3/The Analyser.w"

#line 203 "inweb/Chapter 3/The Analyser.w"

#line 210 "inweb/Chapter 3/The Analyser.w"
hash_table_entry *Analyser__find_hash_entry(section *S, char *text, int create) {
	hash_table *HT = &(S->sect_target->symbols);
	int h = Analyser__hash_code_from_word(text);
	if (h == NUMBER_HASH) return NULL;
	if (HT->analysis_hash_initialised == FALSE) {
		for (int i=0; i<HASH_TAB_SIZE; i++) HT->analysis_hash[i] = NULL;
		HT->analysis_hash_initialised = TRUE;
	}
	hash_table_entry *hte = NULL;
	for (hte = HT->analysis_hash[h]; hte; hte = hte->next_in_hash)
		if (CStrings__eq(hte->hash_key, text))
			break;
	if ((hte == NULL) && (create)) {
		hte = CREATE(hash_table_entry);
		hte->hash_key = Memory__new_string(text);
		hte->next_in_hash = HT->analysis_hash[h];
		hte->first_usage = NULL;
		hte->last_usage = NULL;
		HT->analysis_hash[h] = hte;
	}
	return hte;
}

#line 236 "inweb/Chapter 3/The Analyser.w"
void Analyser__mark_reserved_word(section *S, char *p, int e) {
	hash_table_entry *hte = Analyser__find_hash_entry(S, p, TRUE);
	hte->reserved_word |= (1 << e);
}

int Analyser__is_reserved_word(section *S, char *p, int e) {
	hash_table_entry *hte = Analyser__find_hash_entry(S, p, FALSE);
	if ((hte) && (hte->reserved_word & (1 << e))) return TRUE;
	return FALSE;
}

#line 261 "inweb/Chapter 3/The Analyser.w"

#line 265 "inweb/Chapter 3/The Analyser.w"
void Analyser__analyse_find(web *W, source_line *L, char *identifier, int u) {
	hash_table_entry *hte = Analyser__find_hash_entry(L->owning_section, identifier, FALSE);
	if (hte == NULL) return;
	hash_table_entry_usage *hteu = NULL;
	for (hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
		if (L->owning_paragraph == hteu->usage_recorded_at)
			break;
	if (hteu == NULL) {
		hteu = CREATE(hash_table_entry_usage);
		hteu->form_of_usage = 0;
		hteu->next_usage = NULL;
		hteu->usage_recorded_at = L->owning_paragraph;
		if (hte->first_usage == NULL) hte->first_usage = hteu;
		else hte->last_usage->next_usage = hteu;
		hte->last_usage = hteu;
	}
	hteu->form_of_usage |= u;
}

#line 19 "inweb/Chapter 3/The Swarm.w"
weave_target *swarm_leader = NULL; /* the most inclusive one we weave */

void Swarm__weave(web *W, char *subweb, int swarm_mode, theme_tag *tag, char *format) {
	swarm_leader = NULL;

	if ((swarm_mode & SWARM_CHAPTERS) || (swarm_mode & SWARM_SECTIONS)) {
		/* weave Complete web */
		if (swarm_mode & SWARM_COMPLETE)
			if (CStrings__eq(subweb, "0"))
				swarm_leader = Swarm__weave_subset(W, "0", FALSE, tag, format);

		for (chapter *C = W->first_chapter; C; C = C->next_chapter)
			if (C->imported == FALSE) {
				if (swarm_mode & SWARM_CHAPTERS) {
					/* weave single chapter */
					if ((W->chaptered == TRUE) && (Reader__sigil_within(C->ch_sigil, subweb))) {
						C->ch_weave = Swarm__weave_subset(W, C->ch_sigil, FALSE, tag, format);
						if (CStrings__ne(subweb, "")) swarm_leader = C->ch_weave;
					}
				}
				if (swarm_mode & SWARM_SECTIONS) {
					/* weave individual sections */
					for (section *S = C->first_section; S; S = S->next_section)
						if (Reader__sigil_within(S->sigil, subweb))
							S->sect_weave = Swarm__weave_subset(W, S->sigil, FALSE, tag, format);
				}
			}
	}

	Swarm__weave_index_templates(W, subweb, format);
}

#line 56 "inweb/Chapter 3/The Swarm.w"
weave_target *Swarm__weave_subset(web *W, char *subweb, int open_afterwards, theme_tag *tag, char *format) {
	weave_target *wv = NULL;
	if (no_inweb_errors == 0) {
		Analyser__analyse_code(W);
		
{
#line 87 "inweb/Chapter 3/The Swarm.w"
	wv = CREATE(weave_target);
	wv->weave_web = W;
	CStrings__copy(wv->weave_sigil, subweb);
	wv->theme_match = tag;
	CStrings__copy(wv->booklet_title, "");
	wv->format = Formats__parse_format(format);
	wv->post_processing_results = NULL;
	wv->cover_sheet_to_use = NULL;
	if ((tag) && (tag->cover_sheet_when_woven[0])) {
		pathname *P = Pathnames__subfolder(W->path_to_web, "Materials");
		wv->cover_sheet_to_use =
			Filenames__in_folder(P, wv->theme_match->cover_sheet_when_woven);
	} else {
		wv->cover_sheet_to_use =
			Filenames__in_folder(path_to_inweb_materials, "cover-sheet");
	}

	string leafname; CStrings__copy(leafname, "");
	
{
#line 114 "inweb/Chapter 3/The Swarm.w"
	if (CStrings__eq(subweb, "0")) {
		CStrings__copy(wv->booklet_title, "Complete Program");
		CStrings__copy(leafname, "Complete");
		if ((wv->theme_match) && (wv->theme_match->title_when_woven[0]))
			CStrings__copy(wv->booklet_title, wv->theme_match->title_when_woven);
		if ((wv->theme_match) && (wv->theme_match->leafname_when_woven[0]))
			CSTRING_WRITE(leafname, "%s", wv->theme_match->leafname_when_woven);
	} else if (ISORegexp__match_0(subweb, "%d+")) {
		CSTRING_WRITE(wv->booklet_title, "Chapter %s", subweb);
		CStrings__copy(leafname, wv->booklet_title);
	} else if (ISORegexp__match_0(subweb, "%[A-O]")) {
		CSTRING_WRITE(wv->booklet_title, "Appendix %s", subweb);
		CStrings__copy(leafname, wv->booklet_title);
	} else if (CStrings__eq(subweb, "P")) {
		CStrings__copy(wv->booklet_title, "Preliminaries");
		CStrings__copy(leafname, wv->booklet_title);
	} else {
		CSTRING_WRITE(wv->booklet_title, "%s", subweb);
		CStrings__copy(leafname, wv->booklet_title);
		wv->cover_sheet_to_use = NULL;
	}
	for (int i=0; leafname[i]; i++)
		if ((leafname[i] == '/') || (leafname[i] == ' '))
			CStrings__set_char(leafname, i, '-');
	CStrings__concatenate(leafname, Formats__weave_file_extension(wv->format));

}
#line 105 "inweb/Chapter 3/The Swarm.w"
;
	pathname *H = W->redirect_weaves_to;
	if (H == NULL) H = Pathnames__subfolder(W->path_to_web, "Woven");
	wv->weave_to = Filenames__in_folder(H, leafname);

}
#line 60 "inweb/Chapter 3/The Swarm.w"
;
		if (Weaver__weave_source(W, wv) == 0) /* i.e., the number of lines woven was zero */
			Errors__fatal("empty weave request");
		Formats__post_process_weave(wv, open_afterwards); /* e.g., run through |TeX| */
		
{
#line 143 "inweb/Chapter 3/The Swarm.w"
	printf("[%s: %s", wv->booklet_title, wv->format->format_name);
	Formats__report_on_post_processing(wv);
	printf("]\n");

}
#line 64 "inweb/Chapter 3/The Swarm.w"
;
	}
	return wv;
}

#line 83 "inweb/Chapter 3/The Swarm.w"

#line 151 "inweb/Chapter 3/The Swarm.w"
void Swarm__weave_index_templates(web *W, char *subweb, char *format) {
	
{
#line 159 "inweb/Chapter 3/The Swarm.w"
	if (Bibliographic__data_exists(W, "Index Template")) {
		string temp_list; CStrings__copy(temp_list, "");
		CStrings__copy(temp_list, Bibliographic__get_data(W, "Index Template"));
		while (temp_list[0]) {
			string found_text1;
			string found_text2;
			filename *index_to_make = NULL;
			if (ISORegexp__match_2(temp_list, "(%c+?), (%c+)", found_text1, found_text2)) {
				index_to_make = Filenames__from_string(found_text1);
				CStrings__copy(temp_list, found_text2);
			} else {
				index_to_make = Filenames__from_string(temp_list);
				CStrings__copy(temp_list, "");
			}
			Swarm__run_contents_interpreter(W, subweb, index_to_make, Filenames__get_leafname(index_to_make));
		}
	} else {
		char *index_leaf = NULL;
		if (Formats__index_pdfs(format)) {
			if (W->chaptered) 	index_leaf = "chaptered-tex-index.html";
			else 				index_leaf = "unchaptered-tex-index.html";
		} else {
			if (W->chaptered) 	index_leaf = "chaptered-index.html";
			else 				index_leaf = "unchaptered-index.html";
		}
		if (W->as_ebook) index_leaf = "epub-index.html";
		filename *OUT = Filenames__in_folder(path_to_inweb_materials, index_leaf);
		Swarm__run_contents_interpreter(W, subweb, OUT, Str__new_from_ISO_string("index.html"));
	}

}
#line 152 "inweb/Chapter 3/The Swarm.w"
;
	
{
#line 193 "inweb/Chapter 3/The Swarm.w"
	string copy_list; CStrings__copy(copy_list, "");
	if (Bibliographic__data_exists(W, "Index Extras")) {
		CStrings__copy(copy_list, Bibliographic__get_data(W, "Index Extras"));
		Swarm__copy_files_into_weave(W, copy_list);
	} else {
		if (W->as_ebook) {
			filename *F = Filenames__in_folder(path_to_inweb_materials, "crumbs.gif");
			Swarm__copy_file_into_weave(W, F);
			Epub__note_image(W->as_ebook, F);
		} else {
			Swarm__copy_file_into_weave(W, Filenames__in_folder(path_to_inweb_materials, "download.gif"));
			Swarm__copy_file_into_weave(W, Filenames__in_folder(path_to_inweb_materials, "lemons.jpg"));
			Swarm__copy_file_into_weave(W, Filenames__in_folder(path_to_inweb_materials, "crumbs.gif"));
			Swarm__copy_file_into_weave(W, Filenames__in_folder(path_to_inweb_materials, "inweb.css"));
		}
	}

}
#line 153 "inweb/Chapter 3/The Swarm.w"
;
}

#line 213 "inweb/Chapter 3/The Swarm.w"
void Swarm__copy_files_into_weave(web *W, char *copy_list) {
	while (CStrings__ne(copy_list, "")) {
		string file_to_copy; CStrings__copy(file_to_copy, "");
		string found_text1;
		string found_text2;
		if (ISORegexp__match_2(copy_list, "(%c+?), (%c+)", found_text1, found_text2)) {
			CStrings__copy(file_to_copy, found_text1);
			CStrings__copy(copy_list, found_text2);
		} else {
			CStrings__copy(file_to_copy, copy_list);
			CStrings__copy(copy_list, "");
		}
		filename *OUT = Filenames__from_string(file_to_copy);
		Swarm__copy_file_into_weave(W, OUT);
	}
}

void Swarm__copy_file_into_weave(web *W, filename *F) {
	pathname *H = W->redirect_weaves_to;
	if (H == NULL) H = Pathnames__subfolder(W->path_to_web, "Woven");
	Shell__copy(F, H, "");
}

#line 259 "inweb/Chapter 3/The Swarm.w"

#line 263 "inweb/Chapter 3/The Swarm.w"
contents_processor *cp = NULL;

void Swarm__run_contents_interpreter(web *W, char *subset,
	filename *template_filename, text_stream *contents_page_leafname) {
	PRINT("Weaving index file: %S\n", contents_page_leafname);
	contents_processor actual_cp; cp = &actual_cp;
	text_stream TO_struct;
	text_stream *OUT = &TO_struct;
	cp->no_tlines = 0;
	cp->restrict_to_subweb = subset;
	
{
#line 304 "inweb/Chapter 3/The Swarm.w"
	TextFiles__read_with_lines_to_ISO(template_filename,
		"can't find contents template", TRUE, Swarm__save_template_line, NULL, NULL);
	if (TRACE_CI_EXECUTION)
		PRINT("Read template <%f>: %d line(s)\n", template_filename, cp->no_tlines);

}
#line 273 "inweb/Chapter 3/The Swarm.w"
;
	
{
#line 320 "inweb/Chapter 3/The Swarm.w"
	pathname *H = W->redirect_weaves_to;
	if (H == NULL) H = Pathnames__subfolder(W->path_to_web, "Woven");
	filename *Contents = Filenames__in_folder_S(H, contents_page_leafname);
	if (STREAM_OPEN_TO_FILE(OUT, Contents, ISO_ENC) == FALSE)
		Errors__fatal_with_file("unable to write contents file", Contents);
	if (W->as_ebook)
		Epub__note_page(W->as_ebook, Contents, "Index", "index");

}
#line 274 "inweb/Chapter 3/The Swarm.w"
;

	int lpos = 0; /* This is our program counter: a line number in the template */
	cp->stack_pointer = 0; /* And this is our stack pointer for tracking of loops */
	while (lpos < cp->no_tlines) {
		string tl;
		CStrings__copy(tl, cp->tlines[lpos++]); /* Fetch the line at the program counter and advance */
		string found_text1;
		if (ISORegexp__match_1(tl, "(%c*?) ", found_text1)) CStrings__copy(tl, found_text1); /* Strip trailing spaces */
		if (TRACE_CI_EXECUTION)
			
{
#line 331 "inweb/Chapter 3/The Swarm.w"
	printf("%04d: %s\nStack:", lpos-1, tl);
	for (int j=0; j<cp->stack_pointer; j++) {
		if (cp->repeat_stack_level[j] == CHAPTER_LEVEL)
			printf(" %d: %s/%s",
				j, ((chapter *) cp->repeat_stack_variable[j])->ch_sigil,
				((chapter *) cp->repeat_stack_threshold[j])->ch_sigil);
		else if (cp->repeat_stack_level[j] == SECTION_LEVEL)
			printf(" %d: %s/%s",
				j, ((section *) cp->repeat_stack_variable[j])->sigil,
				((section *) cp->repeat_stack_threshold[j])->sigil);
	}
	printf("\n");

}
#line 284 "inweb/Chapter 3/The Swarm.w"
;
		if ((ISORegexp__match_1(tl, "%[%[(%c+)%]%]", found_text1)) ||
			(ISORegexp__match_1(tl, " %[%[(%c+)%]%]", found_text1))) {
			string command; CStrings__copy(command, found_text1);
			
{
#line 349 "inweb/Chapter 3/The Swarm.w"
	string found_text1;
	if (ISORegexp__match_1(command, "Select (%c*)", found_text1)) {
		string sigil; CStrings__copy(sigil, found_text1);
		section *S;
		LOOP_OVER(S, section)
			if (CStrings__eq(S->sigil, sigil)) {
				Swarm__start_CI_loop(SECTION_LEVEL, S, S, lpos);
				goto CYCLE;
			}
		chapter *C;
		LOOP_OVER(C, chapter)
			if (CStrings__eq(C->ch_sigil, sigil)) {
				Swarm__start_CI_loop(CHAPTER_LEVEL, C, C, lpos);
				goto CYCLE;
			}
		Errors__at_position("don't recognise the chapter or section abbreviation sigil",
			template_filename, lpos);
		goto CYCLE;
	}

}
#line 288 "inweb/Chapter 3/The Swarm.w"
;
			
{
#line 372 "inweb/Chapter 3/The Swarm.w"
	int loop_level = 0;
	if (ISORegexp__match_0(command, "Repeat Chapter")) loop_level = CHAPTER_LEVEL;
	if (ISORegexp__match_0(command, "Repeat Section")) loop_level = SECTION_LEVEL;
	if (loop_level != 0) {
		void *from = NULL, *to = NULL;
		chapter *C = W->first_chapter;
		while ((C) && (C->imported)) C = C->next_chapter;
		if (loop_level == CHAPTER_LEVEL) {
			from = C;
			to = W->last_chapter;
			if (CStrings__ne(cp->restrict_to_subweb, "0")) {
				chapter *C;
				LOOP_OVER(C, chapter)
					if (CStrings__eq(C->ch_sigil, cp->restrict_to_subweb)) {
						from = C; to = C;
						break;
					}
			}
		}
		if (loop_level == SECTION_LEVEL) {
			chapter *within_chapter = Swarm__heading_topmost_on_stack(CHAPTER_LEVEL);
			if (within_chapter == NULL) {
				if (C) from = C->first_section;
				if (W->last_chapter) to = W->last_chapter->last_section;
			} else {
				from = within_chapter->first_section;
				to = within_chapter->last_section;
			}
		}
		if (from) Swarm__start_CI_loop(loop_level, from, to, lpos);
		goto CYCLE;
	}

}
#line 289 "inweb/Chapter 3/The Swarm.w"
;
			
{
#line 408 "inweb/Chapter 3/The Swarm.w"
	if ((ISORegexp__match_0(command, "End Repeat")) || (ISORegexp__match_0(command, "End Select"))) {
		if (cp->stack_pointer <= 0)
			Errors__at_position("stack underflow on contents template", template_filename, lpos);
		if (cp->repeat_stack_level[cp->stack_pointer-1] == SECTION_LEVEL) {
			section *S = cp->repeat_stack_variable[cp->stack_pointer-1];
			if (S == cp->repeat_stack_threshold[cp->stack_pointer-1])
				Swarm__end_CI_loop();
			else {
				cp->repeat_stack_variable[cp->stack_pointer-1] = S->next_section;
				lpos = cp->repeat_stack_startpos[cp->stack_pointer-1]; /* Back round loop */
			}
		} else {
			chapter *C = cp->repeat_stack_variable[cp->stack_pointer-1];
			if (C == cp->repeat_stack_threshold[cp->stack_pointer-1])
				Swarm__end_CI_loop();
			else {
				cp->repeat_stack_variable[cp->stack_pointer-1] = C->next_chapter;
				lpos = cp->repeat_stack_startpos[cp->stack_pointer-1]; /* Back round loop */
			}
		}
		goto CYCLE;
	}

}
#line 290 "inweb/Chapter 3/The Swarm.w"
;
		}
		
{
#line 434 "inweb/Chapter 3/The Swarm.w"
	for (int rstl = cp->stack_pointer-1; rstl >= 0; rstl--)
		if ((cp->repeat_stack_level[cp->stack_pointer-1] == SECTION_LEVEL) &&
			(((section *) cp->repeat_stack_threshold[cp->stack_pointer-1])->next_section ==
			cp->repeat_stack_variable[cp->stack_pointer-1]))
				goto CYCLE;

}
#line 292 "inweb/Chapter 3/The Swarm.w"
;
		
{
#line 477 "inweb/Chapter 3/The Swarm.w"
	int slen, spos;
	while ((spos = ISORegexp__find_expansion(tl, '[', '[', ']', ']', &slen)) >= 0) {
		string left_part; CStrings__copy(left_part, tl); CStrings__truncate(left_part, spos);
		string varname; CStrings__copy(varname, tl+spos+2); CStrings__truncate(varname, slen-4);
		string substituted; CStrings__copy(substituted, varname);
		string right_part; CStrings__copy(right_part, tl+spos+slen);
		string found_text1;
		if (Bibliographic__data_exists(W, varname)) {
			
{
#line 512 "inweb/Chapter 3/The Swarm.w"
	CStrings__copy(substituted, Bibliographic__get_data(W, varname));

}
#line 485 "inweb/Chapter 3/The Swarm.w"
;
		} else if (ISORegexp__match_1(varname, "Chapter (%c+)", found_text1)) {
			string detail; CStrings__copy(detail, found_text1);
			chapter *C = Swarm__heading_topmost_on_stack(CHAPTER_LEVEL);
			if (C == NULL)
				Errors__at_position("no chapter is currently selected",
					template_filename, lpos);
			else 
{
#line 524 "inweb/Chapter 3/The Swarm.w"
	if (CStrings__eq(detail, "Title")) {
		CStrings__copy(substituted, C->ch_title);
	} else if (CStrings__eq(detail, "Code")) {
		CStrings__copy(substituted, C->ch_sigil);
	} else if (CStrings__eq(detail, "Purpose")) {
		CStrings__copy(substituted, C->rubric);
	} else if (Formats__substitute_post_processing_data(substituted, C->ch_weave, detail)) {
		;
	} else {
		CSTRING_WRITE(substituted, "%s for %s", varname, C->ch_title);
	}

}
#line 492 "inweb/Chapter 3/The Swarm.w"
;
		} else if (ISORegexp__match_1(varname, "Section (%c+)", found_text1)) {
			string detail; CStrings__copy(detail, found_text1);
			section *S = Swarm__heading_topmost_on_stack(SECTION_LEVEL);
			if (S == NULL)
				Errors__at_position("no section is currently selected",
					template_filename, lpos);
			else 
{
#line 539 "inweb/Chapter 3/The Swarm.w"
	if (CStrings__eq(detail, "Title")) {
		CStrings__copy(substituted, S->sect_title);
	} else if (CStrings__eq(detail, "Purpose")) {
		CStrings__copy(substituted, S->sect_purpose);
	} else if (CStrings__eq(detail, "Code")) {
		CStrings__copy(substituted, S->sigil);
	} else if (CStrings__eq(detail, "Lines")) {
		CSTRING_WRITE(substituted, "%d", S->sect_extent);
	} else if (CStrings__eq(detail, "Source")) {
		Filenames__to_string(substituted, S->source_file_for_section);
	} else if (CStrings__eq(detail, "Page")) {
		string linkto; CStrings__copy(linkto, S->sigil);
		for (int i=0; linkto[i]; i++)
			if ((linkto[i] == '/') || (linkto[i] == ' '))
				CStrings__set_char(linkto, i, '-');
		CStrings__concatenate(linkto, ".html");
		CStrings__copy(substituted, linkto);
	} else if (CStrings__eq(detail, "Paragraphs")) {
		CSTRING_WRITE(substituted, "%d", S->sect_paragraphs);
	} else if (CStrings__eq(detail, "Mean")) {
		int denom = S->sect_paragraphs;
		if (denom == 0) denom = 1;
		CSTRING_WRITE(substituted, "%d", S->sect_extent/denom);
	} else if (Formats__substitute_post_processing_data(substituted, S->sect_weave, detail)) {
		;
	} else {
		CSTRING_WRITE(substituted, "%s for %s", varname, S->sect_title);
	}

}
#line 499 "inweb/Chapter 3/The Swarm.w"
;
		} else if (ISORegexp__match_1(varname, "Complete (%c+)", found_text1)) {
			string detail; CStrings__copy(detail, found_text1);
			
{
#line 517 "inweb/Chapter 3/The Swarm.w"
	if (swarm_leader)
		if (Formats__substitute_post_processing_data(substituted, swarm_leader, detail) == FALSE)
			CSTRING_WRITE(substituted, "%s for complete web", detail);

}
#line 502 "inweb/Chapter 3/The Swarm.w"
;
		} else {
			CSTRING_WRITE(substituted, "<b>%s</b>", varname);
		}
		CSTRING_WRITE(tl, "%s%s%s", left_part, substituted, right_part);
	}

}
#line 293 "inweb/Chapter 3/The Swarm.w"
;
		WRITE("%s\n", tl); /* Copy the now finished line to the output */

		CYCLE: ;
	}
	STREAM_CLOSE(OUT);
}

#line 312 "inweb/Chapter 3/The Swarm.w"
void Swarm__save_template_line(char *line, text_file_position *tfp, void *unused_state) {
	if (cp->no_tlines < MAX_TEMPLATE_LINES)
		cp->tlines[cp->no_tlines++] = Memory__new_string(line);
}

#line 444 "inweb/Chapter 3/The Swarm.w"
void *Swarm__heading_topmost_on_stack(int level) {
	for (int rstl = cp->stack_pointer-1; rstl >= 0; rstl--)
		if (cp->repeat_stack_level[rstl] == level)
			return cp->repeat_stack_variable[rstl];
	return NULL;
}

#line 458 "inweb/Chapter 3/The Swarm.w"
void Swarm__start_CI_loop(int level, void *from, void *to, int pos) {
	if (cp->stack_pointer < CI_STACK_CAPACITY) {
		cp->repeat_stack_level[cp->stack_pointer] = level;
		cp->repeat_stack_variable[cp->stack_pointer] = from;
		cp->repeat_stack_threshold[cp->stack_pointer] = to;
		cp->repeat_stack_startpos[cp->stack_pointer++] = pos;
	}
}

void Swarm__end_CI_loop(void) {
	cp->stack_pointer--;
}

#line 16 "inweb/Chapter 3/The Weaver.w"
int Weaver__weave_source(web *W, weave_target *wv) {
	text_stream TO_struct;
	text_stream *OUT = &TO_struct;
	if (STREAM_OPEN_TO_FILE(OUT, wv->weave_to, UTF8_ENC) == FALSE)
		Errors__fatal_with_file("unable to write woven file", wv->weave_to);

	string banner;
	CSTRING_WRITE(banner, "Weave of '%s' generated by %s", wv->booklet_title, INWEB_BUILD);
	Formats__top(OUT, wv, banner);

	if (wv->cover_sheet_to_use) 
{
#line 748 "inweb/Chapter 3/The Weaver.w"
	Bibliographic__set_datum(W, "Booklet Title", wv->booklet_title);
	Weaver__weave_cover_from(OUT, W, wv->cover_sheet_to_use, wv, WEAVE_FIRST_HALF);

}
#line 26 "inweb/Chapter 3/The Weaver.w"
;
	int lines_woven = 0;
	
{
#line 42 "inweb/Chapter 3/The Weaver.w"
	weaver_state state_at; weaver_state *state = &state_at;
	
{
#line 82 "inweb/Chapter 3/The Weaver.w"
	state->kind_of_material = REGULAR_MATERIAL;
	state->line_break_pending = FALSE;
	state->weaving_suspended = FALSE;
	state->next_heading_without_vertical_skip = FALSE;
	state->show_section_toc_soon = FALSE;
	state->horizontal_rule_just_drawn = FALSE;
	state->last_extract_from = NULL;
	state->last_endnoted_para = NULL;
	state->substantive_comment = FALSE;
	CStrings__copy(state->chaptermark, "");
	CStrings__copy(state->sectionmark, "");

}
#line 43 "inweb/Chapter 3/The Weaver.w"
;
	for (chapter *C = W->first_chapter; C; C = C->next_chapter) {
		if (C->imported == FALSE) {
			CStrings__copy(state->chaptermark, "");
			for (section *S = C->first_section; S; S = S->next_section)
				if (Reader__sigil_within(S->sigil, wv->weave_sigil))
					
{
#line 97 "inweb/Chapter 3/The Weaver.w"
	Languages__begin_weave(S, wv);
	CStrings__copy(state->sectionmark, "");
	paragraph *current_paragraph = NULL;
	for (source_line *L = S->first_line; L; L = L->next_line) {
		if ((Parser__is_tagged_with(L, wv->theme_match)) &&
			(Languages__skip_in_weaving(S->sect_language, wv, L) == FALSE)) {
			lines_woven++;

			/* In principle, all of these source lines should be woven, but... */
			
{
#line 134 "inweb/Chapter 3/The Weaver.w"
	if (L->category == TOGGLE_WEAVING_LCAT) {
		if (state->weaving_suspended == FALSE) {
			Formats__code_note(OUT, wv, "...and so on...");
			state->weaving_suspended = TRUE;
			continue;
		}
		state->weaving_suspended = FALSE;
		continue;
	}
	if (state->weaving_suspended) continue;

}
#line 106 "inweb/Chapter 3/The Weaver.w"
;
			
{
#line 148 "inweb/Chapter 3/The Weaver.w"
	if (L->category == INTERFACE_BODY_LCAT) continue;
	if (L->category == PURPOSE_BODY_LCAT) continue;
	if (L->category == BEGIN_VERBATIM_LCAT) continue;

}
#line 107 "inweb/Chapter 3/The Weaver.w"
;
			
{
#line 156 "inweb/Chapter 3/The Weaver.w"
	if (L->category == COMMAND_LCAT) {
		if (L->command_code == PAGEBREAK_CMD) Formats__pagebreak(OUT, wv);
		if (L->command_code == GRAMMAR_INDEX_CMD) CForInform__weave_grammar_index(OUT);
		if (L->command_code == FIGURE_CMD) 
{
#line 167 "inweb/Chapter 3/The Weaver.w"
	char *figname = L->text_operand;
	string found_text1;
	string found_text2;
	if (ISORegexp__match_2(figname, "(%d+)cm: (%c+)", found_text1, found_text2))
		Formats__figure(OUT, wv, found_text2, atoi(found_text1));
	else
		Formats__figure(OUT, wv, figname, -1);

}
#line 159 "inweb/Chapter 3/The Weaver.w"
;
		/* Otherwise assume it was a tangler command, and ignore it here */
		continue;
	}

}
#line 108 "inweb/Chapter 3/The Weaver.w"
;

			/* Some of the more baroque front matter of a section... */
			
{
#line 181 "inweb/Chapter 3/The Weaver.w"
	if (L->category == PURPOSE_LCAT) {
		Formats__subheading(OUT, wv, 2, "Purpose", S->sect_purpose);
		Weaver__weave_table_of_contents(OUT, wv, S);
		continue;
	}

}
#line 111 "inweb/Chapter 3/The Weaver.w"
;
			
{
#line 190 "inweb/Chapter 3/The Weaver.w"
	if ((state->show_section_toc_soon == 1) && (ISORegexp__string_is_white_space(L->text))) {
		state->show_section_toc_soon = FALSE;
		if (Weaver__weave_table_of_contents(OUT, wv, S)) {
			state->horizontal_rule_just_drawn = TRUE;
		} else {
			state->horizontal_rule_just_drawn = FALSE;
		}
	}

}
#line 112 "inweb/Chapter 3/The Weaver.w"
;
			
{
#line 205 "inweb/Chapter 3/The Weaver.w"
	if (L->category == INTERFACE_LCAT) {
		state->horizontal_rule_just_drawn = FALSE;
		L = Weaver__weave_interface_table_for_section(OUT, wv, L);
		continue;
	}

}
#line 113 "inweb/Chapter 3/The Weaver.w"
;
			
{
#line 214 "inweb/Chapter 3/The Weaver.w"
	if (L->category == DEFINITIONS_LCAT) {
		Formats__subheading(OUT, wv, 2, "Definitions", NULL);
		state->next_heading_without_vertical_skip = TRUE;
		state->horizontal_rule_just_drawn = FALSE;
		continue;
	}

}
#line 114 "inweb/Chapter 3/The Weaver.w"
;
			
{
#line 225 "inweb/Chapter 3/The Weaver.w"
	if (L->category == BAR_LCAT) {
		
{
#line 579 "inweb/Chapter 3/The Weaver.w"
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != REGULAR_MATERIAL) {
		state->kind_of_material = REGULAR_MATERIAL;
		Formats__change_mode(OUT, wv, mode_now, state->kind_of_material, TRUE);
	}
	if ((current_paragraph) && (current_paragraph != state->last_endnoted_para)) {
		state->last_endnoted_para = current_paragraph;
		Weaver__show_endnotes_on_previous_paragraph(OUT, wv, current_paragraph);
	}
	if (L) current_paragraph = L->owning_paragraph;

}
#line 226 "inweb/Chapter 3/The Weaver.w"
;
		state->kind_of_material = REGULAR_MATERIAL;
		state->next_heading_without_vertical_skip = TRUE;
		if (state->horizontal_rule_just_drawn == FALSE) Formats__bar(OUT, wv);
		continue;
	}

}
#line 115 "inweb/Chapter 3/The Weaver.w"
;

			/* The crucial junction point between modes... */
			
{
#line 445 "inweb/Chapter 3/The Weaver.w"
	if ((L->category == PB_PARAGRAPH_START_LCAT) ||
		(L->category == PARAGRAPH_START_LCAT) ||
		(L->category == CHAPTER_HEADING_LCAT) ||
		(L->category == SECTION_HEADING_LCAT)) {
		
{
#line 579 "inweb/Chapter 3/The Weaver.w"
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != REGULAR_MATERIAL) {
		state->kind_of_material = REGULAR_MATERIAL;
		Formats__change_mode(OUT, wv, mode_now, state->kind_of_material, TRUE);
	}
	if ((current_paragraph) && (current_paragraph != state->last_endnoted_para)) {
		state->last_endnoted_para = current_paragraph;
		Weaver__show_endnotes_on_previous_paragraph(OUT, wv, current_paragraph);
	}
	if (L) current_paragraph = L->owning_paragraph;

}
#line 449 "inweb/Chapter 3/The Weaver.w"
;
		if (wv->theme_match)
			
{
#line 502 "inweb/Chapter 3/The Weaver.w"
	if ((L->owning_paragraph) &&
		(L->owning_paragraph->starts_on_new_page)) Formats__pagebreak(OUT, wv);

}
#line 451 "inweb/Chapter 3/The Weaver.w"
;

		int weight = 0;
		if (L->category == PB_PARAGRAPH_START_LCAT) weight = 1;
		if (L->category == SECTION_HEADING_LCAT) weight = 2;
		if (L->category == CHAPTER_HEADING_LCAT) weight = 3;

		
{
#line 515 "inweb/Chapter 3/The Weaver.w"
	if (weight == 3) {
		CStrings__copy(state->chaptermark, L->text_operand);
		CStrings__copy(state->sectionmark, "");
	}
	if (weight == 2) {
		CStrings__copy(state->sectionmark, L->text_operand);
		if (S->sigil[0]) CStrings__copy(state->chaptermark, S->sigil);
		if (CStrings__ne(state->chaptermark, ""))
			CSTRING_WRITE(state->sectionmark, " - %s", L->text_operand);
	}

}
#line 458 "inweb/Chapter 3/The Weaver.w"
;

		char *TeX_macro = "";
		
{
#line 542 "inweb/Chapter 3/The Weaver.w"
	switch (weight) {
		case 0: TeX_macro = "weavesection"; break;
		case 1: TeX_macro = "weavesections"; break;
		case 2: TeX_macro = "weavesectionss"; break;
		default: TeX_macro = "weavesectionsss"; break;
	}
	if (wv->theme_match) 
{
#line 561 "inweb/Chapter 3/The Weaver.w"
	switch (weight) {
		case 0: TeX_macro = "tweavesection"; break;
		case 1: TeX_macro = "tweavesections"; break;
		case 2: TeX_macro = "tweavesectionss"; break;
		default: TeX_macro = "tweavesectionsss"; break;
	}
	if (weight >= 0) { weight = 0; }
	if (state->last_extract_from != S) {
		state->last_extract_from = S;
		Formats__pagebreak(OUT, wv);
		string extr; CSTRING_WRITE(extr, "From %s: %s", C->ch_title, S->sect_title);
		Formats__subheading(OUT, wv, 1, extr, C->ch_title);
	}

}
#line 548 "inweb/Chapter 3/The Weaver.w"
;
	if ((state->next_heading_without_vertical_skip) && (weight < 2)) {
		state->next_heading_without_vertical_skip = FALSE;
		switch (weight) {
			case 0: TeX_macro = "nsweavesection"; break;
			case 1: TeX_macro = "nsweavesections"; break;
		}
	}

}
#line 461 "inweb/Chapter 3/The Weaver.w"
;

		string heading_text;
		if (weight == 3) {
			string brief_title; CStrings__copy(brief_title, "");
			string found_text1;
			if (ISORegexp__match_1(C->ch_title, "%c*?: (%c*)", found_text1))
				CStrings__copy(brief_title, found_text1);
			else
				CStrings__copy(brief_title, C->ch_title);
			CSTRING_WRITE(heading_text, "%s: %s", C->ch_sigil, brief_title);
		} else {
			CStrings__copy(heading_text, L->text_operand);
		}

		Formats__paragraph_heading(OUT, wv, TeX_macro, S, L->owning_paragraph,
			heading_text, state->chaptermark, state->sectionmark, weight);

		if (weight == 0) state->substantive_comment = FALSE;
		else state->substantive_comment = TRUE;

		/* There's quite likely ordinary text on the line following the paragraph */
		/* start indication, too, so we need to weave this out: */

		if (CStrings__ne(L->text_operand2, "")) {
			string matter;
			CSTRING_WRITE(matter, "%s\n", L->text_operand2);
			Formats__identifier(OUT, wv, matter);
			state->substantive_comment = TRUE;
		}

		/* Chapter headings get a chapter title page, or possibly pages, too: */
		if (weight == 3) Formats__chapter_tp(OUT, wv, C);

		/* And that completes the new paragraph opening. */
		continue;
	}

}
#line 118 "inweb/Chapter 3/The Weaver.w"
;

			/* With all exotica dealt with, we now just have material to weave verbatim... */
			string matter; CStrings__copy(matter, L->text);
			if (L->is_commentary) 
{
#line 240 "inweb/Chapter 3/The Weaver.w"
	
{
#line 252 "inweb/Chapter 3/The Weaver.w"
	if (L->category == SOURCE_DISPLAY_LCAT) {
		Formats__display_line(OUT, wv, L->text_operand);
		continue;
	}

}
#line 240 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 261 "inweb/Chapter 3/The Weaver.w"
	if (ISORegexp__string_is_white_space(matter)) {
		if ((L->next_line) && (L->next_line->category == COMMENT_BODY_LCAT) &&
			(state->substantive_comment)) Formats__blank_line(OUT, wv, TRUE);
		continue;
	}

}
#line 241 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 271 "inweb/Chapter 3/The Weaver.w"
	string found_text1;
	string found_text2;
	if (ISORegexp__match_1(matter, "%(...%) (%c*)", found_text1)) { /* continue single */
		Formats__change_mode(OUT, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		Formats__item(OUT, wv, 1, "");
		CStrings__copy(matter, found_text1);
	} else if (ISORegexp__match_1(matter, "%(-...%) (%c*)", found_text1)) { /* continue double */
		Formats__change_mode(OUT, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		Formats__item(OUT, wv, 2, "");
		CStrings__copy(matter, found_text1);
	} else if (ISORegexp__match_2(matter, "%((%i+)%) (%c*)", found_text1, found_text2)) { /* begin single */
		Formats__change_mode(OUT, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		Formats__item(OUT, wv, 1, found_text1);
		CStrings__copy(matter, found_text2);
	} else if (ISORegexp__match_2(matter, "%(-(%i+)%) (%c*)", found_text1, found_text2)) { /* begin double */
		Formats__change_mode(OUT, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		Formats__item(OUT, wv, 2, found_text1);
		CStrings__copy(matter, found_text2);
	}

}
#line 242 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 303 "inweb/Chapter 3/The Weaver.w"
	string found_text1;
	string found_text2;
	if (ISORegexp__match_2(matter, "\t|(%c*)|(%c*?)", found_text1, found_text2)) {
		if (state->kind_of_material != CODE_MATERIAL) {
			Formats__change_mode(OUT, wv, state->kind_of_material, CODE_MATERIAL, TRUE);
			state->kind_of_material = CODE_MATERIAL;
		}
		string original; CStrings__copy(original, found_text1);
		CStrings__copy(matter, found_text2);
		string colouring;
		for (int i=0; original[i]; i++) colouring[i] = PLAIN_CODE;
		colouring[CStrings__len(original)] = 0;
		Formats__source_code(OUT, wv, 1, "", original, colouring, "", TRUE, TRUE, FALSE);
		Formats__identifier(OUT, wv, matter);
		continue;
	} else if (state->kind_of_material != REGULAR_MATERIAL) {
		Formats__change_mode(OUT, wv, state->kind_of_material, REGULAR_MATERIAL, TRUE);
		state->kind_of_material = REGULAR_MATERIAL;
	}

}
#line 243 "inweb/Chapter 3/The Weaver.w"
;
	state->substantive_comment = TRUE;
	CStrings__concatenate(matter, "\n");
	Formats__identifier(OUT, wv, matter);
	continue;

}
#line 122 "inweb/Chapter 3/The Weaver.w"

			else 
{
#line 329 "inweb/Chapter 3/The Weaver.w"
	
{
#line 372 "inweb/Chapter 3/The Weaver.w"
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != CODE_MATERIAL) {
		if (L->category == MACRO_DEFINITION_LCAT)
			state->kind_of_material = MACRO_MATERIAL;
		else if ((L->category == BEGIN_DEFINITION_LCAT) ||
				(L->category == CONT_DEFINITION_LCAT))
			state->kind_of_material = DEFINITION_MATERIAL;
		else
			state->kind_of_material = CODE_MATERIAL;
		Formats__change_mode(OUT, wv, mode_now, state->kind_of_material,
			state->substantive_comment);
		state->line_break_pending = FALSE;
	}

}
#line 329 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 390 "inweb/Chapter 3/The Weaver.w"
	if (state->line_break_pending) {
		Formats__blank_line(OUT, wv, FALSE);
		state->line_break_pending = FALSE;
	}
	if (ISORegexp__string_is_white_space(matter)) {
		state->line_break_pending = TRUE;
		continue;
	}

}
#line 330 "inweb/Chapter 3/The Weaver.w"
;

	int tab_stops_of_indentation = 0;
	
{
#line 403 "inweb/Chapter 3/The Weaver.w"
	int spaces_in = 0;
	while (ISORegexp__white_space(matter[0])) {
		if (matter[0] == '\t') {
			spaces_in = 0;
			tab_stops_of_indentation++;
		} else {
			spaces_in++;
			if (spaces_in == 4) {
				tab_stops_of_indentation++;
				spaces_in = 0;
			}
		}
		string dummy;
		CStrings__copy(dummy, matter+1);
		CStrings__copy(matter, dummy);
	}

}
#line 333 "inweb/Chapter 3/The Weaver.w"
;

	string prefatory; CStrings__copy(prefatory, "");
	string concluding_comment; CStrings__copy(concluding_comment, "");
	
{
#line 425 "inweb/Chapter 3/The Weaver.w"
	string part_before_comment; CStrings__copy(part_before_comment, "");
	string part_within_comment; CStrings__copy(part_within_comment, "");
	if (Languages__parse_comment(S->sect_language,
		matter, part_before_comment, part_within_comment)) {
		CStrings__copy(matter, part_before_comment);
		CStrings__copy(concluding_comment, part_within_comment);
	}

}
#line 337 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 436 "inweb/Chapter 3/The Weaver.w"
	string found_text1;
	if (ISORegexp__match_1(matter, "@d (%c*)", found_text1)) {
		CStrings__copy(prefatory, "define");
		CStrings__copy(matter, found_text1);
	}

}
#line 338 "inweb/Chapter 3/The Weaver.w"
;

	if (Languages__weave_code_line(OUT, S->sect_language, wv,
		W, C, S, L, matter, concluding_comment)) continue;

	string colouring;
	Languages__syntax_colour(OUT, S->sect_language, wv, W, C, S, L, matter, colouring);

	string found_text1;
	string found_text2;
	string found_text3;

	int found = 0;
	while (ISORegexp__match_3(matter, "(%c*?)%@%<(%c*?)%@%>(%c*)",
						found_text1, found_text2, found_text3)) {
		CStrings__copy(matter, found_text3);
		cweb_macro *cwm = Parser__get_cweb_macro_by_name(found_text2, S);
		Formats__source_code(OUT, wv, tab_stops_of_indentation, prefatory,
			found_text1, colouring, concluding_comment, (found == 0)?TRUE:FALSE, FALSE, TRUE);
		found++;
		int defn = (L->owning_paragraph == cwm->defining_paragraph)?TRUE:FALSE;
		Formats__cweb_macro(OUT, wv, cwm, defn);
		if (defn) CStrings__copy(matter, "");
		string temp; CStrings__copy(temp, colouring);
		CStrings__copy(colouring, temp+CStrings__len(temp)-CStrings__len(matter));
	}
	Formats__source_code(OUT, wv, tab_stops_of_indentation, prefatory,
		matter, colouring, concluding_comment, (found == 0)?TRUE:FALSE, TRUE, TRUE);

	continue;

}
#line 123 "inweb/Chapter 3/The Weaver.w"
;
		}
	}
	source_line *L = NULL;
	
{
#line 579 "inweb/Chapter 3/The Weaver.w"
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != REGULAR_MATERIAL) {
		state->kind_of_material = REGULAR_MATERIAL;
		Formats__change_mode(OUT, wv, mode_now, state->kind_of_material, TRUE);
	}
	if ((current_paragraph) && (current_paragraph != state->last_endnoted_para)) {
		state->last_endnoted_para = current_paragraph;
		Weaver__show_endnotes_on_previous_paragraph(OUT, wv, current_paragraph);
	}
	if (L) current_paragraph = L->owning_paragraph;

}
#line 127 "inweb/Chapter 3/The Weaver.w"
;

}
#line 49 "inweb/Chapter 3/The Weaver.w"
;
		}
	}

}
#line 28 "inweb/Chapter 3/The Weaver.w"
;
	if (wv->cover_sheet_to_use) 
{
#line 754 "inweb/Chapter 3/The Weaver.w"
	Bibliographic__set_datum(W, "Booklet Title", wv->booklet_title);
	Weaver__weave_cover_from(OUT, W, wv->cover_sheet_to_use, wv, WEAVE_SECOND_HALF);

}
#line 29 "inweb/Chapter 3/The Weaver.w"
;

	string rennab; /* which is |banner| backwards */
	CSTRING_WRITE(rennab, "End of weave: %d lines from a web of %d", lines_woven, W->no_lines);
	Formats__tail(OUT, wv, rennab);

	STREAM_CLOSE(OUT);
	return lines_woven; /* number of lines woven */
}

#line 78 "inweb/Chapter 3/The Weaver.w"

#line 594 "inweb/Chapter 3/The Weaver.w"
void Weaver__show_endnotes_on_previous_paragraph(OUTPUT_STREAM, weave_target *wv, paragraph *P) {
	if (P->defines_macro) {
		Formats__endnote(OUT, wv, 1);
		Formats__identifier(OUT, wv, "This code is ");
		int ct = 0;
		for (macro_usage *mu = P->defines_macro->macro_usages; mu; mu = mu->next_macro_usage)
			ct++;
		if (ct == 1) Formats__identifier(OUT, wv, "never used");
		else {
			int k = 0, used_flag = FALSE;
			for (macro_usage *mu = P->defines_macro->macro_usages; mu; mu = mu->next_macro_usage)
				if (P != mu->used_in_paragraph) {
					if (used_flag) {
						if (k < ct-1) Formats__identifier(OUT, wv, ", ");
						else Formats__identifier(OUT, wv, " and ");
					} else {
						Formats__identifier(OUT, wv, "used in ");
					}
					Formats__locale(OUT, wv, mu->used_in_paragraph, NULL);
					used_flag = TRUE; k++;
					switch (mu->multiplicity) {
						case 1: break;
						case 2: Formats__identifier(OUT, wv, " (twice)"); break;
						case 3: Formats__identifier(OUT, wv, " (three times)"); break;
						case 4: Formats__identifier(OUT, wv, " (four times)"); break;
						case 5: Formats__identifier(OUT, wv, " (five times)"); break;
						default: {
							string mt;
							CSTRING_WRITE(mt, " (%d times)", mu->multiplicity);
							Formats__identifier(OUT, wv, mt);
							break;
						}
					}
				}
		}
		Formats__identifier(OUT, wv, ".");
		Formats__endnote(OUT, wv, 2);
	}

	function *fn;
	for (fn = P->first_defined_in_paragraph; fn; fn = fn->next_defined_in_paragraph) {
		Formats__endnote(OUT, wv, 1);
		hash_table_entry *hte = Analyser__find_hash_entry(fn->function_header_at->owning_section, fn->function_name, FALSE);
		Formats__identifier(OUT, wv, "The function ");
		Formats__identifier(OUT, wv, fn->function_name);
		int used_flag = FALSE;
		hash_table_entry_usage *hteu = NULL;
		section *last_cited_in = NULL;
		int count_under = 0;
		for (hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
			if ((P != hteu->usage_recorded_at) &&
				(P->under_section == hteu->usage_recorded_at->under_section))
				
{
#line 698 "inweb/Chapter 3/The Weaver.w"
	if (used_flag == FALSE) Formats__identifier(OUT, wv, " is used in ");
	used_flag = TRUE;
	section *S = hteu->usage_recorded_at->under_section;
	if ((S != last_cited_in) && (S != P->under_section)) {
		count_under = 0;
		if (last_cited_in) {
			if (last_cited_in != P->under_section) Formats__identifier(OUT, wv, "), ");
			else Formats__identifier(OUT, wv, ", ");
		}
		Formats__identifier(OUT, wv, hteu->usage_recorded_at->under_section->sigil);
		Formats__identifier(OUT, wv, " (");
	}
	if (count_under++ > 0) Formats__identifier(OUT, wv, ", ");
	Formats__locale(OUT, wv, hteu->usage_recorded_at, NULL);
	last_cited_in = hteu->usage_recorded_at->under_section;

}
#line 646 "inweb/Chapter 3/The Weaver.w"
;
		for (hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
			if (P->under_section != hteu->usage_recorded_at->under_section)
				
{
#line 698 "inweb/Chapter 3/The Weaver.w"
	if (used_flag == FALSE) Formats__identifier(OUT, wv, " is used in ");
	used_flag = TRUE;
	section *S = hteu->usage_recorded_at->under_section;
	if ((S != last_cited_in) && (S != P->under_section)) {
		count_under = 0;
		if (last_cited_in) {
			if (last_cited_in != P->under_section) Formats__identifier(OUT, wv, "), ");
			else Formats__identifier(OUT, wv, ", ");
		}
		Formats__identifier(OUT, wv, hteu->usage_recorded_at->under_section->sigil);
		Formats__identifier(OUT, wv, " (");
	}
	if (count_under++ > 0) Formats__identifier(OUT, wv, ", ");
	Formats__locale(OUT, wv, hteu->usage_recorded_at, NULL);
	last_cited_in = hteu->usage_recorded_at->under_section;

}
#line 649 "inweb/Chapter 3/The Weaver.w"
;
		if (used_flag == FALSE) Formats__identifier(OUT, wv, " appears nowhere else");
		if ((last_cited_in != P->under_section) && (last_cited_in))
			Formats__identifier(OUT, wv, ")");
		Formats__identifier(OUT, wv, ".");
		Formats__endnote(OUT, wv, 2);
	}

	c_structure *st;
	for (st = P->first_c_structure_in_para; st; st = st->next_c_structure_in_para) {
		Formats__endnote(OUT, wv, 1);
		Formats__identifier(OUT, wv, "The structure ");
		Formats__identifier(OUT, wv, st->structure_name);

		section *S;
		LOOP_OVER(S, section) S->scratch_flag = FALSE;
		for (structure_element *elt = st->first_element; elt; elt = elt->next_element) {
			hash_table_entry *hte = Analyser__find_hash_entry(elt->element_created_at->owning_section, elt->element_name, FALSE);
			if (hte)
				for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
					if (hteu->form_of_usage & ELEMENT_ACCESS_USAGE)
						hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
		}

		int usage_count = 0, external = 0;
		LOOP_OVER(S, section)
			if (S->scratch_flag) {
				usage_count++;
				if (S != P->under_section) external++;
			}
		if (external == 0) Formats__identifier(OUT, wv, " is private to this section");
		else {
			Formats__identifier(OUT, wv, " is accessed in ");
			int c = 0;
			LOOP_OVER(S, section)
				if ((S->scratch_flag) && (S != P->under_section)) {
					if (c++ > 0) Formats__identifier(OUT, wv, ", ");
					Formats__identifier(OUT, wv, S->sigil);
				}
			if (P->under_section->scratch_flag) Formats__identifier(OUT, wv, " and here");
		}
		Formats__identifier(OUT, wv, ".");
		Formats__endnote(OUT, wv, 2);
	}
}

#line 717 "inweb/Chapter 3/The Weaver.w"
int Weaver__weave_table_of_contents(OUTPUT_STREAM, weave_target *wv, section *S) {
	int noteworthy = 0;
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		if ((P->weight > 0) && ((S->barred == FALSE) || (P->above_bar == FALSE)))
			noteworthy++;
	if (noteworthy == 0) return FALSE;

	Formats__toc(OUT, wv, 1, S->sigil, "", NULL);
	noteworthy = 0;
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		if ((P->weight > 0) && ((S->barred == FALSE) || (P->above_bar == FALSE))) {
			if (noteworthy > 0) Formats__toc(OUT, wv, 2, "", "", NULL);
			paragraph *LP = NULL, *CP = P->next_paragraph_in_section;
			while ((CP) && (CP->weight == 0)) {
				LP = CP; CP = CP->next_paragraph_in_section;
			}
			string loc;
			CSTRING_WRITE(loc, "%s%s", P->ornament, P->paragraph_number);
			Formats__toc(OUT, wv, 3, loc, P->first_line_in_paragraph->text_operand, P);
			noteworthy++;
		}
	Formats__toc(OUT, wv, 4, "", "", NULL);
	return TRUE;
}

#line 765 "inweb/Chapter 3/The Weaver.w"
text_stream *WEAVE_COVER_TO = NULL;
int weave_cover_halves = 0;

int Weaver__weave_cover_from(OUTPUT_STREAM, web *W, filename *cs_filename, weave_target *wv, int halves) {
	int swc = weave_cover_halves;
	weave_cover_halves = halves;
	WEAVE_COVER_TO = OUT;
	TextFiles__read_with_lines_to_ISO(
		Filenames__set_extension(cs_filename, Formats__weave_file_extension(wv->format)),
		"can't open cover sheet file", TRUE,
		Weaver__scan_cover_line, NULL, (void *) wv);
	weave_cover_halves = swc;
	return 0;
}

void Weaver__scan_cover_line(char *line, text_file_position *tfp, void *state) {
	int include = FALSE;
	if (((weave_cover_halves & WEAVE_FIRST_HALF) &&
			((weave_cover_halves & IN_SECOND_HALF) == 0)) ||
		((weave_cover_halves & WEAVE_SECOND_HALF) &&
			(weave_cover_halves & IN_SECOND_HALF))) include = TRUE;

	weave_target *wv = (weave_target *) state;
	string matter; CStrings__copy(matter, line);
	string found_text1;
	string found_text2;
	string found_text3;
	while (ISORegexp__match_3(matter, "(%c*?)%[%[(%c*?)%]%](%c*)",
						found_text1, found_text2, found_text3)) {
		string left; CStrings__copy(left, found_text1);
		string middle; CStrings__copy(middle, found_text2);
		string right; CStrings__copy(right, found_text3);
		if (include) WRITE_TO(WEAVE_COVER_TO, "%s", left);
		if (CStrings__eq(middle, "Code")) {
			weave_cover_halves |= IN_SECOND_HALF;
		} else if (CStrings__eq(middle, "Cover Sheet")) {
			if ((include) && ((weave_cover_halves & IN_SECOND_HALF) == 0)) {
				Weaver__weave_cover_from(WEAVE_COVER_TO, wv->weave_web,
					Filenames__in_folder(path_to_inweb_materials, "cover-sheet"),
					wv, WEAVE_FIRST_HALF);
			}
		} else if (Bibliographic__data_exists(wv->weave_web, middle)) {
			if (include)
				WRITE_TO(WEAVE_COVER_TO, "%s", Bibliographic__get_data(wv->weave_web, middle));
		} else {
			if (include) WRITE_TO(WEAVE_COVER_TO, "%s", middle);
		}
		CStrings__copy(matter, right);
	}
	if (include) WRITE_TO(WEAVE_COVER_TO, "%s\n", matter);
}

#line 822 "inweb/Chapter 3/The Weaver.w"
source_line *Weaver__weave_interface_table_for_section(OUTPUT_STREAM, weave_target *wv, source_line *L) {
	if (SHOW_INTERFACES) {
		Formats__subheading(OUT, wv, 2, "Interface", NULL);
		Formats__change_mode(OUT, wv, REGULAR_MATERIAL, CODE_MATERIAL, TRUE);
	}
	source_line *CL = L->next_line, *LL = L;
	while ((CL) && (CL->next_line) &&
		(CL->owning_paragraph == L->owning_paragraph) &&
		(CL->category == COMMENT_BODY_LCAT)) {
		LL = CL;
		if ((SHOW_INTERFACES) && (ISORegexp__string_is_white_space(CL->text) == FALSE)) {
			string colouring;
			for (int i=0; CL->text[i]; i++) colouring[i] = PLAIN_CODE;
			colouring[CStrings__len(CL->text)] = 0;
			Formats__source_code(OUT, wv, 1, "", CL->text, colouring, "",
				TRUE, TRUE, TRUE);
		}
		CL = CL->next_line;
	}
	if (SHOW_INTERFACES) {
		Formats__change_mode(OUT, wv, CODE_MATERIAL, REGULAR_MATERIAL, TRUE);
	}
	return LL;
}

#line 14 "inweb/Chapter 3/The Tangler.w"
void Tangler__go(web *W, tangle_target *target, filename *dest_file) {
	programming_language *lang = target->tangle_language;
	PRINT("  tangling <%/f> (written in %s)\n", dest_file, lang->language_name);

	if (Languages__tangles(lang) == FALSE) /* for documentation webs, for instance */
		Errors__fatal_with_C_string("can't tangle material in the language", lang->language_name);

	text_stream TO_struct;
	text_stream *OUT = &TO_struct;
	if (STREAM_OPEN_TO_FILE(OUT, dest_file, ISO_ENC) == FALSE)
		Errors__fatal_with_file("unable to write tangled file", dest_file);
	
{
#line 42 "inweb/Chapter 3/The Tangler.w"
	/* (a) The shebang line, a header for scripting languages, and other heading matter */
	Languages__shebang(OUT, lang, W, target);

	/* (b) Results of |@d| declarations */
	
{
#line 68 "inweb/Chapter 3/The Tangler.w"
	LOOP_WITHIN_TANGLE(target)
		if (L->category == BEGIN_DEFINITION_LCAT) {
			Languages__start_definition(OUT, lang,
				L->text_operand,
				L->text_operand2, S, L);
			while ((L->next_line) && (L->next_line->category == CONT_DEFINITION_LCAT)) {
				L = L->next_line;
				Languages__prolong_definition(OUT, lang, L->text, S, L);
			}
			Languages__end_definition(OUT, lang, S, L);
		}

}
#line 46 "inweb/Chapter 3/The Tangler.w"
;

	/* (c) Miscellaneous automated C predeclarations */
	Languages__additional_predeclarations(OUT, lang, W);

	/* (d) Above-the-bar code from all of the sections (global variables, and such) */
	LOOP_OVER_PARAGRAPHS(target)
		if ((S->barred) && (P->placed_early) && (P->defines_macro == NULL))
			Tangler__tangle_paragraph(OUT, P);

	/* (e) Below-the-bar code: the bulk of the program itself */
	LOOP_OVER_PARAGRAPHS(target)
		if (((S->barred == FALSE) || (P->placed_early == FALSE)) && (P->defines_macro == NULL))
			Tangler__tangle_paragraph(OUT, P);

	/* (f) Opposite of the shebang: a footer */
	Languages__gnabehs(OUT, lang, W);

}
#line 25 "inweb/Chapter 3/The Tangler.w"
;
	STREAM_CLOSE(OUT);

	
{
#line 83 "inweb/Chapter 3/The Tangler.w"
	for (imported_header *H = W->first_header; H; H = H->next_header)
		Shell__copy(H->header_file, Pathnames__subfolder(W->path_to_web, "Tangled"), "");

}
#line 28 "inweb/Chapter 3/The Tangler.w"
;
	Languages__additional_tangling(lang, W, target);
}

#line 91 "inweb/Chapter 3/The Tangler.w"
void Tangler__tangle_paragraph(OUTPUT_STREAM, paragraph *P) {
	int contiguous = FALSE;
	for (source_line *L = P->first_line_in_paragraph;
		((L) && (L->owning_paragraph == P)); L = L->next_line) {
		if (Languages__will_insert_in_tangle(P->under_section->sect_language, L)) {
			
{
#line 114 "inweb/Chapter 3/The Tangler.w"
	if (contiguous == FALSE) {
		contiguous = TRUE;
		Languages__insert_line_marker(OUT, P->under_section->sect_language, L);
	}

}
#line 96 "inweb/Chapter 3/The Tangler.w"
;
			Languages__insert_in_tangle(OUT, P->under_section->sect_language, L);
		}
		if ((L->category != CODE_BODY_LCAT) || (L->suppress_tangling)) {
			contiguous = FALSE;
		} else {
			
{
#line 114 "inweb/Chapter 3/The Tangler.w"
	if (contiguous == FALSE) {
		contiguous = TRUE;
		Languages__insert_line_marker(OUT, P->under_section->sect_language, L);
	}

}
#line 102 "inweb/Chapter 3/The Tangler.w"
;
			Tangler__tangle_code(OUT, L->text, P->under_section, L); WRITE("\n");
		}
	}
}

#line 124 "inweb/Chapter 3/The Tangler.w"
void Tangler__tangle_code(OUTPUT_STREAM, char *original, section *S, source_line *L) {
	int mlen, slen;
	int mpos = ISORegexp__find_expansion(original, '@', '<', '@', '>', &mlen);
	int spos = ISORegexp__find_expansion(original, '[', '[', ']', ']', &slen);
	if ((mpos >= 0) && ((spos == -1) || (mpos <= spos)))
		
{
#line 155 "inweb/Chapter 3/The Tangler.w"
	string temp; CStrings__copy(temp, original); CStrings__truncate(temp, mpos);
	Languages__tangle_code(OUT, S->sect_language, temp);

	programming_language *lang = S->sect_language;
	for (int i=0; i<mlen-4; i++) CStrings__set_char(temp, i, original[mpos+2+i]); CStrings__truncate(temp, mlen-4);
	cweb_macro *cwm = Parser__get_cweb_macro_by_name(temp, S);
	if (cwm) {
		Languages__before_macro_expansion(OUT, lang, cwm);
		Tangler__tangle_paragraph(OUT, cwm->defining_paragraph);
		Languages__after_macro_expansion(OUT, lang, cwm);
		Languages__insert_line_marker(OUT, lang, L);
	} else {
		Main__error_in_web("unknown macro", L);
		fprintf(stderr, "Macro is '%s'\n", temp);
		Languages__comment(OUT, lang, temp); /* recover by putting macro name in comment */
	}

	Tangler__tangle_code(OUT, original + mpos + mlen, S, L);

}
#line 129 "inweb/Chapter 3/The Tangler.w"

	else if (spos >= 0)
		
{
#line 190 "inweb/Chapter 3/The Tangler.w"
	web *W = S->owning_chapter->owning_web;

	string temp; CStrings__copy(temp, "");
	for (int i=0; i<spos; i++) CStrings__set_char(temp, i, original[i]); CStrings__truncate(temp, spos);
	Languages__tangle_code(OUT, S->sect_language, temp);

	for (int i=0; i<slen-4; i++) CStrings__set_char(temp, i, original[spos+2+i]); CStrings__truncate(temp, slen-4);
	if (Languages__special_data(OUT, S->sect_language, temp) == FALSE) {
		if (Bibliographic__look_up_datum(W, temp))
			WRITE("%s", Bibliographic__get_data(W, temp));
		else
			WRITE("[[%s]]", temp);
	}

	Tangler__tangle_code(OUT, original + spos + slen, S, L);

}
#line 131 "inweb/Chapter 3/The Tangler.w"

	else
		Languages__tangle_code(OUT, S->sect_language, original); /* this is usually what happens */
}

#line 32 "inweb/Chapter 4/Programming Languages.w"

#line 36 "inweb/Chapter 4/Programming Languages.w"
programming_language *C_FOR_INFORM_LANGUAGE = NULL;
programming_language *C_LANGUAGE = NULL;
programming_language *CPP_LANGUAGE = NULL; /* never actually tested */
programming_language *I6_LANGUAGE = NULL;
programming_language *I7_LANGUAGE = NULL;
programming_language *PERL_LANGUAGE = NULL; /* Perl 5, that is, though 6 may also work */
programming_language *PLAIN_LANGUAGE = NULL;

programming_language *NO_LANGUAGE = NULL; /* a dummy language for error recovery */

programming_language *Languages__default(void) {
	return C_LANGUAGE;
}

#line 54 "inweb/Chapter 4/Programming Languages.w"
void Languages__create_programming_languages(void) {
	C_FOR_INFORM_LANGUAGE = Languages__new_language("C for Inform", ".c");
	C_FOR_INFORM_LANGUAGE->c_like = TRUE;
	C_LANGUAGE = Languages__new_language("C", ".c");
	C_LANGUAGE->c_like = TRUE;
	CPP_LANGUAGE = Languages__new_language("C++", ".cpp");
	CPP_LANGUAGE->c_like = TRUE;
	I6_LANGUAGE = Languages__new_language("Inform 6", ".i6");
	I6_LANGUAGE->source_file_extension = ".i6t";
	I7_LANGUAGE = Languages__new_language("Inform 7", ".i7x");
	PERL_LANGUAGE = Languages__new_language("Perl", ".pl");
	PERL_LANGUAGE->shebang = "#!/usr/bin/perl\n\n";
	PLAIN_LANGUAGE = Languages__new_language("Plain Text", ".txt");
	/* something of an exception: */
	NO_LANGUAGE = Languages__new_language("None", "");
}

#line 74 "inweb/Chapter 4/Programming Languages.w"
programming_language *Languages__new_language(char *name, char *ext) {
	programming_language *pl = CREATE(programming_language);
	pl->language_name = name; pl->file_extension = ext;
	pl->shebang = ""; pl->c_like = FALSE;
	pl->source_file_extension = ".w";
	return pl;
}

#line 85 "inweb/Chapter 4/Programming Languages.w"
programming_language *Languages__language_with_name(char *lname) {
	programming_language *pl;
	LOOP_OVER(pl, programming_language)
		if (CStrings__eq(lname, pl->language_name))
			return pl;
	Errors__fatal_with_C_string("unsupported programming language '%s'", lname);
	return NULL;
}

#line 97 "inweb/Chapter 4/Programming Languages.w"
int Languages__special_data(OUTPUT_STREAM, programming_language *pl, char *data) {
	if (pl == C_FOR_INFORM_LANGUAGE) return CForInform__special_data(OUT, data);
	return FALSE;
}

#line 108 "inweb/Chapter 4/Programming Languages.w"
void Languages__further_parsing(web *W, programming_language *pl) {
	if (pl->c_like) CLike__further_parsing(W);
	if (pl == C_FOR_INFORM_LANGUAGE) CForInform__further_parsing(W);
}

void Languages__subcategorise_code(programming_language *pl, source_line *L) {
	if (pl->c_like) CLike__subcategorise_code(pl, L);
}

#line 121 "inweb/Chapter 4/Programming Languages.w"
int Languages__tangles(programming_language *pl) {
	if (pl == NO_LANGUAGE) return FALSE;
	return TRUE;
}

#line 129 "inweb/Chapter 4/Programming Languages.w"
void Languages__shebang(OUTPUT_STREAM, programming_language *pl, web *W, tangle_target *target) {
	WRITE("%s", pl->shebang);
	if (pl != I7_LANGUAGE)
		Languages__comment(OUT, pl, "Tangled output generated by inweb-C: do not edit");
	if (pl->c_like) CLike__shebang(OUT, pl, W, target);
}

#line 144 "inweb/Chapter 4/Programming Languages.w"
void Languages__start_definition(OUTPUT_STREAM, programming_language *pl,
	char *term, char *start, section *S, source_line *L) {
	if (pl->c_like) {
		WRITE("#define %s ", term);
		Tangler__tangle_code(OUT, start, S, L);
	} else if (pl == PERL_LANGUAGE) {
		WRITE("%s = ", term);
		Tangler__tangle_code(OUT, start, S, L);
	} else Main__error_in_web("this programming language does not support @d", L);
}

void Languages__prolong_definition(OUTPUT_STREAM, programming_language *pl,
	char *more, section *S, source_line *L) {
	if (pl->c_like) {
		WRITE("\\\n    ");
		Tangler__tangle_code(OUT, more, S, L);
	} else Main__error_in_web("this programming language does not support multiline @d", L);
}

void Languages__end_definition(OUTPUT_STREAM, programming_language *pl,
	section *S, source_line *L) {
	if (pl->c_like) WRITE("\n");
	else if (pl == PERL_LANGUAGE) WRITE("\n;\n");
}

#line 173 "inweb/Chapter 4/Programming Languages.w"
void Languages__additional_predeclarations(OUTPUT_STREAM, programming_language *pl, web *W) {
	if (pl->c_like) CLike__additional_predeclarations(OUT, pl, W);
	if (pl == C_FOR_INFORM_LANGUAGE) CForInform__additional_predeclarations(OUT, W);
}

#line 184 "inweb/Chapter 4/Programming Languages.w"
int Languages__will_insert_in_tangle(programming_language *pl, source_line *L) {
	if (pl == C_FOR_INFORM_LANGUAGE) return CForInform__will_insert_in_tangle(L);
	return FALSE;
}

void Languages__insert_in_tangle(OUTPUT_STREAM, programming_language *pl, source_line *L) {
	if (pl == C_FOR_INFORM_LANGUAGE) CForInform__insert_in_tangle(OUT, L);
}

#line 201 "inweb/Chapter 4/Programming Languages.w"
void Languages__insert_line_marker(OUTPUT_STREAM, programming_language *pl, source_line *L) {
	if ((pl->c_like) || (pl == PERL_LANGUAGE)) CLike__insert_line_marker(OUT, pl, L);
}

#line 210 "inweb/Chapter 4/Programming Languages.w"
void Languages__before_macro_expansion(OUTPUT_STREAM, programming_language *pl, cweb_macro *cwm) {
	if ((pl->c_like) || (pl == PERL_LANGUAGE)) CLike__before_macro_expansion(OUT, pl, cwm);
}

void Languages__after_macro_expansion(OUTPUT_STREAM, programming_language *pl, cweb_macro *cwm) {
	if ((pl->c_like) || (pl == PERL_LANGUAGE)) CLike__after_macro_expansion(OUT, pl, cwm);
}

#line 221 "inweb/Chapter 4/Programming Languages.w"
void Languages__comment(OUTPUT_STREAM, programming_language *pl, char *comm) {
	if (pl->c_like) CLike__comment(OUT, pl, comm);
	if (pl == PERL_LANGUAGE) WRITE("# %s\n", comm);
	if (pl == I6_LANGUAGE) WRITE("! %s\n", comm);
	if (pl == I7_LANGUAGE) WRITE("[%s]\n", comm);
}

#line 231 "inweb/Chapter 4/Programming Languages.w"
int Languages__parse_comment(programming_language *pl,
	char *line, char *part_before_comment, char *part_within_comment) {
	if (pl->c_like)
		return CLike__parse_comment(pl, line, part_before_comment, part_within_comment);
	if (pl == PERL_LANGUAGE) {
		string found_text1;
		string found_text2;
		if (ISORegexp__match_1(line, "# (%c*?) *", found_text1)) {
			CStrings__copy(part_before_comment, "");
			CStrings__copy(part_within_comment, found_text1);
			return TRUE;
		}
		if (ISORegexp__match_2(line, "(%c*) # (%c*?) *", found_text1, found_text2)) {
			CStrings__copy(part_before_comment, found_text1);
			CStrings__copy(part_within_comment, found_text2);
			return TRUE;
		}
	}
	return FALSE;
}

#line 257 "inweb/Chapter 4/Programming Languages.w"
void Languages__tangle_code(OUTPUT_STREAM, programming_language *pl, char *original) {
	if (pl == C_FOR_INFORM_LANGUAGE) CForInform__tangle_code(OUT, original);
	else WRITE("%s", original);
}

#line 265 "inweb/Chapter 4/Programming Languages.w"
void Languages__gnabehs(OUTPUT_STREAM, programming_language *pl, web *W) {
	if (pl == C_FOR_INFORM_LANGUAGE) CForInform__gnabehs(OUT, W);
}

#line 274 "inweb/Chapter 4/Programming Languages.w"
void Languages__additional_tangling(programming_language *pl, web *W, tangle_target *target) {
	if (pl == C_FOR_INFORM_LANGUAGE)
		CForInform__additional_tangling(pl, W, target);
}

#line 282 "inweb/Chapter 4/Programming Languages.w"
void Languages__begin_weave(section *S, weave_target *wv) {
	if (S->sect_language->c_like) CLike__begin_weave(S, wv);
	if (S->sect_language == C_FOR_INFORM_LANGUAGE) CForInform__begin_weave(S, wv);
}

#line 290 "inweb/Chapter 4/Programming Languages.w"
void Languages__new_tag_declared(theme_tag *tag) {
	CForInform__new_tag_declared(tag);
}

int Languages__skip_in_weaving(programming_language *pl, weave_target *wv, source_line *L) {
	if (pl == C_FOR_INFORM_LANGUAGE) return CForInform__skip_in_weaving(wv, L);
	return FALSE;
}

int Languages__syntax_colour(OUTPUT_STREAM, programming_language *pl, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) {
	CStrings__copy(colouring, matter);
	for (int i=0; matter[i]; i++) colouring[i] = PLAIN_CODE;
	if (pl->c_like)
		if (CLike__syntax_colour(OUT, pl, wv, W, C, S, L, matter, colouring))
			return TRUE;
	if (pl == C_FOR_INFORM_LANGUAGE)
		if (CForInform__syntax_colour(OUT, wv, W, C, S, L, matter, colouring))
			return TRUE;
	return FALSE;
}

int Languages__weave_code_line(OUTPUT_STREAM, programming_language *pl, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) {
	if (pl->c_like)
		if (CLike__weave_code_line(OUT, pl, wv, W, C, S, L, matter, concluding_comment))
			return TRUE;
	if (pl == C_FOR_INFORM_LANGUAGE)
		if (CForInform__weave_code_line(OUT, wv, W, C, S, L, matter, concluding_comment))
			return TRUE;
	return FALSE;
}

#line 326 "inweb/Chapter 4/Programming Languages.w"
void Languages__analysis(programming_language *pl, section *S, int functions_too) {
	if (pl->c_like) CLike__analysis(pl, S, functions_too);
}

void Languages__analyse_code(programming_language *pl, web *W) {
	if (pl->c_like) CLike__analyse_code(pl, W);
	if (pl == C_FOR_INFORM_LANGUAGE) CForInform__analyse_code(pl, W);
}

void Languages__post_analysis(programming_language *pl, web *W) {
	if (pl->c_like) CLike__post_analysis(pl, W);
}

#line 45 "inweb/Chapter 4/C-Like Languages.w"

c_structure *first_cst_alphabetically = NULL;

#line 58 "inweb/Chapter 4/C-Like Languages.w"

#line 68 "inweb/Chapter 4/C-Like Languages.w"

#line 79 "inweb/Chapter 4/C-Like Languages.w"

#line 99 "inweb/Chapter 4/C-Like Languages.w"

#line 105 "inweb/Chapter 4/C-Like Languages.w"
void CLike__further_parsing(web *W) {
	
{
#line 118 "inweb/Chapter 4/C-Like Languages.w"
	c_structure *current_bt = NULL;
	LOOP_WITHIN_TANGLE(W->first_target) {
		string found_text1;
		string found_text2;
		if (ISORegexp__match_1(L->text, "typedef struct (%i+) %c*", found_text1)) {
			string sname; CStrings__copy(sname, found_text1);
			current_bt = CLike__attach_structure(W, sname, L);
			Parser__add_tag_by_name(L, "Structures");
		} else if (((L->text)[0] == '}') && (current_bt)) {
			current_bt->typedef_ends = L;
			current_bt = NULL;
		} else if ((current_bt) && (current_bt->typedef_ends == NULL)) {
			char *p = L->text;
			while (ISORegexp__white_space(*p)) p++;
			char *modifier_patterns[] = {
				"(struct )(%C%c*)", "(signed )(%C%c*)", "(unsigned )(%C%c*)",
				"(short )(%C%c*)", "(long )(%C%c*)", "(static )(%C%c*)", NULL };
			int seek_modifiers = TRUE;
			while (seek_modifiers) {
				seek_modifiers = FALSE;
				for (int i = 0; modifier_patterns[i]; i++)
					if (ISORegexp__match_2(p, modifier_patterns[i], found_text1, found_text2)) {
						p = found_text2;
						seek_modifiers = TRUE;
						break;
					}
			}
			if (*p != '/') {
				while ((*p) && (ISORegexp__white_space(*p) == FALSE)) p++;
				while ((ISORegexp__white_space(*p)) || (*p == '*') || (*p == '(') || (*p == ')')) p++;
				if (p[0]) {
					string elname; CStrings__copy(elname, p);
					for (int i=0; elname[i]; i++)
						if (ISORegexp__identifier_char(elname[i]) == FALSE)
							CStrings__truncate(elname, i);
					Analyser__mark_reserved_word(L->owning_section, elname, ELEMENT_CODE);
					structure_element *elt = CREATE(structure_element);
					CStrings__copy(elt->element_name, elname);
					elt->next_element = NULL;
					elt->allow_sharing = FALSE;
					elt->element_created_at = L;
					if (W->main_language == C_FOR_INFORM_LANGUAGE) {
						if (CStrings__eq(elname, "word_ref1")) elt->allow_sharing = TRUE;
						if (CStrings__eq(elname, "word_ref2")) elt->allow_sharing = TRUE;
						if (CStrings__eq(elname, "next")) elt->allow_sharing = TRUE;
						if (CStrings__eq(elname, "down")) elt->allow_sharing = TRUE;
						if (CStrings__eq(elname, "allocation_id")) elt->allow_sharing = TRUE;
					}
					if (current_bt->first_element == NULL)
						current_bt->first_element = elt;
					else
						current_bt->last_element->next_element = elt;
					current_bt->last_element = elt;
				}
			}
		} else if (ISORegexp__match_0(L->text, "typedef char%c+")) {
			L->category = TYPEDEF_LCAT;
		}
	}

}
#line 106 "inweb/Chapter 4/C-Like Languages.w"
;
	
{
#line 185 "inweb/Chapter 4/C-Like Languages.w"
	c_structure *current_bt;
	LOOP_OVER(current_bt, c_structure) {
		for (source_line *L = current_bt->typedef_begins;
			((L) && (L != current_bt->typedef_ends));
			L = L->next_line) {
			string found_text1;
			if (ISORegexp__match_1(L->text, " struct (%i+) %i%c*", found_text1))
				
{
#line 199 "inweb/Chapter 4/C-Like Languages.w"
	string used_structure; CStrings__copy(used_structure, found_text1);
	for (c_structure *str = W->first_c_structure; str; str = str->next_c_structure)
		if ((str != current_bt) &&
			(CStrings__eq(used_structure, str->structure_name))) {
			structure_dependence *dpd = CREATE(structure_dependence);
			dpd->incorporates = str;
			if (current_bt->first_dependence == NULL) {
				current_bt->first_dependence = dpd;
				current_bt->last_dependence = dpd;
			} else {
				current_bt->last_dependence->next_dependence = dpd;
				current_bt->last_dependence = dpd;
			}
		}

}
#line 192 "inweb/Chapter 4/C-Like Languages.w"
;
		}
	}

}
#line 107 "inweb/Chapter 4/C-Like Languages.w"
;
	LOOP_WITHIN_TANGLE(W->first_target)
		if ((L->category == CODE_BODY_LCAT) ||
			(L->category == BEGIN_DEFINITION_LCAT) ||
			(L->category == CONT_DEFINITION_LCAT))
			
{
#line 299 "inweb/Chapter 4/C-Like Languages.w"
	char *p = L->text;
	if (!(ISORegexp__white_space(p[0]))) {
		string qualifiers; CStrings__copy(qualifiers, "");
		string modified; CStrings__copy(modified, "");
		
{
#line 352 "inweb/Chapter 4/C-Like Languages.w"
	char *modifier_patterns[] = {
		"(signed )(%C%c*)", "(unsigned )(%C%c*)",
		"(short )(%C%c*)", "(long )(%C%c*)", "(static )(%C%c*)", NULL };
	int seek_modifiers = TRUE;
	while (seek_modifiers) {
		seek_modifiers = FALSE;
		string found_text1;
		string found_text2;
		for (int i = 0; modifier_patterns[i]; i++)
			if (ISORegexp__match_2(p, modifier_patterns[i], found_text1, found_text2)) {
				CStrings__concatenate(qualifiers, found_text1);
				CStrings__copy(modified, found_text2);
				p = modified; seek_modifiers = TRUE; break;
			}
	}

}
#line 303 "inweb/Chapter 4/C-Like Languages.w"
;
		string found_text1;
		string found_text2;
		string found_text3;
		string found_text4;
		if (ISORegexp__match_4(p, "(%i+) (%**)(%i+)%((%c*)",
			found_text1, found_text2, found_text3, found_text4)) {
			string ftype; CStrings__copy(ftype, found_text1);
			string asts; CStrings__copy(asts, found_text2);
			string fname; CStrings__copy(fname, found_text3);
			string arguments; CStrings__copy(arguments, found_text4);
			
{
#line 378 "inweb/Chapter 4/C-Like Languages.w"
	source_line *AL = L;
	int arg_lc = 1;
	while ((AL) && (arg_lc <= MAX_ARG_LINES) && (ISORegexp__find_open_brace(arguments) == -1)) {
		if (AL->next_line == NULL) {
			string err_mess;
			sprintf(err_mess, "Function '%s' has a malformed declaration", fname);
			Main__error_in_web(err_mess, L);
			break;
		}
		AL = AL->next_line;
		CStrings__concatenate(arguments, " ");
		CStrings__concatenate(arguments, AL->text);
		arg_lc++;
	}
	int n = ISORegexp__find_open_brace(arguments);
	if (n >= 0) CStrings__truncate(arguments, n);

}
#line 314 "inweb/Chapter 4/C-Like Languages.w"
;
			Analyser__mark_reserved_word(L->owning_section, fname, FUNCTION_CODE);

			function *fn = CREATE(function);
			CStrings__copy(fn->function_name, fname);
			CStrings__copy(fn->function_arguments, arguments);
			CSTRING_WRITE(fn->function_type, "%s%s %s", qualifiers, ftype, asts);
			fn->within_namespace = FALSE;
			fn->called_from_other_sections = FALSE;
			fn->call_freely = FALSE;
			if ((CStrings__eq(fn->function_name, "isdigit")) &&
				(W->main_language == C_FOR_INFORM_LANGUAGE))
				fn->call_freely = TRUE;
			fn->function_header_at = L;
			fn->next_defined_in_paragraph = NULL;
			paragraph *P = L->owning_paragraph;
			if (P) {
				if (P->first_defined_in_paragraph == NULL)
					P->first_defined_in_paragraph = fn;
				else {
					function *ofn = P->first_defined_in_paragraph;
					while ((ofn) && (ofn->next_defined_in_paragraph))
						ofn = ofn->next_defined_in_paragraph;
					ofn->next_defined_in_paragraph = fn;
				}
			}
			L->function_defined = fn;

			if (W->main_language == C_FOR_INFORM_LANGUAGE)
				
{
#line 398 "inweb/Chapter 4/C-Like Languages.w"
	char *declared_namespace = "";
	string found_text1;
	if (ISORegexp__match_1(fname, "(%c+::)%c*", found_text1)) {
		declared_namespace = found_text1;
		fn->within_namespace = TRUE;
	} else if ((strcmp(fname, "main") == 0) && (strcmp(S->sect_namespace, "Main::") == 0))
		declared_namespace = "Main::";
	if (strcmp(declared_namespace, S->sect_namespace) != 0) {
		string err_mess;
		if (declared_namespace[0] == 0)
			sprintf(err_mess, "Function '%s' should have namespace prefix '%s'",
				fname, S->sect_namespace);
		else if (S->sect_namespace[0] == 0)
			sprintf(err_mess, "Function '%s' declared in a section with no namespace",
				fname);
		else
			sprintf(err_mess, "Function '%s' declared in a section with the wrong namespace '%s'",
				fname, S->sect_namespace);
		Main__error_in_web(err_mess, L);
	}

}
#line 343 "inweb/Chapter 4/C-Like Languages.w"
;
		}
	}

}
#line 112 "inweb/Chapter 4/C-Like Languages.w"
;
}

#line 217 "inweb/Chapter 4/C-Like Languages.w"
c_structure *CLike__find_structure(web *W, char *name) {
	for (c_structure *str = W->first_c_structure; str; str = str->next_c_structure)
		if (CStrings__eq(name, str->structure_name))
			return str;
	return NULL;
}

function *CLike__get_function_with_name(char *name) {
	function *fn;
	LOOP_OVER(fn, function)
		if (CStrings__eq(name, fn->function_name))
			return fn;
	return NULL;
}

#line 235 "inweb/Chapter 4/C-Like Languages.w"
c_structure *CLike__attach_structure(web *W, char *name, source_line *L) {
	c_structure *str = CREATE(c_structure);
	CStrings__copy(str->structure_name, name);
	Analyser__mark_reserved_word(L->owning_section, str->structure_name, RESERVED_CODE);
	str->typedef_begins = L;
	str->declared_owner = NULL;
	str->tangled = FALSE;
	str->typedef_ends = NULL;
	str->next_c_structure = NULL;
	str->next_c_structure_in_para = NULL;
	str->first_dependence = NULL;
	str->last_dependence = NULL;
	str->first_element = NULL;
	str->last_element = NULL;
	if (W->first_c_structure == NULL) {
		W->first_c_structure = str;
		W->last_c_structure = str;
	} else {
		W->last_c_structure->next_c_structure = str;
		W->last_c_structure = str;
	}
	paragraph *P = L->owning_paragraph;
	if (P) {
		if (P->first_c_structure_in_para == NULL) {
			P->first_c_structure_in_para = str;
			P->last_c_structure_in_para = str;
		} else {
			P->last_c_structure_in_para->next_c_structure_in_para = str;
			P->last_c_structure_in_para = str;
		}
	}
	str->next_cst_alphabetically = NULL;
	if (first_cst_alphabetically == NULL) first_cst_alphabetically = str;
	else {
		int placed = FALSE;
		c_structure *last = NULL;
		for (c_structure *seq = first_cst_alphabetically; seq;
			seq = seq->next_cst_alphabetically) {
			if (CStrings__cmp(name, seq->structure_name) < 0) {
				if (seq == first_cst_alphabetically) {
					str->next_cst_alphabetically = first_cst_alphabetically;
					first_cst_alphabetically = str;
				} else {
					last->next_cst_alphabetically = str;
					str->next_cst_alphabetically = seq;
				}
				placed = TRUE;
				break;
			}
			last = seq;
		}
		if (placed == FALSE) last->next_cst_alphabetically = str;
	}
	return str;
}

#line 422 "inweb/Chapter 4/C-Like Languages.w"
void CLike__subcategorise_code(programming_language *pl, source_line *L) {
	string found_text1;
	if (ISORegexp__match_1(L->text, "#include <(%C+)>%c*", found_text1)) {
		string library_file; CStrings__copy(library_file, found_text1);
		char *ansi_libs[] = {
			"assert.h", "ctype.h", "errno.h", "float.h", "limits.h",
			"locale.h", "math.h", "setjmp.h", "signal.h", "stdarg.h",
			"stddef.h", "stdio.h", "stdlib.h", "string.h", "time.h",
			NULL
		};
		for (int j = 0; ansi_libs[j]; j++)
			if (CStrings__eq(library_file, ansi_libs[j]))
				L->category = C_LIBRARY_INCLUDE_LCAT;
	}
}

#line 447 "inweb/Chapter 4/C-Like Languages.w"
void CLike__shebang(OUTPUT_STREAM, programming_language *pl, web *W, tangle_target *target) {
	LOOP_WITHIN_TANGLE(target)
		if (L->category == C_LIBRARY_INCLUDE_LCAT) {
			Tangler__tangle_code(OUT, L->text, S, L);
			WRITE("\n");
		}
}

#line 459 "inweb/Chapter 4/C-Like Languages.w"
void CLike__additional_predeclarations(OUTPUT_STREAM, programming_language *pl, web *W) {
	
{
#line 468 "inweb/Chapter 4/C-Like Languages.w"
	LOOP_WITHIN_TANGLE(W->first_target)
		if (L->category == TYPEDEF_LCAT) {
			Languages__tangle_code(OUT, W->main_language, L->text);
			WRITE("\n");
		}

}
#line 460 "inweb/Chapter 4/C-Like Languages.w"
;
	
{
#line 495 "inweb/Chapter 4/C-Like Languages.w"
	for (c_structure *str = W->first_c_structure; str; str = str->next_c_structure)
		str->tangled = FALSE;
	for (c_structure *str = W->first_c_structure; str; str = str->next_c_structure)
		CLike__tangle_structure(OUT, pl, str);

}
#line 461 "inweb/Chapter 4/C-Like Languages.w"
;
	
{
#line 477 "inweb/Chapter 4/C-Like Languages.w"
	LOOP_WITHIN_TANGLE(W->first_target)
		if (L->function_defined) {
			function *fn = L->function_defined;
			Languages__insert_line_marker(OUT, W->main_language, L);
			WRITE("%s ", fn->function_type);
			Languages__tangle_code(OUT, W->main_language, fn->function_name);
			WRITE("(%s;\n", fn->function_arguments);
		}

}
#line 462 "inweb/Chapter 4/C-Like Languages.w"
;
}

#line 503 "inweb/Chapter 4/C-Like Languages.w"
void CLike__tangle_structure(OUTPUT_STREAM, programming_language *pl, c_structure *str) {
	if (str->tangled != FALSE) return;
	str->tangled = NOT_APPLICABLE;
	for (structure_dependence *dpd = str->first_dependence; dpd; dpd = dpd->next_dependence)
		CLike__tangle_structure(OUT, pl, dpd->incorporates);
	str->tangled = TRUE;
	Languages__insert_line_marker(OUT, pl, str->typedef_begins);
	for (source_line *L = str->typedef_begins; L; L = L->next_line) {
		WRITE("%s\n", L->text);
		L->suppress_tangling = TRUE;
		if (L == str->typedef_ends) break;
	}
}

#line 525 "inweb/Chapter 4/C-Like Languages.w"
void CLike__insert_line_marker(OUTPUT_STREAM, programming_language *pl, source_line *L) {
	WRITE("#line %d \"%/f\"\n",
		L->source.line_count,
		L->source.text_file_filename);
}

#line 534 "inweb/Chapter 4/C-Like Languages.w"
void CLike__comment(OUTPUT_STREAM, programming_language *pl, char *comm) {
	WRITE("/* %s */\n", comm);
}

#line 541 "inweb/Chapter 4/C-Like Languages.w"
int CLike__parse_comment(programming_language *pl,
	char *line, char *part_before_comment, char *part_within_comment) {
	string found_text1;
	string found_text2;
	if (ISORegexp__match_2(line, "(%c*)/%* *(%c*?) *%*/ *", found_text1, found_text2)) {
		CStrings__copy(part_before_comment, found_text1);
		CStrings__copy(part_within_comment, found_text2);
		return TRUE;
	}
	return FALSE;
}

#line 571 "inweb/Chapter 4/C-Like Languages.w"
void CLike__before_macro_expansion(OUTPUT_STREAM, programming_language *pl, cweb_macro *cwm) {
	WRITE("\n{\n");
}

void CLike__after_macro_expansion(OUTPUT_STREAM, programming_language *pl, cweb_macro *cwm) {
	WRITE("}\n");
}

#line 583 "inweb/Chapter 4/C-Like Languages.w"
void CLike__begin_weave(section *S, weave_target *wv) {
	Analyser__mark_reserved_word(S, "FILE", RESERVED_CODE);

	Analyser__mark_reserved_word(S, "auto", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "break", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "case", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "char", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "const", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "continue", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "default", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "do", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "double", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "else", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "enum", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "extern", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "float", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "for", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "goto", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "if", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "int", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "long", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "register", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "return", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "short", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "signed", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "sizeof", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "static", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "struct", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "switch", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "typedef", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "union", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "unsigned", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "void", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "volatile", RESERVED_CODE);
	Analyser__mark_reserved_word(S, "while", RESERVED_CODE);
}

#line 623 "inweb/Chapter 4/C-Like Languages.w"
int colouring_state = PLAIN_CODE;
int CLike__syntax_colour(OUTPUT_STREAM, programming_language *pl, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) {
	for (int i=0; matter[i]; i++) {
		int skip = FALSE, one_off = -1, will_be = -1;
		switch (colouring_state) {
			case PLAIN_CODE:
				switch (matter[i]) {
					case '\"': colouring_state = STRING_CODE; break;
					case '\'': colouring_state = CHAR_LITERAL_CODE; break;
				}
				if ((ISORegexp__identifier_char(matter[i])) && (matter[i] != ':')) {
					if ((!(isdigit(matter[i]))) ||
						((i>0) && (colouring[i-1] == IDENTIFIER_CODE)))
						one_off = IDENTIFIER_CODE;
				}
				break;
			case CHAR_LITERAL_CODE:
				switch (matter[i]) {
					case '\\': skip = TRUE; break;
					case '\'': will_be = PLAIN_CODE; break;
				}
				break;
			case STRING_CODE:
				switch (matter[i]) {
					case '\\': skip = TRUE; break;
					case '\"': will_be = PLAIN_CODE; break;
				}
				break;
		}
		if (one_off >= 0) colouring[i] = (char) one_off; else colouring[i] = (char) colouring_state;
		if (will_be >= 0) colouring_state = (char) will_be;
		if ((skip) && (matter[i+1])) i++;
	}
	int ident_from = -1;
	for (int i=0; matter[i]; i++) {
		if ((matter[i] == ':') && (matter[i+1] == ':') &&
			(colouring[i-1] == IDENTIFIER_CODE) && (colouring[i+2] == IDENTIFIER_CODE)) {
			colouring[i] = IDENTIFIER_CODE;
			colouring[i+1] = IDENTIFIER_CODE;
		}
		if (colouring[i] == IDENTIFIER_CODE) {
			if (ident_from == -1) ident_from = i;
		} else {
			if (ident_from >= 0)
				CLike__colour_ident(S, matter, colouring, ident_from, i-1);
			ident_from = -1;
		}
	}
	if (ident_from >= 0)
		CLike__colour_ident(S, matter, colouring, ident_from, CStrings__len(matter)-1);
	return FALSE;
}

void CLike__colour_ident(section *S, char *matter, char *colouring, int from, int to) {
	string id; CStrings__copy(id, matter+from); CStrings__truncate(id, to-from+1);
	int override = -1;

	if (Analyser__is_reserved_word(S, id, FUNCTION_CODE)) override = FUNCTION_CODE;
	if (Analyser__is_reserved_word(S, id, RESERVED_CODE)) override = RESERVED_CODE;
	if (Analyser__is_reserved_word(S, id, CONSTANT_CODE)) override = CONSTANT_CODE;
	if (Analyser__is_reserved_word(S, id, ELEMENT_CODE)) {
		int at = --from;
		while ((at > 0) && (ISORegexp__white_space(matter[at]))) at--;
		if (((at >= 0) && (matter[at] == '.')) ||
			((at >= 0) && (matter[at-1] == '-') && (matter[at] == '>')))
			override = ELEMENT_CODE;
	}

	if (override >= 0) {
		for (int i=from; i<=to; i++) colouring[i] = (char) override;
	}
}

int CLike__weave_code_line(OUTPUT_STREAM, programming_language *pl, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) {
	return FALSE;
}

#line 705 "inweb/Chapter 4/C-Like Languages.w"
void CLike__analysis(programming_language *pl, section *S, int functions_too) {
	c_structure *str;
	LOOP_OVER(str, c_structure)
		if (str->typedef_begins->owning_section == S)
			printf(" %s ", str->structure_name);
	if (functions_too) {
		function *fn;
		LOOP_OVER(fn, function)
			if (fn->function_header_at->owning_section == S)
				printf("\n                     %s", fn->function_name);
	}
}

void CLike__analyse_code(programming_language *pl, web *W) {
	function *fn;
	LOOP_OVER(fn, function)
		Analyser__find_hash_entry(fn->function_header_at->owning_section, fn->function_name, TRUE);
	c_structure *st;
	LOOP_OVER(st, c_structure)
		for (structure_element *elt = st->first_element; elt; elt = elt->next_element)
			if (elt->allow_sharing == FALSE)
				Analyser__find_hash_entry(elt->element_created_at->owning_section, elt->element_name, TRUE);

	c_structure *str = NULL;
	LOOP_WITHIN_TANGLE(W->first_target) {
		if (L->category == INTERFACE_BODY_LCAT) {
			string found_text1;
			string found_text2;
			if (ISORegexp__match_2(L->text, "-- Owns struct (%c+) %((%c+)%) *", found_text1, found_text2)) {
				int private_flag = NOT_APPLICABLE;
				if (CStrings__eq(found_text2, "private")) private_flag = TRUE;
				if (CStrings__eq(found_text2, "public")) private_flag = FALSE;
				if (private_flag == NOT_APPLICABLE) {
					Main__error_in_web("should be marked private or public", L);
					private_flag = TRUE;
				}
				str = CLike__find_structure(W, found_text1);
				if (str == NULL)
					Main__error_in_web("should be marked private or public", L);
				else {
					str->declared_owner = S;
					str->declared_private = private_flag;
				}
				L->interface_line_identified = TRUE;
			} else if (ISORegexp__match_1(L->text, " *!- shared with (%c+?) *", found_text1)) {
				if (str == NULL)
					Main__error_in_web("no structure yet to be shared", L);
				else {
					TEMPORARY_TEXT(FT);
					WRITE_TO(FT, "%s", found_text1);
					section *SW = Reader__section_by_filename(W, FT);
					DISCARD_TEXT(FT);
					if (SW == NULL)
						Main__error_in_web("no such section", L);
					else {
						structure_permission *sp = CREATE(structure_permission);
						sp->shared_with = SW;
						sp->next_permission = NULL;
						sp->granted_at = L;
						if (str->first_permission == NULL)
							str->first_permission = sp;
						else
							str->last_permission->next_permission = sp;
						str->last_permission = sp;
					}
				}
				L->interface_line_identified = TRUE;
			} else if (ISORegexp__match_0(L->text, "-- Defines {-%c+?:%c+} *")) {
				L->interface_line_identified = TRUE;
			}
		}
	}
}

void CLike__post_analysis(programming_language *pl, web *W) {
	int check_namespaces = FALSE;
	if (CStrings__eq(Bibliographic__get_data(W, "Namespaces"), "On")) check_namespaces = TRUE;
	function *fn;
	LOOP_OVER(fn, function) {
		hash_table_entry *hte = Analyser__find_hash_entry(fn->function_header_at->owning_section, fn->function_name, FALSE);
		if (hte)
			for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
				if ((hteu->form_of_usage & FCALL_USAGE) || (fn->within_namespace))
					if (hteu->usage_recorded_at->under_section != fn->function_header_at->owning_section)
						fn->called_from_other_sections = TRUE;
		if ((fn->within_namespace != fn->called_from_other_sections)
			&& (check_namespaces)
			&& (fn->call_freely == FALSE)) {
			if (fn->within_namespace)
				Main__error_in_web(
					"Being internally called, this function mustn't belong to a :: namespace",
					fn->function_header_at);
			else
				Main__error_in_web(
					"Being externally called, this function must belong to a :: namespace",
					fn->function_header_at);
		}
	}
	if (CStrings__eq(Bibliographic__get_data(W, "Strict Usage Rules"), "On")) {
		c_structure *str;
		LOOP_OVER(str, c_structure) {
			if (str->declared_owner == NULL) {
				Main__error_in_web("undeclared structure",
					str->typedef_begins);
				str->typedef_begins->owning_section->erroneous_interface = TRUE;
			}
			CLike__section_subset(str, TRUE);
			for (structure_permission *sp = str->first_permission; sp; sp = sp->next_permission) {
				sp->shared_with->scratch_flag |= 2;
				if (sp->shared_with->scratch_flag == 2) {
					Main__error_in_web("structure declared as shared, but it isn't",
						sp->granted_at);
					str->typedef_begins->owning_section->erroneous_interface = TRUE;
				}
			}
			section *S;
			LOOP_OVER(S, section)
				if (S->scratch_flag == 1) {
					Main__error_in_web("structure has missing shared declarations",
						str->typedef_begins);
					str->typedef_begins->owning_section->erroneous_interface = TRUE;
					break;
				}
		}
		section *S;
		LOOP_OVER(S, section)
			if (S->erroneous_interface) {
				printf("Interface for section %s should be:\n", S->sect_title);
				
{
#line 841 "inweb/Chapter 4/C-Like Languages.w"
	c_structure *str;
	for (str = first_cst_alphabetically; str;
		str = str->next_cst_alphabetically)
		if (str->typedef_begins->owning_section == S) {
			int c = CLike__section_subset(str, FALSE);
			printf("-- Owns struct %s (%s)\n", str->structure_name,
				(c > 0)?"public":"private");
			section *SS;
			LOOP_OVER(SS, section)
				if (SS->scratch_flag)
					PRINT("\t!- shared with %S\n", SS->source_file_for_section);
		}

}
#line 833 "inweb/Chapter 4/C-Like Languages.w"
;
			}
	}
}

#line 857 "inweb/Chapter 4/C-Like Languages.w"
int CLike__section_subset(c_structure *str, int report) {
	int c = 0;
	section *S;
	LOOP_OVER(S, section) S->scratch_flag = 0;
	for (structure_element *elt = str->first_element; elt; elt = elt->next_element) {
		int d = 0;
		hash_table_entry *hte = Analyser__find_hash_entry(elt->element_created_at->owning_section, elt->element_name, FALSE);
		if (hte)
			for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage) {
				if (hteu->form_of_usage & ELEMENT_ACCESS_USAGE) {
					d++;
					if (hteu->usage_recorded_at->under_section != str->typedef_begins->owning_section) {
						if (hteu->usage_recorded_at->under_section->scratch_flag == 0) c++;
						hteu->usage_recorded_at->under_section->scratch_flag = 1;
					}
				}
			}
		if ((report) && (d == 0) && (elt->allow_sharing == FALSE))
			Main__error_in_web("element is never used",
				elt->element_created_at);
	}
	return c;
}

#line 34 "inweb/Chapter 4/C for Inform.w"

#line 42 "inweb/Chapter 4/C for Inform.w"

#line 46 "inweb/Chapter 4/C for Inform.w"
preform_nonterminal *first_pnt_alphabetically = NULL;

theme_tag *Preform_theme = NULL;

#line 56 "inweb/Chapter 4/C for Inform.w"
int CForInform__special_data(OUTPUT_STREAM, char *data) {
	if (CStrings__eq(data, "nonterminals")) {
		WRITE("register_tangled_nonterminals();\n");
		return TRUE;
	}
	return FALSE;
}

#line 73 "inweb/Chapter 4/C for Inform.w"
void CForInform__further_parsing(web *W) {
	LOOP_WITHIN_TANGLE(W->first_target) {
		int form = NOT_A_NONTERMINAL; /* one of the four values above, or a non-negative word count */
		string pntname; CStrings__copy(pntname, "");
		string header; CStrings__copy(header, "");
		
{
#line 122 "inweb/Chapter 4/C for Inform.w"
	string found_text1;
	string found_text2;
	string found_text3;
	if (ISORegexp__match_1(L->text, "(<%p+>) ::=%c*", found_text1)) {
		form = A_GRAMMAR_NONTERMINAL;
		CStrings__copy(pntname, found_text1);
		CStrings__copy(header, found_text1);
		
{
#line 156 "inweb/Chapter 4/C for Inform.w"
	source_line *AL;
	for (AL = L; (AL) && (AL->category == CODE_BODY_LCAT); AL = AL->next_line) {
		if (ISORegexp__string_is_white_space(AL->text)) break;
		AL->category = PREFORM_GRAMMAR_LCAT;

		string found_text1;
		string found_text2;
		if (ISORegexp__match_2(AL->text, "(%c+) ==> (%c*)", found_text1, found_text2)) {
			AL->text_operand = Memory__new_string(found_text1);
			AL->text_operand2 = Memory__new_string(found_text2);
		} else {
			AL->text_operand = AL->text;
			AL->text_operand2 = "";
		}

		
{
#line 183 "inweb/Chapter 4/C for Inform.w"
	string found_text1;
	if (ISORegexp__match_1(AL->text_operand, "(%c*)%/%*%c*%*%/ *", found_text1))
		AL->text_operand = Memory__new_string(found_text1);

}
#line 171 "inweb/Chapter 4/C for Inform.w"
;
		
{
#line 192 "inweb/Chapter 4/C for Inform.w"
	string to_scan; CStrings__copy(to_scan, AL->text_operand2);
	string found_text1;
	string found_text2;
	while (ISORegexp__match_2(to_scan, "%c*?<<(%P+?)>> =(%c*)", found_text1, found_text2)) {
		string var_given; CStrings__copy(var_given, found_text1);
		string type_given; CStrings__copy(type_given, "int");
		CStrings__copy(to_scan, found_text2);
		if (ISORegexp__match_1(var_given, "(%p+):%p+", found_text1)) {
			CSTRING_WRITE(type_given, "%s *", found_text1);
		}
		nonterminal_variable *ntv;
		LOOP_OVER(ntv, nonterminal_variable)
			if (CStrings__eq(ntv->ntv_name, var_given))
				break;
		if (ntv == NULL) 
{
#line 214 "inweb/Chapter 4/C for Inform.w"
	ntv = CREATE(nonterminal_variable);
	CStrings__copy(ntv->ntv_name, var_given);
	CStrings__copy(ntv->ntv_type, type_given);
	for (int i=0; var_given[i]; i++)
		if ((var_given[i] == '-') || (var_given[i] == ':'))
			CStrings__set_char(var_given, i, '_');
	CSTRING_WRITE(ntv->ntv_identifier, "%s_NTMV", var_given);
	ntv->first_mention = AL;

}
#line 206 "inweb/Chapter 4/C for Inform.w"
;
	}

}
#line 172 "inweb/Chapter 4/C for Inform.w"
;
	}

}
#line 129 "inweb/Chapter 4/C for Inform.w"
;
	} else if (ISORegexp__match_2(L->text, "((<%p+>) internal %?) {%c*", found_text1, found_text2)) {
		form = A_VORACIOUS_NONTERMINAL;
		CStrings__copy(pntname, found_text2);
		CStrings__copy(header, found_text1);
	} else if (ISORegexp__match_2(L->text, "((<%p+>) internal) {%c*", found_text1, found_text2)) {
		form = A_FLEXIBLE_NONTERMINAL;
		CStrings__copy(pntname, found_text2);
		CStrings__copy(header, found_text1);
	} else if (ISORegexp__match_3(L->text, "((<%p+>) internal (%d+)) {%c*",
						found_text1, found_text2, found_text3)) {
		form = atoi(found_text3);
		CStrings__copy(pntname, found_text2);
		CStrings__copy(header, found_text1);
	}

}
#line 78 "inweb/Chapter 4/C for Inform.w"
;
		if (form != NOT_A_NONTERMINAL) {
			preform_nonterminal *pnt = CREATE(preform_nonterminal);
			pnt->where_defined = L;
			CStrings__copy(pnt->nt_name, pntname);
			CStrings__copy(pnt->unangled_name, pntname + 1);
			CStrings__truncate(pnt->unangled_name, CStrings__len(pnt->unangled_name)-1);
			pnt->next_pnt_alphabetically = NULL;
			if (first_pnt_alphabetically == NULL) first_pnt_alphabetically = pnt;
			else {
				int placed = FALSE;
				preform_nonterminal *last = NULL;
				for (preform_nonterminal *seq = first_pnt_alphabetically; seq;
					seq = seq->next_pnt_alphabetically) {
					if (CStrings__cmp(pntname, seq->nt_name) < 0) {
						if (seq == first_pnt_alphabetically) {
							pnt->next_pnt_alphabetically = first_pnt_alphabetically;
							first_pnt_alphabetically = pnt;
						} else {
							last->next_pnt_alphabetically = pnt;
							pnt->next_pnt_alphabetically = seq;
						}
						placed = TRUE;
						break;
					}
					last = seq;
				}
				if (placed == FALSE) last->next_pnt_alphabetically = pnt;
			}
			
{
#line 229 "inweb/Chapter 4/C for Inform.w"
	CStrings__copy(pnt->as_C_identifier, pnt->nt_name + 1);
	for (int i=0; pnt->as_C_identifier[i]; i++) {
		if (pnt->as_C_identifier[i] == '-') CStrings__set_char(pnt->as_C_identifier, i, '_');
		if (pnt->as_C_identifier[i] == '>') CStrings__truncate(pnt->as_C_identifier, i);
	}
	CStrings__concatenate(pnt->as_C_identifier, "_NTM");

}
#line 107 "inweb/Chapter 4/C for Inform.w"
;
			
{
#line 239 "inweb/Chapter 4/C for Inform.w"
	pnt->voracious = FALSE; if (form == A_VORACIOUS_NONTERMINAL) pnt->voracious = TRUE;
	pnt->as_function = TRUE; if (form == A_GRAMMAR_NONTERMINAL) pnt->as_function = FALSE;

	pnt->takes_pointer_result = FALSE;
	if (ISORegexp__match_0(pnt->nt_name, "<k-%c+")) pnt->takes_pointer_result = TRUE;
	if (ISORegexp__match_0(pnt->nt_name, "<s-%c+")) pnt->takes_pointer_result = TRUE;

	int min = 1, max = form;
	if (form < 0) max = INFINITE_WORD_COUNT;
	if (max == 0) min = 0;
	else if (max != INFINITE_WORD_COUNT) min = max;
	pnt->min_word_count = min;
	pnt->max_word_count = max;

}
#line 108 "inweb/Chapter 4/C for Inform.w"
;
			L->preform_nonterminal_defined = pnt;
			if (Preform_theme) Parser__add_tag_to_para(L->owning_paragraph, Preform_theme, NULL);
			L->category = PREFORM_LCAT;
			L->text_operand = Memory__new_string(header);
		}
	}
}

#line 264 "inweb/Chapter 4/C for Inform.w"
void CForInform__additional_predeclarations(OUTPUT_STREAM, web *W) {
	LOOP_WITHIN_TANGLE(W->first_target)
		if (L->preform_nonterminal_defined) {
			preform_nonterminal *pnt = L->preform_nonterminal_defined;
			Languages__insert_line_marker(OUT, W->main_language, L);
			WRITE("nonterminal *%s = NULL;\n", pnt->as_C_identifier);
		}

	nonterminal_variable *ntv;
	LOOP_OVER(ntv, nonterminal_variable)
		WRITE("%s %s = %s;\n",
			ntv->ntv_type, ntv->ntv_identifier,
			(CStrings__eq(ntv->ntv_type, "int"))?"0":"NULL");

	WRITE("void register_tangled_nonterminals(void);\n");
}

#line 285 "inweb/Chapter 4/C for Inform.w"
void CForInform__gnabehs(OUTPUT_STREAM, web *W) {
	WRITE("void register_tangled_nonterminals(void) {\n");
	LOOP_WITHIN_TANGLE(W->first_target)
		if (L->preform_nonterminal_defined) {
			preform_nonterminal *pnt = L->preform_nonterminal_defined;
			Languages__insert_line_marker(OUT, W->main_language, L);
			if (pnt->as_function) {
				WRITE("\tINTERNAL_NONTERMINAL(\"%s\", %s, %d, %d);\n",
					pnt->nt_name, pnt->as_C_identifier,
					pnt->min_word_count, pnt->max_word_count);
				WRITE("\t%s->voracious = %d;\n",
					pnt->as_C_identifier, pnt->voracious);
			} else {
				WRITE("\tREGISTER_NONTERMINAL(\"%s\", %s);\n",
					pnt->nt_name, pnt->as_C_identifier);
			}
		}
	WRITE("}\n");
}

#line 313 "inweb/Chapter 4/C for Inform.w"
int CForInform__will_insert_in_tangle(source_line *L) {
	if (L->category == PREFORM_LCAT) return TRUE;
	return FALSE;
}

#line 334 "inweb/Chapter 4/C for Inform.w"
void CForInform__insert_in_tangle(OUTPUT_STREAM, source_line *L) {
	preform_nonterminal *pnt = L->preform_nonterminal_defined;
	if (pnt->as_function) {
		WRITE("int %sR(wording W, int *X, void **XP) {\n",
			pnt->as_C_identifier);
	} else {
		WRITE("int %sC(int *X, void **XP, int *R, void **RP, wording W) {\n",
			pnt->as_C_identifier);
		
{
#line 391 "inweb/Chapter 4/C for Inform.w"
	int needs_collation = FALSE;
	for (source_line *AL = L->next_line;
		((AL) && (AL->category == PREFORM_GRAMMAR_LCAT));
		AL = AL->next_line)
			if (AL->text_operand2[0])
				needs_collation = TRUE;
	if (needs_collation) 
{
#line 411 "inweb/Chapter 4/C for Inform.w"
	WRITE("\tswitch(R[0]) {\n");
	int c = 0;
	for (source_line *AL = L->next_line;
		((AL) && (AL->category == PREFORM_GRAMMAR_LCAT));
		AL = AL->next_line, c++) {
		char *formula = AL->text_operand2;
		if (formula[0]) {
			WRITE("\t\tcase %d: ", c);
			
{
#line 448 "inweb/Chapter 4/C for Inform.w"
	if (!ISORegexp__match_0(formula, "@<%c*")) {
		if (pnt->takes_pointer_result) WRITE("*XP = ");
		else WRITE("*X = ");
	}
	string expanded; CStrings__copy(expanded, "");
	for (int i=0; formula[i]; i++) {
		if ((formula[i] == 'W') && (formula[i+1] == 'R') &&
			(formula[i+2] == '[') && (isdigit(formula[i+3])) && (formula[i+4] == ']')) {
				CSTRING_WRITE(expanded+CStrings__len(expanded),
					"%s->range_result[%c]", pnt->as_C_identifier, formula[i+3]);
				i += 4;
		} else {
			CSTRING_WRITE(expanded+CStrings__len(expanded), "%c", formula[i]);
		}
	}
	Tangler__tangle_code(OUT, expanded, AL->owning_section, AL);

}
#line 419 "inweb/Chapter 4/C for Inform.w"
;
			WRITE(";\n");
			WRITE("#pragma clang diagnostic push\n");
			WRITE("#pragma clang diagnostic ignored \"-Wunreachable-code\"\n");
			WRITE("break;\n");
			WRITE("#pragma clang diagnostic pop\n");
		}
	}
	WRITE("\t\tdefault: *X = R[0]; break;\n");
	WRITE("\t}\n");

}
#line 397 "inweb/Chapter 4/C for Inform.w"

	else 
{
#line 406 "inweb/Chapter 4/C for Inform.w"
	WRITE("\t*X = R[0];\n");

}
#line 398 "inweb/Chapter 4/C for Inform.w"
;
	WRITE("\treturn TRUE;\n");

}
#line 342 "inweb/Chapter 4/C for Inform.w"
;
		WRITE("}\n");
	}
}

#line 470 "inweb/Chapter 4/C for Inform.w"
void CForInform__tangle_code(OUTPUT_STREAM, char *original) {
	int fcall_pos = -1;
	for (int i = 0; original[i]; i++) {
		
{
#line 512 "inweb/Chapter 4/C for Inform.w"
	if ((i > 0) && (original[i] == ':') && (original[i+1] == ':') &&
		(isalpha(original[i+2])) && (isalnum(original[i-1]))) {
		WRITE("__"); i++;
		continue;
	}

}
#line 473 "inweb/Chapter 4/C for Inform.w"
;
		if (original[i] == '<') {
			if (original[i+1] == '<') {
				
{
#line 524 "inweb/Chapter 4/C for Inform.w"
	string found_text1;
	if (ISORegexp__match_1(original+i, "<<(%P+)>>%c*", found_text1)) {
		string putative; CStrings__copy(putative, found_text1);
		char *pv_identifier = CForInform__nonterminal_variable_identifier(putative);
		if (pv_identifier) {
			WRITE("%s", pv_identifier);
			i += CStrings__len(putative) + 3;
			continue;
		}
	}

}
#line 476 "inweb/Chapter 4/C for Inform.w"
;
			} else {
				
{
#line 551 "inweb/Chapter 4/C for Inform.w"
	string found_text1;
	if (ISORegexp__match_1(original+i, "(<%p+>)%c*", found_text1)) {
		string putative; CStrings__copy(putative, found_text1);
		preform_nonterminal *pnt = CForInform__nonterminal_by_name(putative);
		if (pnt) {
			i += CStrings__len(putative) - 1;
			if (original[i+1] == '(') {
				int arity = 1;
				for (int j = i+2, bl = 1; ((original[j]) && (bl > 0)); j++) {
					if (original[j] == '(') bl++;
					if (original[j] == ')') { bl--; if (bl == 0) fcall_pos = j; }
					if ((original[j] == ',') && (bl == 1)) arity++;
				}
				WRITE("Preform__parse_nt_against_word_range(");
			}
			WRITE("%s", pnt->as_C_identifier);
			if (fcall_pos >= 0) {
				WRITE(", "); i++;
			}
			continue;
		}
	}

}
#line 478 "inweb/Chapter 4/C for Inform.w"
;
			}
		}
		if (i == fcall_pos) {
			fcall_pos = -1;
			WRITE(", NULL, NULL");
		}
		PUT(original[i]);
	}
}

#line 580 "inweb/Chapter 4/C for Inform.w"
preform_nonterminal *CForInform__nonterminal_by_name(char *name) {
	preform_nonterminal *pnt;
	LOOP_OVER(pnt, preform_nonterminal)
		if (CStrings__eq(name, pnt->nt_name))
			return pnt;
	return NULL;
}

#line 594 "inweb/Chapter 4/C for Inform.w"
char *CForInform__nonterminal_variable_identifier(char *name) {
	if (CStrings__eq(name, "r")) return "most_recent_result";
	if (CStrings__eq(name, "rp")) return "most_recent_result_p";
	nonterminal_variable *ntv;
	LOOP_OVER(ntv, nonterminal_variable)
		if (CStrings__eq(ntv->ntv_name, name))
			return ntv->ntv_identifier;
	return NULL;
}

#line 616 "inweb/Chapter 4/C for Inform.w"
void CForInform__additional_tangling(programming_language *pl, web *W, tangle_target *target) {
	if (NUMBER_CREATED(preform_nonterminal) > 0) {
		pathname *P = Pathnames__subfolder(W->path_to_web, "Tangled");
		filename *Syntax = Filenames__in_folder(P, "Syntax.preform");

		text_stream TO_struct;
		text_stream *OUT = &TO_struct;
		if (STREAM_OPEN_TO_FILE(OUT, Syntax, ISO_ENC) == FALSE)
			Errors__fatal_with_file("unable to write Preform file", Syntax);

		WRITE_TO(STDOUT, "Writing Preform syntax to: %/f\n", Syntax);

		WRITE("[This is English.preform, generated by inweb: do not edit.]\n\n");
		WRITE("language English\n");

		
{
#line 649 "inweb/Chapter 4/C for Inform.w"
	LOOP_WITHIN_TANGLE(target)
		if (L->category == PREFORM_LCAT) {
			preform_nonterminal *pnt = L->preform_nonterminal_defined;
			if (pnt->as_function)
				WRITE("\n%s internal\n", pnt->nt_name);
			else
				WRITE("\n%s ::=\n", L->text_operand);
			for (source_line *AL = L->next_line;
				((AL) && (AL->category == PREFORM_GRAMMAR_LCAT));
				AL = AL->next_line) {
				WRITE("%s", AL->text_operand);
				string found_text1;
				if (ISORegexp__match_1(AL->text_operand2, "%c+Issue (%c+) problem%c+", found_text1))
					WRITE("[issues %s]", found_text1);
				WRITE("\n");
			}
		}

}
#line 631 "inweb/Chapter 4/C for Inform.w"
;
		STREAM_CLOSE(OUT);
	}
}

#line 670 "inweb/Chapter 4/C for Inform.w"
void CForInform__weave_grammar_index(OUTPUT_STREAM) {
	WRITE("\\raggedright\\tolerance=10000");
	preform_nonterminal *pnt;
	for (pnt = first_pnt_alphabetically; pnt;
		pnt = pnt->next_pnt_alphabetically) {
		WRITE("\\line{\\nonterminal{%s}%s"
			"\\leaders\\hbox to 1em{\\hss.\\hss}\\hfill {\\xreffont %s}}\n",
			pnt->unangled_name,
			(pnt->as_function)?" (internal)":"",
			pnt->where_defined->owning_section->sigil);
		int said_something = FALSE;
		
{
#line 719 "inweb/Chapter 4/C for Inform.w"
	section *S;
	LOOP_OVER(S, section) S->scratch_flag = FALSE;
	hash_table_entry *hte = Analyser__find_hash_entry(pnt->where_defined->owning_section, pnt->unangled_name, FALSE);
	for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
		if (hteu->form_of_usage & PREFORM_IN_GRAMMAR_USAGE)
			hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
	int use_count = 0;
	LOOP_OVER(S, section)
		if (S->scratch_flag)
			use_count++;
	if (use_count > 0) {
		said_something = TRUE;
		WRITE("\\par\\hangindent=3em{\\it used by other nonterminals in} ");
		int c = 0;
		LOOP_OVER(S, section)
			if (S->scratch_flag) {
				if (c++ > 0) WRITE(", ");
				WRITE("{\\xreffont %s}", S->sigil);
			}
		WRITE("\n\n");
	}

}
#line 681 "inweb/Chapter 4/C for Inform.w"
;
		
{
#line 694 "inweb/Chapter 4/C for Inform.w"
	section *S;
	LOOP_OVER(S, section) S->scratch_flag = FALSE;
	hash_table_entry *hte = Analyser__find_hash_entry(pnt->where_defined->owning_section, pnt->unangled_name, FALSE);
	for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
		if (hteu->form_of_usage & PREFORM_IN_CODE_USAGE)
			hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
	int use_count = 0;
	LOOP_OVER(S, section)
		if (S->scratch_flag)
			use_count++;
	if (use_count > 0) {
		said_something = TRUE;
		WRITE("\\par\\hangindent=3em{\\it called from} ");
		int c = 0;
		LOOP_OVER(S, section)
			if (S->scratch_flag) {
				if (c++ > 0) WRITE(", ");
				WRITE("{\\xreffont %s}", S->sigil);
			}
		WRITE("\n\n");
	}

}
#line 682 "inweb/Chapter 4/C for Inform.w"
;
		if (said_something == FALSE)
			WRITE("\\par\\hangindent=3em{\\it unused}\n\n");
	}
	WRITE("\\penalty-1000\n");
	WRITE("\\smallbreak\n");
	WRITE("\\hrule\\smallbreak\n");
}

#line 745 "inweb/Chapter 4/C for Inform.w"
void CForInform__new_tag_declared(theme_tag *tag) {
	if (CStrings__eq(tag->tag_name, "Preform")) Preform_theme = tag;
}

int skipping_internal = FALSE, preform_production_count = 0;

int CForInform__skip_in_weaving(weave_target *wv, source_line *L) {
	if ((Preform_theme) && (wv->theme_match == Preform_theme)) {
		if (ISORegexp__match_0(L->text, "}%c*")) { skipping_internal = FALSE; return TRUE; }
		if (skipping_internal) return TRUE;
		if (ISORegexp__match_0(L->text, "<%c*?> internal%c*")) skipping_internal = TRUE;
	}
	return FALSE;
}

void CForInform__begin_weave(section *S, weave_target *wv) {
}

#line 766 "inweb/Chapter 4/C for Inform.w"
int CForInform__syntax_colour(OUTPUT_STREAM, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) {
	return FALSE;
}

int CForInform__weave_code_line(OUTPUT_STREAM, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) {
	if ((Preform_theme) && (wv->theme_match == Preform_theme)) {
		if (L->preform_nonterminal_defined) preform_production_count = 0;
		if (L->preform_nonterminal_defined) {
			WRITE("\\nonterminal{%s} |::=|",
				L->preform_nonterminal_defined->unangled_name);
			if (L->preform_nonterminal_defined->as_function) {
				WRITE("\\quad{\\it internal definition");
				if (L->preform_nonterminal_defined->voracious)
					WRITE(" (voracious)");
				else if (L->preform_nonterminal_defined->min_word_count ==
					L->preform_nonterminal_defined->min_word_count)
					WRITE(" (%d word%s)",
						L->preform_nonterminal_defined->min_word_count,
						(L->preform_nonterminal_defined->min_word_count != 1)?"s":"");
				WRITE("}");
			}
			WRITE("\n");
			return TRUE;
		} else {
			if (L->category == PREFORM_GRAMMAR_LCAT) {
				string problem; CStrings__copy(problem, "");
				string found_text1;
				string found_text2;
				string found_text3;
				if (ISORegexp__match_1(matter, "Issue (%c*?) problem", found_text1)) CStrings__copy(problem, found_text1);
				if (ISORegexp__match_0(matter, "FAIL_NONTERMINAL %+")) CStrings__copy(problem, "fail and skip");
				else if (ISORegexp__match_0(matter, "FAIL_NONTERMINAL")) CStrings__copy(problem, "fail");
				preform_production_count++;
				CSTRING_WRITE(matter, "|%s|", L->text_operand);
				while (ISORegexp__match_2(matter, "(%c+?)|(%c+)", found_text1, found_text2))
					CSTRING_WRITE(matter, "%s___stroke___%s",
						found_text1, found_text2);
				while (ISORegexp__match_2(matter, "(%c*?)___stroke___(%c*)", found_text1, found_text2))
					CSTRING_WRITE(matter, "%s|\\||%s",
						found_text1, found_text2);
				while (ISORegexp__match_3(matter, "(%c*)<(%c*?)>(%c*)",
						found_text1, found_text2, found_text3))
					CSTRING_WRITE(matter, "%s|\\nonterminal{%s}|%s",
						found_text1, found_text2, found_text3);
				string label; CStrings__copy(label, "");
				int N = preform_production_count;
				int L = ((N-1)%26) + 1;
				if (N <= 26) CSTRING_WRITE(label, "%c", 'a'+L-1);
				else if (N <= 52) CSTRING_WRITE(label, "%c%c", 'a'+L-1, 'a'+L-1);
				else if (N <= 78) CSTRING_WRITE(label, "%c%c%c", 'a'+L-1, 'a'+L-1, 'a'+L-1);
				else {
					int n = (N-1)/26;
					CSTRING_WRITE(label, "%c${}^{%d}$", 'a'+L-1, n);
				}
				WRITE("\\qquad {\\hbox to 0.4in{\\it %s\\hfil}}%s", label, matter);
				if (problem[0])
					WRITE("\\hfill$\\longrightarrow$ {\\ttninepoint\\it %s}", problem);
				else if (concluding_comment[0]) {
					WRITE(" \\hfill{\\ttninepoint\\it ");
					if (concluding_comment) Formats__identifier(OUT, wv, concluding_comment);
					WRITE("}");
				}
				WRITE("\n");
				return TRUE;
			}
		}
	}
	return FALSE;
}

#line 841 "inweb/Chapter 4/C for Inform.w"
void CForInform__analyse_code(programming_language *pl, web *W) {
	preform_nonterminal *pnt;
	LOOP_OVER(pnt, preform_nonterminal)
		Analyser__find_hash_entry(pnt->where_defined->owning_section, pnt->unangled_name, TRUE);
	LOOP_WITHIN_TANGLE(W->first_target) {
		if (L->category == INTERFACE_BODY_LCAT) {
			string found_text1;
			string found_text2;
			if (ISORegexp__match_2(L->text, "-- Defines {-(%c+?):(%c+)} *", found_text1, found_text2)) {
				L->interface_line_identified = TRUE;
				int form = 0;
				if (CStrings__eq(found_text1, "call")) form = 1;
				if (CStrings__eq(found_text1, "callv")) form = 2;
				if (CStrings__eq(found_text1, "routine")) form = 3;
				if (CStrings__eq(found_text1, "array")) form = 4;
				if (form == 0) {
					Main__error_in_web("bad {-format:...}", L);
					continue;
				}
				string function_name; CStrings__copy(function_name, "");
				switch (form) {
					case 1: case 2: CStrings__copy(function_name, found_text2); break;
					case 3: CSTRING_WRITE(function_name, "%s_routine", found_text2); break;
					case 4: CSTRING_WRITE(function_name, "%s_array", found_text2); break;
				}
				function *fn = CLike__get_function_with_name(function_name);
				if (fn == NULL) {
					Main__error_in_web("no such function exists", L);
					fprintf(stderr, "  >> %s\n", function_name);
					continue;
				}
				fn->called_from_other_sections = TRUE;
			}
		}
	}
}

#line 13 "inweb/Chapter 5/Weave Formats.w"
weave_format *plain_text_format = NULL;
weave_format *tex_format = NULL;
weave_format *dvi_format = NULL;
weave_format *pdf_format = NULL;
weave_format *html_format = NULL;
weave_format *epub_format = NULL;

void Formats__create_weave_formats(void) {
	plain_text_format = Formats__create_weave_format("plain", ".txt", NULL);
	tex_format = Formats__create_weave_format("TeX", ".tex", NULL);
	dvi_format = Formats__create_weave_format("DVI", ".dvi", tex_format);
	pdf_format = Formats__create_weave_format("PDF", ".pdf", tex_format);
	html_format = Formats__create_weave_format("HTML", ".html", NULL);
	epub_format = Formats__create_weave_format("ePub", ".epub", html_format);
}

#line 38 "inweb/Chapter 5/Weave Formats.w"

#line 42 "inweb/Chapter 5/Weave Formats.w"
weave_format *Formats__create_weave_format(char *name, char *ext, weave_format *intermediate) {
	weave_format *wf = CREATE(weave_format);
	wf->format_name = name;
	wf->woven_extension = ext;
	wf->intermediate = intermediate;
	return wf;
}

#line 53 "inweb/Chapter 5/Weave Formats.w"
weave_format *Formats__parse_format(char *name) {
	weave_format *wf;
	LOOP_OVER(wf, weave_format)
		if (CStrings__eq_insensitive(name, wf->format_name))
			return wf;
	return NULL;
}

int Formats__html_like(weave_format *wf) {
	if (wf->intermediate) wf = wf->intermediate;
	if ((wf == html_format) || (wf == epub_format)) return TRUE;
	return FALSE;
}

char *Formats__weave_file_extension(weave_format *wf) {
	if (wf->intermediate) wf = wf->intermediate;
	return wf->woven_extension;
}

#line 75 "inweb/Chapter 5/Weave Formats.w"
int Formats__begin_weaving(web *W, char *format) {
	if (Formats__parse_format(format) == epub_format) {
		TEMPORARY_TEXT(T)
		WRITE_TO(T, "%s", Bibliographic__get_data(W, "Title"));
		W->as_ebook = Epub__new(T);
		filename *CSS = Filenames__in_folder(path_to_inweb_materials, "inweb.css");
		Epub__use_CSS(W->as_ebook, CSS);
		Epub__attach_metadata(W->as_ebook, L"identifier", T);
		pathname *P = Pathnames__subfolder(W->path_to_web, "Woven");
		W->redirect_weaves_to = Epub__begin_construction(W->as_ebook, P, NULL);
		Shell__copy(CSS, W->redirect_weaves_to, "");
		return SWARM_SECTIONS;
	}
	return SWARM_OFF;
}

void Formats__end_weaving(web *W, char *format) {
	if (Formats__parse_format(format) == epub_format) {
		Epub__end_construction(W->as_ebook);
	}
}

#line 100 "inweb/Chapter 5/Weave Formats.w"
void Formats__top(OUTPUT_STREAM, weave_target *wv, char *comment) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__top(OUT, wv, comment); return; }
	if (wf == tex_format) { TeX__top(OUT, wv, comment); return; }
	if (Formats__html_like(wf)) { HTMLFormat__top(OUT, wv, comment); return; }
}

void Formats__subheading(OUTPUT_STREAM, weave_target *wv, int level, char *comment, char *head) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__subheading(OUT, wv, level, comment, head); return; }
	if (wf == tex_format) { TeX__subheading(OUT, wv, level, comment, head); return; }
	if (Formats__html_like(wf)) { HTMLFormat__subheading(OUT, wv, level, comment, head); return; }
}

void Formats__toc(OUTPUT_STREAM, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__toc(OUT, wv, stage, text1, text2, P); return; }
	if (wf == tex_format) { TeX__toc(OUT, wv, stage, text1, text2, P); return; }
	if (Formats__html_like(wf)) { HTMLFormat__toc(OUT, wv, stage, text1, text2, P); return; }
}

void Formats__chapter_tp(OUTPUT_STREAM, weave_target *wv, chapter *C) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__chapter_tp(OUT, wv, C); return; }
	if (wf == tex_format) { TeX__chapter_tp(OUT, wv, C); return; }
	if (Formats__html_like(wf)) { HTMLFormat__chapter_tp(OUT, wv, C); return; }
}

void Formats__paragraph_heading(OUTPUT_STREAM, weave_target *wv, char *TeX_macro,
	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark,
	int weight) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format)
		{ PlainText__paragraph_heading(OUT, wv, TeX_macro, S, P, heading_text, chaptermark, sectionmark, weight); return; }
	if (wf == tex_format)
		{ TeX__paragraph_heading(OUT, wv, TeX_macro, S, P, heading_text, chaptermark, sectionmark, weight); return; }
	if (Formats__html_like(wf))
		{ HTMLFormat__paragraph_heading(OUT, wv, TeX_macro, S, P, heading_text, chaptermark, sectionmark, weight); return; }
}

void Formats__source_code(OUTPUT_STREAM, weave_target *wv,
	int tab_stops_of_indentation,
	char *prefatory, char *matter, char *colouring, char *concluding_comment,
	int starts, int finishes, int code_mode) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__source_code(OUT, wv, tab_stops_of_indentation,
		prefatory, matter, colouring, concluding_comment, starts, finishes, code_mode); return; }
	if (wf == tex_format) { TeX__source_code(OUT, wv, tab_stops_of_indentation,
		prefatory, matter, colouring, concluding_comment, starts, finishes, code_mode); return; }
	if (Formats__html_like(wf)) { HTMLFormat__source_code(OUT, wv, tab_stops_of_indentation,
		prefatory, matter, colouring, concluding_comment, starts, finishes, code_mode); return; }
}

void Formats__source_fragment(OUTPUT_STREAM, weave_target *wv, char *fragment) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) PlainText__inline_code(OUT, wv, TRUE);
	if (wf == tex_format) TeX__inline_code(OUT, wv, TRUE);
	if (Formats__html_like(wf)) HTMLFormat__inline_code(OUT, wv, TRUE);
	string colouring;
	for (int i=0; fragment[i]; i++) colouring[i] = PLAIN_CODE;
	colouring[CStrings__len(fragment)] = 0;
	Formats__source_code(OUT, wv, 0, "", fragment, colouring, "", FALSE, FALSE, TRUE);
	if (wf == plain_text_format) PlainText__inline_code(OUT, wv, FALSE);
	if (wf == tex_format) TeX__inline_code(OUT, wv, FALSE);
	if (Formats__html_like(wf)) HTMLFormat__inline_code(OUT, wv, FALSE);
}

void Formats__comment_lines(OUTPUT_STREAM, weave_target *wv, source_line *from, source_line *to) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__comment_lines(OUT, wv, from, to); return; }
	if (wf == tex_format) { TeX__comment_lines(OUT, wv, from, to); return; }
	if (Formats__html_like(wf)) { HTMLFormat__comment_lines(OUT, wv, from, to); return; }
}

void Formats__display_line(OUTPUT_STREAM, weave_target *wv, char *from) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__display_line(OUT, wv, from); return; }
	if (wf == tex_format) { TeX__display_line(OUT, wv, from); return; }
	if (Formats__html_like(wf)) { HTMLFormat__display_line(OUT, wv, from); return; }
}

void Formats__item(OUTPUT_STREAM, weave_target *wv, int depth, char *label) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__item(OUT, wv, depth, label); return; }
	if (wf == tex_format) { TeX__item(OUT, wv, depth, label); return; }
	if (Formats__html_like(wf)) { HTMLFormat__item(OUT, wv, depth, label); return; }
}

void Formats__bar(OUTPUT_STREAM, weave_target *wv) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__bar(OUT, wv); return; }
	if (wf == tex_format) { TeX__bar(OUT, wv); return; }
	if (Formats__html_like(wf)) { HTMLFormat__bar(OUT, wv); return; }
}

void Formats__figure(OUTPUT_STREAM, weave_target *wv, char *figname, int cm) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__figure(OUT, wv, figname, cm); return; }
	if (wf == tex_format) { TeX__figure(OUT, wv, figname, cm); return; }
	if (Formats__html_like(wf)) { HTMLFormat__figure(OUT, wv, figname, cm); return; }
}

void Formats__cweb_macro(OUTPUT_STREAM, weave_target *wv, cweb_macro *cwm, int defn) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__cweb_macro(OUT, wv, cwm, defn); return; }
	if (wf == tex_format) { TeX__cweb_macro(OUT, wv, cwm, defn); return; }
	if (Formats__html_like(wf)) { HTMLFormat__cweb_macro(OUT, wv, cwm, defn); return; }
}

void Formats__pagebreak(OUTPUT_STREAM, weave_target *wv) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__pagebreak(OUT, wv); return; }
	if (wf == tex_format) { TeX__pagebreak(OUT, wv); return; }
	if (Formats__html_like(wf)) { HTMLFormat__pagebreak(OUT, wv); return; }
}

void Formats__blank_line(OUTPUT_STREAM, weave_target *wv, int in_comment) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__blank_line(OUT, wv, in_comment); return; }
	if (wf == tex_format) { TeX__blank_line(OUT, wv, in_comment); return; }
	if (Formats__html_like(wf)) { HTMLFormat__blank_line(OUT, wv, in_comment); return; }
}

void Formats__code_note(OUTPUT_STREAM, weave_target *wv, char *comment) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__code_note(OUT, wv, comment); return; }
	if (wf == tex_format) { TeX__code_note(OUT, wv, comment); return; }
	if (Formats__html_like(wf)) { HTMLFormat__code_note(OUT, wv, comment); return; }
}

void Formats__change_mode(OUTPUT_STREAM, weave_target *wv, int old_mode, int new_mode, int content) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__change_mode(OUT, wv, old_mode, new_mode, content); return; }
	if (wf == tex_format) { TeX__change_mode(OUT, wv, old_mode, new_mode, content); return; }
	if (Formats__html_like(wf)) { HTMLFormat__change_mode(OUT, wv, old_mode, new_mode, content); return; }
}

#line 267 "inweb/Chapter 5/Weave Formats.w"
void Formats__change_colour(OUTPUT_STREAM, weave_target *wv, int col, int in_code) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__change_colour(OUT, wv, col, in_code); return; }
	if (wf == tex_format) { TeX__change_colour(OUT, wv, col, in_code); return; }
	if (Formats__html_like(wf)) { HTMLFormat__change_colour(OUT, wv, col, in_code); return; }
}

void Formats__endnote(OUTPUT_STREAM, weave_target *wv, int end) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__endnote(OUT, wv, end); return; }
	if (wf == tex_format) { TeX__endnote(OUT, wv, end); return; }
	if (Formats__html_like(wf)) { HTMLFormat__endnote(OUT, wv, end); return; }
}

void Formats__identifier(OUTPUT_STREAM, weave_target *wv, char *id) {
	Formats__identifier_r(OUT, wv, id, FALSE);
}

void Formats__identifier_r(OUTPUT_STREAM, weave_target *wv, char *id, int within) {
	for (int i=0; id[i]; i++) {
		if (id[i] == '\\') i++;
		else if (id[i] == '|') {
			string before; CStrings__copy(before, id); before[i] = 0;
			string after; CStrings__copy(after, id+i+1);
			Formats__identifier_r(OUT, wv, before, within);
			Formats__identifier_r(OUT, wv, after, (within)?FALSE:TRUE);
			return;
		}
	}
	if (within) {
		Formats__source_fragment(OUT, wv, id);
	} else {
		weave_format *wf = wv->format->intermediate;
		if (wf == NULL) wf = wv->format;
		if (wf == plain_text_format) { PlainText__identifier(OUT, wv, id); return; }
		if (wf == tex_format) { TeX__identifier(OUT, wv, id); return; }
		if (Formats__html_like(wf)) { HTMLFormat__identifier(OUT, wv, id); return; }
	}
}

void Formats__locale(OUTPUT_STREAM, weave_target *wv, paragraph *par1, paragraph *par2) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__locale(OUT, wv, par1, par2); return; }
	if (wf == tex_format) { TeX__locale(OUT, wv, par1, par2); return; }
	if (Formats__html_like(wf)) { HTMLFormat__locale(OUT, wv, par1, par2); return; }
}

void Formats__tail(OUTPUT_STREAM, weave_target *wv, char *comment) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) { PlainText__tail(OUT, wv, comment); return; }
	if (wf == tex_format) { TeX__tail(OUT, wv, comment); return; }
	if (Formats__html_like(wf)) { HTMLFormat__tail(OUT, wv, comment); return; }
}

#line 328 "inweb/Chapter 5/Weave Formats.w"
void Formats__post_process_weave(weave_target *wv, int open_afterwards) {
	if (wv->format->intermediate == tex_format)
		RunningTeX__post_process_weave(wv, open_afterwards);
}

void Formats__report_on_post_processing(weave_target *wv) {
	if (wv->format->intermediate == tex_format)
		Formats__report_on_post_processing(wv);
}

int Formats__substitute_post_processing_data(char *to, weave_target *wv, char *detail) {
	if (wv->format->intermediate == tex_format)
		return RunningTeX__substitute_post_processing_data(to, wv, detail);
	return FALSE;
}

int Formats__index_pdfs(char *format) {
	if (Formats__parse_format(format) == pdf_format) return TRUE;
	return FALSE;
}

#line 9 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__top(OUTPUT_STREAM, weave_target *wv, char *comment) {
	WRITE("[%s]\n", comment);
}

#line 16 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__subheading(OUTPUT_STREAM, weave_target *wv, int level, char *comment, char *head) {
	WRITE("%s:\n", comment);
	if ((level == 2) && (head)) { Formats__identifier(OUT, wv, head); WRITE("\n\n"); }
}

#line 24 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__toc(OUTPUT_STREAM, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) {
	switch (stage) {
		case 1: WRITE("%s.", text1); break;
		case 2: WRITE("; "); break;
		case 3: WRITE("%s %s", text1, text2); break;
		case 4: WRITE("\n\n"); break;
	}
}

#line 36 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__chapter_tp(OUTPUT_STREAM, weave_target *wv, chapter *C) {
	WRITE("%s\n\n", C->rubric);
	for (section *S2 = C->first_section; S2; S2 = S2->next_section)
		WRITE("    %s: %s\n        %s\n",
			S2->sigil, S2->sect_title, S2->sect_purpose);
}

#line 46 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__paragraph_heading(OUTPUT_STREAM, weave_target *wv, char *TeX_macro,
	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark,
	int weight) {
	if (P) {
		WRITE("\n");
		Formats__locale(OUT, wv, P, NULL);
		WRITE(". %s    ", heading_text);
	} else {
		WRITE("%s\n\n", heading_text);
	}
}

#line 61 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__source_code(OUTPUT_STREAM, weave_target *wv,
	int tab_stops_of_indentation,
	char *prefatory, char *matter, char *colouring, char *concluding_comment,
	int starts, int finishes, int code_mode) {
	if (starts) {
		for (int i=0; i<tab_stops_of_indentation; i++)
			WRITE("    ");
		if (prefatory[0]) WRITE("%s ", prefatory);
	}
	WRITE("%s", matter);
	if (finishes) {
		if (concluding_comment[0]) WRITE("[%s]", concluding_comment);
		WRITE("\n");
	}
}

#line 80 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__inline_code(OUTPUT_STREAM, weave_target *wv, int enter) {
}

#line 86 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__comment_lines(OUTPUT_STREAM, weave_target *wv, source_line *from, source_line *to) {
}

#line 92 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__display_line(OUTPUT_STREAM, weave_target *wv, char *from) {
	WRITE("    %s\n", from);
}

#line 99 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__item(OUTPUT_STREAM, weave_target *wv, int depth, char *label) {
	if (depth == 1) WRITE("%-4s  ", label);
	else WRITE("%-8s  ", label);
}

#line 107 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__bar(OUTPUT_STREAM, weave_target *wv) {
	WRITE("\n----------------------------------------------------------------------\n\n");
}

#line 114 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__figure(OUTPUT_STREAM, weave_target *wv, char *figname, int cm) {
}

#line 120 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__cweb_macro(OUTPUT_STREAM, weave_target *wv, cweb_macro *cwm, int defn) {
	WRITE("<%s (%s)>%s",
		cwm->macro_name, cwm->defining_paragraph->paragraph_number,
		(defn)?" =":"");
}

#line 129 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__pagebreak(OUTPUT_STREAM, weave_target *wv) {
}

#line 135 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__blank_line(OUTPUT_STREAM, weave_target *wv, int in_comment) {
	WRITE("\n");
}

#line 142 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__code_note(OUTPUT_STREAM, weave_target *wv, char *comment) {
	WRITE("    ...and so on...\n");
}

#line 149 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__change_mode(OUTPUT_STREAM, weave_target *wv, int old_mode, int new_mode, int content) {
}

#line 155 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__change_colour(OUTPUT_STREAM, weave_target *wv, int col, int in_code) {
}

#line 161 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__endnote(OUTPUT_STREAM, weave_target *wv, int end) {
	WRITE("\n");
}

#line 168 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__identifier(OUTPUT_STREAM, weave_target *wv, char *id) {
	WRITE("%s", id);
}

#line 175 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__locale(OUTPUT_STREAM, weave_target *wv, paragraph *par1, paragraph *par2) {
	WRITE("%s%s", par1->ornament, par1->paragraph_number);
	if (par2) WRITE("-%s", par2->paragraph_number);
}

#line 183 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__tail(OUTPUT_STREAM, weave_target *wv, char *comment) {
	WRITE("[%s]\n", comment);
}

#line 9 "inweb/Chapter 5/TeX Format.w"
void TeX__top(OUTPUT_STREAM, weave_target *wv, char *comment) {
	WRITE("%% %s\n", comment);
	
{
#line 22 "inweb/Chapter 5/TeX Format.w"
	filename *Macros = Filenames__in_folder(path_to_inweb_materials, "inweb-macros.tex");
	FILE *MACROS = Platform__iso_fopen(Macros, "r");
	if (MACROS == NULL) Errors__fatal_with_file("can't open file of TeX macros", Macros);
	while (TRUE) {
		int c = fgetc(MACROS);
		if (c == EOF) break;
		PUT(c);
	}
	fclose(MACROS);

}
#line 11 "inweb/Chapter 5/TeX Format.w"
;
}

#line 35 "inweb/Chapter 5/TeX Format.w"
void TeX__subheading(OUTPUT_STREAM, weave_target *wv, int level, char *comment, char *head) {
	switch (level) {
		case 1:
			WRITE("\\par\\noindent{\\bf %s}\\mark{%s}\\medskip\n",
				comment, head);
			break;
		case 2:
			WRITE("\\smallskip\\par\\noindent{\\it %s}\\smallskip\\noindent\n",
				comment);
			if (head) Formats__identifier(OUT, wv, head);
			break;
	}
}

#line 52 "inweb/Chapter 5/TeX Format.w"
void TeX__toc(OUTPUT_STREAM, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) {
	switch (stage) {
		case 1:
			WRITE("\\medskip\\hrule\\smallskip\\par\\noindent{\\usagefont %s.",
				text1);
			break;
		case 2:
			WRITE("; ");
			break;
		case 3:
			WRITE("%s~%s", text1, text2);
			break;
		case 4:
			WRITE("}\\par\\medskip\\hrule\\bigskip\n");
			break;
	}
}

#line 73 "inweb/Chapter 5/TeX Format.w"
void TeX__chapter_tp(OUTPUT_STREAM, weave_target *wv, chapter *C) {
	WRITE("%s\\medskip\n", C->rubric);
	for (section *S2 = C->first_section; S2; S2 = S2->next_section)
		WRITE("\\smallskip\\noindent |%s|: {\\it %s}\\qquad\n%s",
			S2->sigil, S2->sect_title, S2->sect_purpose);
}

#line 83 "inweb/Chapter 5/TeX Format.w"
void TeX__paragraph_heading(OUTPUT_STREAM, weave_target *wv, char *TeX_macro,
	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark,
	int weight) {
	char *orn = (P)?(P->ornament):"P";
	char *N = (P)?(P->paragraph_number):"";
	string mark; CStrings__copy(mark, "");
	CSTRING_WRITE(mark, "%s%s\\quad$\\%s$%s", chaptermark, sectionmark, orn, N);
	string modified; CStrings__copy(modified, heading_text);
	string found_text1;
	string found_text2;
	if (ISORegexp__match_2(modified, "(%c*?): (%c*)", found_text1, found_text2))
		CSTRING_WRITE(modified, "{\\sinchhigh %s}\\quad %s", found_text1, found_text2);
	WRITE("\\%s{%s}{%s}{%s}{\\%s}{%s}%%\n",
		TeX_macro, N, modified, mark, orn, S->sigil);
}

#line 105 "inweb/Chapter 5/TeX Format.w"
void TeX__source_code(OUTPUT_STREAM, weave_target *wv,
	int tab_stops_of_indentation,
	char *prefatory, char *matter, char *colouring, char *concluding_comment,
	int starts, int finishes, int code_mode) {
	if (code_mode == FALSE) WRITE("\\smallskip\\par\\noindent");
	if (starts) {
		
{
#line 137 "inweb/Chapter 5/TeX Format.w"
	for (int i=0; i<tab_stops_of_indentation; i++)
		WRITE("\\qquad");

}
#line 111 "inweb/Chapter 5/TeX Format.w"
;
		if (prefatory[0]) WRITE("{\\ninebf %s} ", prefatory);
		WRITE("|");
	}
	int current_colour = PLAIN_CODE, colour_wanted = PLAIN_CODE;
	for (int i=0; matter[i]; i++) {
		colour_wanted = colouring[i]; 
{
#line 143 "inweb/Chapter 5/TeX Format.w"
	if (colour_wanted != current_colour) {
		Formats__change_colour(OUT, wv, colour_wanted, TRUE);
		current_colour = colour_wanted;
	}

}
#line 117 "inweb/Chapter 5/TeX Format.w"
;
		if (matter[i] == '|') WRITE("|\\||");
		else WRITE("%c", matter[i]);
	}
	colour_wanted = PLAIN_CODE; 
{
#line 143 "inweb/Chapter 5/TeX Format.w"
	if (colour_wanted != current_colour) {
		Formats__change_colour(OUT, wv, colour_wanted, TRUE);
		current_colour = colour_wanted;
	}

}
#line 121 "inweb/Chapter 5/TeX Format.w"
;
	if (finishes) {
		WRITE("|");
		if (concluding_comment[0]) {
			if ((CStrings__ne(matter, "")) || (!starts))
				WRITE("\\hfill\\quad ");
			WRITE("{\\ttninepoint\\it %s}", concluding_comment);
		}
		WRITE("\n");
	}
}

#line 151 "inweb/Chapter 5/TeX Format.w"
void TeX__inline_code(OUTPUT_STREAM, weave_target *wv, int enter) {
	WRITE("|");
}

#line 158 "inweb/Chapter 5/TeX Format.w"
void TeX__change_colour(OUTPUT_STREAM, weave_target *wv, int col, int in_code) {
	if (wv->format == pdf_format) {
		char *inout = "";
		if (in_code) inout = "|";
		switch (col) {
			case MACRO_CODE: WRITE("%s\\pdfliteral direct{1 1 0 0 k}%s", inout, inout); break;
			case FUNCTION_CODE: WRITE("%s\\pdfliteral direct{0 1 1 0 k}%s", inout, inout); break;
			case PLAIN_CODE: WRITE("%s\\special{PDF:0 g}%s", inout, inout); break;
		}
	}
}

#line 173 "inweb/Chapter 5/TeX Format.w"
void TeX__comment_lines(OUTPUT_STREAM, weave_target *wv, source_line *from, source_line *to) {
}

#line 179 "inweb/Chapter 5/TeX Format.w"
void TeX__display_line(OUTPUT_STREAM, weave_target *wv, char *text) {
	WRITE("\\quotesource{%s}\n", text);
}

#line 186 "inweb/Chapter 5/TeX Format.w"
void TeX__item(OUTPUT_STREAM, weave_target *wv, int depth, char *label) {
	if (label[0]) {
		if (depth == 1) WRITE("\\item{(%s)}", label);
		else WRITE("\\itemitem{(%s)}", label);
	} else {
		if (depth == 1) WRITE("\\item{}");
		else WRITE("\\itemitem{}");
	}
}

#line 199 "inweb/Chapter 5/TeX Format.w"
void TeX__bar(OUTPUT_STREAM, weave_target *wv) {
	WRITE("\\par\\medskip\\noindent\\hrule\\medskip\\noindent\n");
}

#line 211 "inweb/Chapter 5/TeX Format.w"
void TeX__figure(OUTPUT_STREAM, weave_target *wv, char *figname, int cm) {
	if (wv->format == pdf_format) {
		WRITE("\\pdfximage");
		if (cm >= 0)
			WRITE(" width %d cm{../Figures/%s}\n", cm, figname);
		else
			WRITE("{../Figures/%s}\n", figname);
		WRITE("\\smallskip\\noindent"
			"\\hbox to\\hsize{\\hfill\\pdfrefximage \\pdflastximage\\hfill}"
			"\\smallskip\n");
	}
}

#line 229 "inweb/Chapter 5/TeX Format.w"
void TeX__cweb_macro(OUTPUT_STREAM, weave_target *wv, cweb_macro *cwm, int defn) {
	if (wv->format == pdf_format) {
		if (defn)
			WRITE("|\\pdfdest num %d fit ",
				cwm->allocation_id + 100);
		else
			WRITE("|\\pdfstartlink attr{/C [0.9 0 0] /Border [0 0 0]} goto num %d ",
				cwm->allocation_id + 100);
	}
	WRITE("$\\langle${\\xreffont");
	Formats__change_colour(OUT, wv, MACRO_CODE, FALSE);
	WRITE(cwm->macro_name);
	WRITE(" ");
	string rest;
	CSTRING_WRITE(rest, "{\\sevenss %s}}", cwm->defining_paragraph->paragraph_number);
	WRITE(rest);
	Formats__change_colour(OUT, wv, PLAIN_CODE, FALSE);
	WRITE("$\\rangle$ ");
	if (wv->format == pdf_format) {
		if (defn)
			WRITE("$\\equiv$|");
		else
			WRITE("\\pdfendlink|");
	}
}

#line 258 "inweb/Chapter 5/TeX Format.w"
void TeX__pagebreak(OUTPUT_STREAM, weave_target *wv) {
	WRITE("\\vfill\\eject\n");
}

#line 265 "inweb/Chapter 5/TeX Format.w"
void TeX__blank_line(OUTPUT_STREAM, weave_target *wv, int in_comment) {
	if (in_comment) WRITE("\\smallskip\\par\\noindent%%\n");
	else WRITE("\\smallskip\n");
}

#line 273 "inweb/Chapter 5/TeX Format.w"
void TeX__endnote(OUTPUT_STREAM, weave_target *wv, int end) {
	if (end == 1) {
		WRITE("\\par\\noindent\\penalty10000\n");
		WRITE("{\\usagefont ");
	} else {
		WRITE("}\\smallskip\n");
	}
}

#line 285 "inweb/Chapter 5/TeX Format.w"
void TeX__identifier(OUTPUT_STREAM, weave_target *wv, char *id) {
	int math_mode = FALSE;
	for (int i=0; id[i]; i++) {
		switch (id[i]) {
			case '$': math_mode = (math_mode)?FALSE:TRUE; break;
			case '_': if (math_mode) WRITE("_"); else WRITE("\\_"); break;
			case '"':
				if ((id[i] == '"') && ((i==0) || (id[i-1] == ' ') || (id[i-1] == '(')))
					WRITE("``");
				else
					WRITE("''");
				break;
			default: WRITE("%c", id[i]);
		}
	}
}

#line 305 "inweb/Chapter 5/TeX Format.w"
void TeX__locale(OUTPUT_STREAM, weave_target *wv, paragraph *par1, paragraph *par2) {
	WRITE("$\\%s$%s", par1->ornament, par1->paragraph_number);
	if (par2) WRITE("-%s", par2->paragraph_number);
}

#line 313 "inweb/Chapter 5/TeX Format.w"
void TeX__code_note(OUTPUT_STREAM, weave_target *wv, char *comment) {
	WRITE("\\smallskip\\par\\noindent");
	WRITE("{\\ttninepoint\\it ...and so on...}\\smallskip\n");
}

#line 321 "inweb/Chapter 5/TeX Format.w"
void TeX__change_mode(OUTPUT_STREAM, weave_target *wv, int old_mode, int new_mode, int content) {
	if (old_mode != new_mode) {
		switch (old_mode) {
			case REGULAR_MATERIAL:
				switch (new_mode) {
					case CODE_MATERIAL:
						WRITE("\\beginlines\n");
						break;
					case DEFINITION_MATERIAL:
						WRITE("\\beginlines\n");
						break;
					case MACRO_MATERIAL:
						WRITE("\\beginlines\n");
						break;
				}
				break;
			default:
				if (new_mode == REGULAR_MATERIAL)
					WRITE("\\endlines\n");
				break;
		}
	}
}

#line 348 "inweb/Chapter 5/TeX Format.w"
void TeX__tail(OUTPUT_STREAM, weave_target *wv, char *comment) {
	WRITE("%% %s\n", comment);
	WRITE("\\end\n");
}

#line 18 "inweb/Chapter 5/HTML Formats.w"
int html_in_para = HTML_OUT; /* one of the above */
int item_depth = 0; /* for |HTML_IN_LI| only: how many lists we're nested inside */

void HTMLFormat__p(OUTPUT_STREAM, char *class) {
	HTML__open_with_class(OUT, "p", class);
	html_in_para = HTML_IN_P;
}

void HTMLFormat__cp(OUTPUT_STREAM) {
	HTML__close(OUT, "p"); WRITE("\n");
	html_in_para = HTML_OUT;
}

void HTMLFormat__pre(OUTPUT_STREAM, char *class) {
	HTML__open_with_class(OUT, "pre", class); WRITE("\n"); INDENT;
	html_in_para = HTML_IN_PRE;
}

void HTMLFormat__cpre(OUTPUT_STREAM) {
	OUTDENT; HTML__close(OUT, "pre"); WRITE("\n");
	html_in_para = HTML_OUT;
}

#line 45 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__go_to_depth(OUTPUT_STREAM, int depth) {
	if (html_in_para != HTML_IN_LI) HTMLFormat__exit_current_paragraph(OUT);
	if (item_depth == depth) {
		HTML__close(OUT, "li");
	} else {
		while (item_depth < depth) {
			HTML__open_with_class(OUT, "ul", "items"); item_depth++;
		}
		while (item_depth > depth) {
			HTML__close(OUT, "li");
			HTML__close(OUT, "ul");
			WRITE("\n"); item_depth--;
		}
	}
	if (depth > 0) {
		HTML__open_with_class(OUT, "li", "NULL");
		html_in_para = HTML_IN_LI;
	} else {
		html_in_para = HTML_OUT;
	}
}

#line 70 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__exit_current_paragraph(OUTPUT_STREAM) {
	switch (html_in_para) {
		case HTML_IN_P: HTMLFormat__cp(OUT); break;
		case HTML_IN_PRE: HTMLFormat__cpre(OUT); break;
		case HTML_IN_LI: HTMLFormat__go_to_depth(OUT, 0); break;
	}
}

#line 81 "inweb/Chapter 5/HTML Formats.w"
section *page_section = NULL;

void HTMLFormat__top(OUTPUT_STREAM, weave_target *wv, char *comment) {
	if (wv->format == epub_format)
		HTML__declare_as_HTML(OUT, TRUE);
	else
		HTML__declare_as_HTML(OUT, FALSE);
	if (wv->format == epub_format)
		Epub__note_page(wv->weave_web->as_ebook, wv->weave_to, wv->booklet_title, "");
	filename *T = NULL;
	if (wv->format == epub_format)
		T = Filenames__in_folder(path_to_inweb_materials, "epub-template");
	else
		T = Filenames__in_folder(path_to_inweb_materials, "template");
	Bibliographic__set_datum(wv->weave_web, "Booklet Title", wv->booklet_title);
	Weaver__weave_cover_from(OUT, wv->weave_web, T, wv, WEAVE_FIRST_HALF);
	filename *CSS = Filenames__in_folder(path_to_inweb_materials, "inweb.css");
	if (wv->format != epub_format)
		Shell__copy(CSS, Pathnames__subfolder(wv->weave_web->path_to_web, "Woven"), "");
	HTML__comment(OUT, comment);
	html_in_para = HTML_OUT;
}

#line 107 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__subheading(OUTPUT_STREAM, weave_target *wv, int level, char *comment, char *head) {
	HTMLFormat__exit_current_paragraph(OUT);
	switch (level) {
		case 1: HTML__heading(OUT, "h3", comment); break;
		case 2: HTMLFormat__p(OUT, "purpose");
			WRITE("%s: ", comment);
			if (head) Formats__identifier(OUT, wv, head);
			HTMLFormat__cp(OUT);
			break;
	}
}

#line 122 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__toc(OUTPUT_STREAM, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) {
	HTMLFormat__exit_current_paragraph(OUT);
	switch (stage) {
		case 1:
			HTML__open_with_class(OUT, "ul", "toc");
			HTML__open(OUT, "li");
			break;
		case 2:
			HTML__close(OUT, "li");
			HTML__open(OUT, "li");
			break;
		case 3: {
			TEMPORARY_STREAM
			HTMLFormat__xref(TEMP, wv, P, NULL, TRUE);
			HTML__begin_link(OUT, TEMP);
			CLOSE_TEMPORARY_STREAM
			WRITE("%s%s", (*(P->ornament) == 'S')?"&#167;":"&para;", P->paragraph_number);
			WRITE(". %s", text2);
			HTML__end_link(OUT);
			break;
		}
		case 4:
			HTML__close(OUT, "li");
			HTML__close(OUT, "ul");
			HTML__hr(OUT, "tocbar");
			WRITE("\n"); break;
	}
}

#line 154 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__chapter_tp(OUTPUT_STREAM, weave_target *wv, chapter *C) {
	return;
}

#line 161 "inweb/Chapter 5/HTML Formats.w"
int crumbs_dropped = FALSE;

void HTMLFormat__paragraph_heading(OUTPUT_STREAM, weave_target *wv, char *TeX_macro,
	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark,
	int weight) {
	page_section = S;
	if (weight == 3) return; /* Skip chapter headings */
	HTMLFormat__exit_current_paragraph(OUT);
	if (P) {
		HTMLFormat__p(OUT, "inwebparagraph");
		TEMPORARY_STREAM
		HTMLFormat__xref(TEMP, wv, P, NULL, FALSE);
		HTML__anchor(OUT, TEMP);
		CLOSE_TEMPORARY_STREAM
		HTML__open(OUT, "b");
		WRITE("%s%s", (*(P->ornament) == 'S')?"&#167;":"&para;", P->paragraph_number);
		WRITE(". %s%s ", heading_text, (*heading_text)?".":"");
		HTML__close(OUT, "b");
	} else {
		if (crumbs_dropped == FALSE) {
			filename *C = Filenames__in_folder(path_to_inweb_materials, "crumbs.gif");
			Swarm__copy_file_into_weave(wv->weave_web, C);
			crumbs_dropped = TRUE;
		}
		HTML__open_with_class(OUT, "ul", "crumbs");
		HTMLFormat__breadcrumb(OUT, Bibliographic__get_data(wv->weave_web, "Title"), "index.html");
		string chapter_link;
		CSTRING_WRITE(chapter_link, "index.html#%s%s", (wv->weave_web->as_ebook)?"C":"", S->owning_chapter->ch_sigil);
		HTMLFormat__breadcrumb(OUT, S->owning_chapter->ch_title, chapter_link);
		HTMLFormat__breadcrumb(OUT, heading_text, NULL);
		HTML__close(OUT, "ul");
	}
}

void HTMLFormat__breadcrumb(OUTPUT_STREAM, char *text, char *link) {
	if (link) {
		HTML__open(OUT, "li");
		STRING(L);
		Str__copy_ISO_string(L, link);
		HTML__begin_link(OUT, L);
		WRITE("%s", text);
		HTML__end_link(OUT);
		HTML__close(OUT, "li");
	} else {
		HTML__open(OUT, "li");
		HTML__open(OUT, "b");
		WRITE("%s", text);
		HTML__close(OUT, "b");
		HTML__close(OUT, "li");
	}
}

#line 216 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__source_code(OUTPUT_STREAM, weave_target *wv, int tab_stops_of_indentation,
	char *prefatory, char *matter, char *colouring, char *concluding_comment,
	int starts, int finishes, int code_mode) {
	if (starts) {
		for (int i=0; i<tab_stops_of_indentation; i++)
			WRITE("    ");
		if (prefatory[0]) {
			HTML__open(OUT, "strong");
			WRITE("%s", prefatory);
			HTML__close(OUT, "strong");
			WRITE(" ");
		}
	}
	int current_colour = -1, colour_wanted = PLAIN_CODE;
	for (int i=0; matter[i]; i++) {
		colour_wanted = colouring[i]; 
{
#line 253 "inweb/Chapter 5/HTML Formats.w"
	if (colour_wanted != current_colour) {
		if (current_colour >= 0) HTML__close(OUT, "span");
		Formats__change_colour(OUT, wv, colour_wanted, TRUE);
		current_colour = colour_wanted;
	}

}
#line 231 "inweb/Chapter 5/HTML Formats.w"
;
		if (matter[i] == '<') WRITE("&lt;");
		else if (matter[i] == '>') WRITE("&gt;");
		else if (matter[i] == '&') WRITE("&amp;");
		else WRITE("%c", matter[i]);
	}
	if (current_colour >= 0) HTML__close(OUT, "span");
	current_colour = -1;
	if (finishes) {
		if (concluding_comment[0]) {
			if ((CStrings__ne(matter, "")) || (!starts)) WRITE("    ");
			HTML__open_with_class(OUT, "span", "comment");
			Formats__identifier(OUT, wv, concluding_comment);
			HTML__close(OUT, "span");
		}
		WRITE("\n");
	}
}

#line 262 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__inline_code(OUTPUT_STREAM, weave_target *wv, int enter) {
	if (enter) {
		if (html_in_para == HTML_OUT) HTMLFormat__p(OUT, "inwebparagraph");
		HTML__open_with_class(OUT, "code", "display");
	} else {
		HTML__close(OUT, "code");
	}
}

#line 274 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__comment_lines(OUTPUT_STREAM, weave_target *wv, source_line *from, source_line *to) {
}

#line 280 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__display_line(OUTPUT_STREAM, weave_target *wv, char *from) {
	HTMLFormat__exit_current_paragraph(OUT);
	HTML__open(OUT, "blockquote"); WRITE("\n"); INDENT;
	HTMLFormat__p(OUT, NULL);
	WRITE("%s", from);
	HTMLFormat__cp(OUT);
	OUTDENT; HTML__close(OUT, "blockquote"); WRITE("\n");
}

#line 292 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__item(OUTPUT_STREAM, weave_target *wv, int depth, char *label) {
	HTMLFormat__go_to_depth(OUT, depth);
	if (*label) WRITE("(%s) ", label);
	else WRITE(" ");

}

#line 302 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__bar(OUTPUT_STREAM, weave_target *wv) {
	HTMLFormat__exit_current_paragraph(OUT);
	HTML__hr(OUT, NULL);
}

#line 310 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__figure(OUTPUT_STREAM, weave_target *wv, char *figname, int cm) {
	HTMLFormat__exit_current_paragraph(OUT);
	HTML__open(OUT, "center");
	pathname *P = Pathnames__from_string("Figures");
	HTML__image(OUT, Filenames__in_folder(P, figname));
	HTML__close(OUT, "center");
	WRITE("\n");
}

#line 322 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__cweb_macro(OUTPUT_STREAM, weave_target *wv, cweb_macro *cwm, int defn) {
	paragraph *P = cwm->defining_paragraph;
	WRITE("&lt;");
	HTML__open_with_class(OUT, "span", (defn)?"cwebmacrodefn":"cwebmacro");
	WRITE("%s", cwm->macro_name);
	HTML__close(OUT, "span");
	WRITE(" ");
	HTML__open_with_class(OUT, "span", "cwebmacronumber");
	WRITE("%s", P->paragraph_number);
	HTML__close(OUT, "span");
	WRITE("&gt;%s", (defn)?" =":"");
}

#line 338 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__pagebreak(OUTPUT_STREAM, weave_target *wv) {
	HTMLFormat__exit_current_paragraph(OUT);
}

#line 345 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__blank_line(OUTPUT_STREAM, weave_target *wv, int in_comment) {
	if (html_in_para == HTML_IN_PRE) {
		WRITE("\n");
	} else {
		int old_state = html_in_para, old_depth = item_depth;
		HTMLFormat__exit_current_paragraph(OUT);
		if ((old_state == HTML_IN_P) || ((old_state == HTML_IN_LI) && (old_depth > 1)))
			HTMLFormat__p(OUT,"inwebparagraph");
	}
}

#line 359 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__code_note(OUTPUT_STREAM, weave_target *wv, char *comment) {
	HTMLFormat__exit_current_paragraph(OUT);
	HTMLFormat__p(OUT, NULL);
	WRITE("%s", comment);
	HTMLFormat__cp(OUT);
}

#line 369 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__change_mode(OUTPUT_STREAM, weave_target *wv, int old_mode, int new_mode, int content) {
	// WRITE("(CM%d:%d->%d)", content, old_mode, new_mode);
	if (old_mode != new_mode) {
		if (old_mode == MACRO_MATERIAL) HTML__close(OUT, "code");
		if ((content) || (new_mode != MACRO_MATERIAL)) HTMLFormat__exit_current_paragraph(OUT);
		switch (old_mode) {
			case CODE_MATERIAL:
			case REGULAR_MATERIAL:
				switch (new_mode) {
					case CODE_MATERIAL:
						WRITE("\n");
						HTMLFormat__pre(OUT, "display");
						break;
					case DEFINITION_MATERIAL:
						WRITE("\n");
						HTMLFormat__pre(OUT, "definitions");
						break;
					case MACRO_MATERIAL:
						if (content) {
							WRITE("\n");
							HTMLFormat__p(OUT,"macrodefinition");
						}
						HTML__open_with_class(OUT, "code", "display");
						WRITE("\n");
						break;
					case REGULAR_MATERIAL:
						if (content) {
							WRITE("\n");
							HTMLFormat__p(OUT,"inwebparagraph");
						}
						break;
				}
				break;
			case MACRO_MATERIAL:
				switch (new_mode) {
					case CODE_MATERIAL:
						WRITE("\n");
						HTMLFormat__pre(OUT, "displaydefn");
						break;
					case DEFINITION_MATERIAL:
						WRITE("\n");
						HTMLFormat__pre(OUT, "definitions");
						break;
				}
				break;
			case DEFINITION_MATERIAL:
				switch (new_mode) {
					case CODE_MATERIAL:
						WRITE("\n");
						HTMLFormat__pre(OUT, "display");
						break;
					case MACRO_MATERIAL:
						WRITE("\n");
						HTMLFormat__p(OUT, "macrodefinition");
						HTML__open_with_class(OUT, "code", "display");
						WRITE("\n");
						break;
				}
				break;
			default:
				HTMLFormat__cpre(OUT);
				break;
		}
	}
}

#line 438 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__change_colour(OUTPUT_STREAM, weave_target *wv, int col, int in_code) {
	char *cl = "plain";
	switch (col) {
		case MACRO_CODE: 		cl = "cwebmacrotext"; break;
		case FUNCTION_CODE: 	cl = "functiontext"; break;
		case IDENTIFIER_CODE: 	cl = "identifier"; break;
		case ELEMENT_CODE:		cl = "element"; break;
		case RESERVED_CODE: 	cl = "reserved"; break;
		case STRING_CODE: 		cl = "string"; break;
		case CHAR_LITERAL_CODE: cl = "character"; break;
		case CONSTANT_CODE: 	cl = "constant"; break;
		case PLAIN_CODE: 		cl = "plain"; break;
		default: printf("col: %d\n", col); internal_error("bad colour"); break;
	}
	HTML__open_with_class(OUT, "span", cl);
}

#line 458 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__endnote(OUTPUT_STREAM, weave_target *wv, int end) {
	if (end == 1) {
		HTMLFormat__exit_current_paragraph(OUT);
		HTMLFormat__p(OUT, "endnote");
	} else {
		HTMLFormat__cp(OUT);
	}
}

#line 470 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__identifier(OUTPUT_STREAM, weave_target *wv, char *id) {
	for (int i=0; id[i]; i++) {
		if (html_in_para == HTML_OUT) HTMLFormat__p(OUT, "inwebparagraph");
		if (id[i] == '&') WRITE("&amp;");
		else if (id[i] == '<') WRITE("&lt;");
		else if (id[i] == '>') WRITE("&gt;");
		else if ((id[i] == ' ') && (id[i+1] == '-') && (id[i+2] == '-') &&
			((id[i+3] == ' ') || (id[i+3] == 0))) {
			WRITE(" &mdash;"); i+=2;
		} else WRITE("%c", id[i]);
	}
}

#line 486 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__locale(OUTPUT_STREAM, weave_target *wv, paragraph *par1, paragraph *par2) {
	TEMPORARY_STREAM
	HTMLFormat__xref(TEMP, wv, par1, page_section, TRUE);
	HTML__begin_link(OUT, TEMP);
	CLOSE_TEMPORARY_STREAM
	WRITE("%s%s",
		(*(par1->ornament) == 'S')?"&#167;":"&para;",
		par1->paragraph_number);
	if (par2) WRITE("-%s", par2->paragraph_number);
	HTML__end_link(OUT);
}

#line 501 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__xref(OUTPUT_STREAM, weave_target *wv, paragraph *P, section *from, int a_link) {
	string linkto;
	CStrings__copy(linkto, "");
	if ((from) && (P->under_section != from)) {
		CStrings__copy(linkto, P->under_section->sigil);
		for (int i=0; linkto[i]; i++)
			if ((linkto[i] == '/') || (linkto[i] == ' '))
				CStrings__set_char(linkto, i, '-');
		CStrings__concatenate(linkto, ".html");
	}
	WRITE("%s%s%s", linkto, (a_link)?"#":"", P->ornament);
	char *N = P->paragraph_number;
	for (int i=0; N[i]; i++)
		if (N[i] == '.') WRITE("_");
		else WRITE("%c", N[i]);
}

#line 521 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__tail(OUTPUT_STREAM, weave_target *wv, char *comment) {
	HTMLFormat__exit_current_paragraph(OUT);
	HTML__comment(OUT, comment);
	HTML__completed(OUT);
	filename *T = Filenames__in_folder(path_to_inweb_materials, "template");
	Bibliographic__set_datum(wv->weave_web, "Booklet Title", wv->booklet_title);
	Weaver__weave_cover_from(OUT, wv->weave_web, T, wv, WEAVE_SECOND_HALF);
}

#line 30 "inweb/Chapter 5/Running Through TeX.w"

#line 34 "inweb/Chapter 5/Running Through TeX.w"
int serious_error_count = 0;
tex_results *via_tex = NULL;

void RunningTeX__post_process_weave(weave_target *wv, int open_afterwards) {
	tex_results *res = CREATE(tex_results);
	wv->post_processing_results = (void *) res;
	res->overfull_hbox_count = 0;
	res->tex_error_count = 0;
	res->page_count = 0;
	res->pdf_size = 0;

	filename *console_filename = Filenames__set_extension(wv->weave_to, "console");
	filename *log_filename = Filenames__set_extension(wv->weave_to, "log");
	filename *pdf_filename = Filenames__set_extension(wv->weave_to, "pdf");
	res->PDF_filename = pdf_filename;

	serious_error_count = 0; via_tex = res;

	
{
#line 62 "inweb/Chapter 5/Running Through TeX.w"
	TEMPORARY_STREAM
	filename *tex_rel = Filenames__without_path(wv->weave_to);
	filename *console_rel = Filenames__without_path(console_filename);

	Shell__plain(TEMP, "cd ");
	Shell__quote_path(TEMP, Filenames__get_path_to(wv->weave_to));
	Shell__plain(TEMP, "; ");

	char *tool = pdftex_configuration;
	if (wv->format == dvi_format) tool = tex_configuration;
	Shell__plain(TEMP, tool);
	Shell__plain(TEMP, " -interaction=scrollmode ");
	Shell__quote_file(TEMP, tex_rel);
	Shell__plain(TEMP, ">");
	Shell__quote_file(TEMP, console_rel);
	Shell__run(TEMP);
	CLOSE_TEMPORARY_STREAM

}
#line 52 "inweb/Chapter 5/Running Through TeX.w"
;
	
{
#line 85 "inweb/Chapter 5/Running Through TeX.w"
	TextFiles__read_with_lines_to_ISO(console_filename,
		"can't open console file", TRUE, RunningTeX__scan_console_line, NULL, NULL);

}
#line 53 "inweb/Chapter 5/Running Through TeX.w"
;
	
{
#line 96 "inweb/Chapter 5/Running Through TeX.w"
	if (serious_error_count == 0) {
		Shell__rm(console_filename);
		Shell__rm(log_filename);
		Shell__rm(wv->weave_to);
	}

}
#line 54 "inweb/Chapter 5/Running Through TeX.w"
;

	if (open_afterwards) 
{
#line 105 "inweb/Chapter 5/Running Through TeX.w"
	if (CStrings__eq(open_configuration, ""))
		Errors__fatal("no way to open PDF (see configuration file)");
	else
		Shell__apply(open_configuration, pdf_filename);

}
#line 56 "inweb/Chapter 5/Running Through TeX.w"
;
}

#line 113 "inweb/Chapter 5/Running Through TeX.w"
void RunningTeX__scan_console_line(char *line, text_file_position *tfp, void *unused_state) {
	string found_text1;
	string found_text2;
	if (ISORegexp__match_2(line, "Output written %c*? %((%d+) page%c*?(%d+) bytes%).", found_text1, found_text2)) {
		via_tex->page_count = atoi(found_text1);
		via_tex->pdf_size = atoi(found_text2);
	}
	if (ISORegexp__match_0(line, "%c+verfull \\hbox%c+"))
		via_tex->overfull_hbox_count++;
	else if (line[0] == '!') {
		via_tex->tex_error_count++;
		serious_error_count++;
	}
}

#line 131 "inweb/Chapter 5/Running Through TeX.w"
void RunningTeX__report_on_post_processing(weave_target *wv) {
	tex_results *res = wv->post_processing_results;
	if (res) {
		printf(": %dpp %dK", res->page_count, res->pdf_size/1024);
		if (res->overfull_hbox_count > 0)
			printf(", %d overfull hbox(es)", res->overfull_hbox_count);
		if (res->tex_error_count > 0)
			printf(", %d error(s)", res->tex_error_count);
	}
}

#line 145 "inweb/Chapter 5/Running Through TeX.w"
int RunningTeX__substitute_post_processing_data(char *to, weave_target *wv, char *detail) {
	if (wv) {
		tex_results *res = wv->post_processing_results;
		if (res) {
			if (CStrings__eq(detail, "PDF Size")) {
				CSTRING_WRITE(to, "%dKB", res->pdf_size/1024);
			} else if (CStrings__eq(detail, "Extent")) {
				CSTRING_WRITE(to, "%dpp", res->page_count);
			} else if (CStrings__eq(detail, "Leafname")) {
				Str__copy_to_ISO_string(to, Filenames__get_leafname(res->PDF_filename), MAX_FILENAME_LENGTH);
			} else if (CStrings__eq(detail, "Errors")) {
				CStrings__copy(to, "");
				if ((res->overfull_hbox_count > 0) || (res->tex_error_count > 0))
					CSTRING_WRITE(to, ": ");
				if (res->overfull_hbox_count > 0)
					CSTRING_WRITE(to + CStrings__len(to), "%d overfull line%s",
						res->overfull_hbox_count,
						(res->overfull_hbox_count>1)?"s":"");
				if ((res->overfull_hbox_count > 0) && (res->tex_error_count > 0))
					CSTRING_WRITE(to + CStrings__len(to), ", ");
				if (res->tex_error_count > 0)
					CSTRING_WRITE(to + CStrings__len(to), "%d TeX error%s",
						res->tex_error_count,
						(res->tex_error_count>1)?"s":"");
			} else return FALSE;
			return TRUE;
		}
	}
	return FALSE;
}

void register_tangled_nonterminals(void) {
}
